<!DOCTYPE html>
<html lang="en">
<head>
 <meta name="author" content="Harris Hudson.  harris@harrishudson.com"/>
 <title>Visual Field</title>
 <meta name="description" content="Explore, Process and Visualize your data right in your browser."/>
 <meta id="application-name" name="application-name" content="Visual Field (v1.0.0 - Released Dec 2019)."/>
 <meta charset="UTF-8"/>
 <meta name="viewport" content="width=device-width, initial-scale=1"/>
 <link id="ico" rel="icon" href="" type="image/png">
 <script src="https://npmcdn.com/@turf/turf@5.1.6/turf.min.js"></script>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"/>
 <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/leaflet.markercluster-src.min.js"></script>
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css"/>
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/MarkerCluster.css"/>
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2.4.0/src/easy-button.css">
 <script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2.4.0/src/easy-button.js"></script>
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.css"/>
 <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script>
 <script>var module={};module.exports={};var exports={};var jQuery={};</script>
 <script src="https://cdn.jsdelivr.net/npm/jquery-csv@1.0.5/src/jquery.csv.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/stemmer@1.0.4/index.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/double-metaphone@1.0.4/index.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/wellknown@0.5.0/index.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/node-vincenty@0.0.6/vincenty.min.js"></script>
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"/>

<style>
/* Menu bar styling */
body {margin: 0px; font-family:Helvetica}
.topnav {overflow:hidden;background-color:#333;}
.topnav a {float:left;display:block;color:#f2f2f2;text-align:center;padding:14px 16px;text-decoration:none;font-size:17px;}
.active {background-color:#4CAF50;color:white;}
.topnav .icon {display:none;}
.dropdown {float:left;overflow:hidden;}
.dropdown .dropbtn {font-size:17px;border:none;outline:none;color:white;padding:14px 16px;background-color:inherit;font-family:inherit;margin:0;}
.dropdown-content {display:none;position:absolute;background-color:#f9f9f9;min-width:160px;box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);z-index: 1000;}
.dropdown-content a {float:none;color:black;padding:12px 16px;text-decoration:none;display:block;text-align:left;}
.topnav a:hover, .dropdown:hover .dropbtn {background-color:#555;color:white;}
.dropdown-content a:hover {background-color:#ddd;color:black;}
.dropdown:hover .dropdown-content {display:block;}
@media screen and (max-width: 600px) {
  .topnav a:not(:first-child), .dropdown .dropbtn {display:none;}
  .topnav a.icon {float:right;display:block;}
}
@media screen and (max-width: 600px) {
  .topnav.responsive {position:relative;}
  .topnav.responsive .icon {position:absolute;right:0;top:0;}
  .topnav.responsive a {float:none;display:block;text-align:left;}
  .topnav.responsive .dropdown {float:none;}
  .topnav.responsive .dropdown-content {position:relative;}
  .topnav.responsive .dropdown .dropbtn {display:block;width:100%;text-align:left;}
}
/* File drag/drop styling */
input[type="file"] {position:absolute;left:0;opacity:0;top:0;bottom:0;width:100%}
.filediv {position:absolute;top:0;bottom:0;width:100%;display:flex;align-items:center;
	 justify-content:center;background:#dcc;border:3px dotted #bebebe;border-radius:10px}
.quickfilediv {position:absolute;top:0;bottom:0;width:100%;display:flex;align-items:center;
	       justify-content:center;background:#dcc;border:3px dotted #bebebe;border-radius:10px}
.metadatafilediv {position:absolute;top:0;bottom:0;width:100%;display:flex;align-items:center;
	          justify-content:center;background:#acc;border:3px dotted #bebebe;border-radius:10px}
.filelabel {display:inline-block;position:relative;height:75px;width:600px;max-width:80%}
div.dragover {background-color:#aaa}
/* Button styling */
button {background:#f9f9f9;padding:5px;border-radius:2px;border:1px solid #C66; margin: 1px}
button:hover {background:#EDD}
.easy {background:#f9f9f9 !important}
.easy:hover {background:#EDD !important}
/* Result set styling */
table.rs {border:1px solid #d0d0d0;border-collapse:collapse;}
.rs tr { border:1px solid #d0d0d0}
.rs {padding:3px;margin:4px;font-size:12px}
.rs td {border:1px solid #d0d0d0;padding: 3px;font-size: 12px}
.rs:nth-child(odd) td {background:#F9F9F9}
.rs:nth-child(even) td {background:#FFFFFF}
.rs tr:hover td {background:#F3F3FF}
.rs-small {font-size:11px}
.bold {font-weight:bolder;color:green}
.bold a {font-weight:bolder;color:green}
.hdr1 {font-size:13px; font-weight: bold}
.hdr1 td { padding: 6px; background: #EFEFEF !important}
.hdr1 a, .hdrg, .info_success, a.hdr1 {color:green}
.hdr1-small {font-size:10px}
.hdrb {color:darkblue}
.nobr {white-space: nowrap}
/* General Info */
.error, td.error {color:red;background:#FFFFF3 !important;}
.info1 {color:blue}
.alert {color:red}
.required {color: darkblue; background-color: #F3F3FF}
.blk {width:100%;display:block;} 
/* CSV previews */
pre.preview {width:80%;height:100px;background:#eef;overflow:auto;
             border:solid 1px black;font-size: 9px;font-family:monospace;}
/* Info in Help pages */
pre.info {width:480px;max-width:80%;background:#eff;overflow:auto;
	  border:solid 1px black;font-size: 12px;font-family:monospace;}
/* Chart styling */
.chart-legend li span {display:inline-block;width:8px;height:8px;margin-right:5px;}
.chart-legend li {list-style-type:none !important;list-style:none !important;}
/* Additional Map and Chart styling */
.map_title {position:absolute;top:12px;left:50px;background:rgba(255,255,255,0.7);z-index:4000;
	    font-size:larger;font-weight:bolder;padding:2px;pointer-events:none}
.throbber {height:100vh;width:100vw;position:absolute;top:0px;left:0px;display:flex;
	   justify-content:center;align-items:center;z-index:4000;pointer-events:none}
/* Additional Media query for smallscreen result set split */
@media (max-width: 600px) {
 .largescreen_only {display:none;}
 .smallscreen_only {display:block;}
}
@media (min-width: 600px) {
 .largescreen_only {display:block;}
 .smallscreen_only {display:none;}
}
hr {width:80%;text-align:center}
</style>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->
<!-- Begin Embedded 3rd party scripts (where unable to find any public web hosted version -->
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->
<script>
// Regular Expression for URL validation
// Author: Diego Perini
// Created: 2010/12/05
// Updated: 2018/09/12
// License: MIT
// Copyright (c) 2010-2018 Diego Perini (http://www.iport.it)
//   http://mathiasbynens.be/demo/url-regex
//
var re_weburl = new RegExp(
  "^" +
    // protocol identifier (optional)
    // short syntax // still required
    "(?:(?:(?:https?|ftp):)?\\/\\/)" +
    // user:pass BasicAuth (optional)
    "(?:\\S+(?::\\S*)?@)?" +
    "(?:" +
      // IP address exclusion
      // private & local networks
      "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
      "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
      "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +
      // IP address dotted notation octets
      // excludes loopback network 0.0.0.0
      // excludes reserved space >= 224.0.0.0
      // excludes network & broadcast addresses
      // (first & last IP address of each class)
      "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
      "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
      "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
    "|" +
      // host & domain names, may end with dot
      // can be replaced by a shortest alternative
      // (?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.)+
      "(?:" +
        "(?:" +
          "[a-z0-9\\u00a1-\\uffff]" +
          "[a-z0-9\\u00a1-\\uffff_-]{0,62}" +
        ")?" +
        "[a-z0-9\\u00a1-\\uffff]\\." +
      ")+" +
      // TLD identifier name, may end with dot
      "(?:[a-z\\u00a1-\\uffff]{2,}\\.?)" +
    ")" +
    // port number (optional)
    "(?::\\d{2,5})?" +
    // resource path (optional)
    "(?:[/?#]\\S*)?" +
  "$", "i"
);
</script>
<!-- - - - - - - - - - - - - - - - - - -->
<!-- End of Embedded 3rd party scripts -->
<!-- - - - - - - - - - - - - - - - - - -->


<!-- Visual Field Core Engine Javascript -->
<script>
// Will log console output if set to true;
const gDEBUG=false;

// Setup for offline use
if ('serviceWorker' in navigator) {
 try {
  navigator.serviceWorker.register('vf_service_worker.js').catch(function(e) { console.info('Service worker request failed.');});
     } catch(e) { console.info('Service worker request failed.'); }
}

//Internal limits
const gMAX_FILE_SIZE_MB_FOR_FULL_PARSE=20;  
const gMAX_CHART_ROWS=10000;
const gMAX_MAP_ROWS=120000;
const gMAX_UNCLUSTERED_POINTS=3000;
const gMAX_PIE_HEADER_ROWS=30;	
const gUNPAGINATED_MAX_ROWS=100;

/* ----- Begin Reference Metadata ----- */

// Map base layers.

const gSAMPLE_TILE_LAYERS= 
	[
        {title: 'OpenStreetMap', 
         url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', 
         attrib: 'Tiles (c) OpenStreetMap' },
        {title: 'Esri.WorldTopoMap', 
         url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', 
         attrib: 'Tiles (c) Esri'},
        {title: 'Esri.WorldImagery', 
         url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', 
         attrib: 'Tiles (c) Esri'},
        {title: 'OSM', 
         url: 'http://{s}.tile.osm.org/{z}/{x}/{y}.png', 
         attrib: 'Tiles (c) OpenStreetMap' },
        {title: 'OpenTopoMap',
         url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
         attrib: 'Tiles (c) OpenStreetMap Style (c) OpenTopoMap'},
        {title: 'GA NationalMap Colour Topographic Base',
         url: 'http://services.ga.gov.au/site_7/rest/services/NationalMap_Colour_Topographic_Base_World_WM/MapServer/'+
	       'WMTS/tile/1.0.0/NationalMap_Colour_Topographic_Base_World_WM/default/default028mm/{z}/{y}/{x}.png',
         attrib: 'Tiles Geoscience Australia'},
        {title: 'GA NationalMap GreyScale Topographic Base',
         url: 'http://services.ga.gov.au/site_7/rest/services/NationalMap_GreyScale_Topographic_Base_World_WM/MapServer/'+
               'WMTS/tile/1.0.0/NationalMap_Colour_Topographic_Base_World_WM/default/default028mm/{z}/{y}/{x}.png',
         attrib: 'Tiles Geoscience Australia'},
        {title: 'Hydda Full',
         url: 'https://{s}.tile.openstreetmap.se/hydda/full/{z}/{x}/{y}.png',
         attrib: 'Tiles courtesy of OpenStreetMap Sweden'},
        {title: 'Stamen Terrain',
         url: 'https://stamen-tiles-a.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png',
         attrib: 'Tiles by Stamen Design'}
        ];


// Export/Import Metadata definition 

const gVF_DEFINITION=
	{VERSION: 1,
		CONFIG: [{param:'CONFIG_DB_NAME',
		          help:'The WebSQL database name (fixed in this version of Visual Field to "vf")'},
			 {param: 'CONFIG_DB_SIZE',
		           help: 'Size in Mb of WebSQL database'},
			 {param: 'CONFIG_SEQUENCE_LIMIT',
			  help: 'The maximum number of tasks that can make up any sequence (used for sequence expansion limit)'},
                         {param: 'CONFIG_SHOW_STATUS',
		          help: 'Indicates whether to simply display the Status pane during sequence execution. '+
			        'The Status Pane will give an overall summary of the task execution.  Unselecting '+
				  ' this will give a higher level of feedback during sequence execution by switching '+
				  ' between the relevant screens whilst the sequence is running.  So unchecking this '+
				  ' can give improved diagnostic feedback which may be useful during report development.'},
			 {param: 'CONFIG_FIELD_TRUNCATE',
		          help: 'The display of any fields will be truncated to this many characters'},
			 {param: 'CONFIG_PAGE_SIZE',
			  help: 'The number of rows to show per page on SQL Display output and Browse table panes'},
                         {param: 'CONFIG_MAP_BASE_URL',
		          help: 'The Leaflet Tile Map URL to be used for Map Visualizations'},
                         {param: 'CONFIG_MAP_ATTRIBUTION',
		          help: 'The Tile Attribution to be shown on the Leaflet map as part of any Map Visualizations'},
			 {param: 'CONFIG_DEVICE_ATTRIBUTES_TASK_ID',
			  help: 'The Task Id that is associated with collection of Device Attributes'},
			 {param: 'CONFIG_PAGELOAD_TASK_TYPE',
		          help: 'Either "Literal Constant" or "Query String Param". Indicates how to interpret any '+
				 'Page load Start sequence value from the CONFIG_PAGELOAD_TASK_VALUE setting'},
		         {param: 'CONFIG_PAGELOAD_TASK_VALUE',
		          help: 'The value to be interpreted for any Page Load Start Sequence or Task Id'}],
	  TABLES: [
            {TABLE: 'VF_TABLES',  
              help: 'Used to house importation metadata and the corresponding underlying database table.',
	      applicable_screens: 'Table (Import File) and Table (Import URL)',
	      primary_key_column: ["TABLE_NAME"],
	      COLUMNS: [
               {column:'TABLE_TYPE', help:'Type of Table. Either "FILE" or "URL"' },          
               {column:'TABLE_NAME', help:'Name of actual database Table'},
	       {column:'FILE_NAME_DEDUPED', help:'Name of file imported (file name deduplicated). '+
	                                         'Used for TABLE_TYPE=FILE only.  Not applicable to URL imports.'},
               //{column:'FILE_SIZE', help:'Size of File'},
	       //{column:'FILE_LAST_MODIFIED', help:'Last file modification timestamp'},
	       //{column:'FILE_LAST_MODIFIED_DATE', help:'Human readable Last file modification timestamp'},
	       {column:'FILE_TYPE', help:'File Content-Type'},
	       {column:'URI', help:'The URI used for URL imported files.  Not applicable to FILE based tables.'},
	       {column:'CHARSET', help:'Current The URI used for URL imported files.  This field is currently ignored. '+
	                                'Leave as empty/null or "UTF-8".  Reserved for future use.'},
	       {column:'SEPARATOR', help:'The field separator. If tab, comma, semi-colon.  If another separator is being'+
	                               ' used, then set this to "Custom" and populate CUSTOM_SEPARATOR. Default is comma.'},
               {column:'CUSTOM_SEPARATOR', help:'Populate with the field separator. Used when SEPARATOR="Custom".'},
	       {column:'DELIMITER', help:'The field delimiter. Quote delimiter character.  Can be single or double quote. '+
	                                 'If another delimiter is being used, then set this to "Custom" and populate '+
				         'CUSTOM_DELIMITER. Default is double quote.'},
	       {column:'CUSTOM_DELIMITER', help:'Populate with the field delimiter. Used when DELIMITER="Custom".'},
	       {column:'SKIP_FIRST_LINES', help:'The number of lines in the input file to be skipped before parsing.'+
	  	                              ' Default: 0.'},
	       {column:'HEADER_ROW', help:'1 indicates a header row is present, 0 indicates no header row.  A header row '+
		                       ' has the table column names.  If no header row is used, table columns will '+
		                       ' be named; F1, F2, F3 and so on.'},
	       {column:'EMPTY_AS_NULL', help:'1 indicates empty strings in the input file will be created as null database '+
		                           ' values whereas 0 indicates empty strings in the input file will be created '+
		                           ' as empty database strings. Default: 1.'},
	       {column:'IS_TEMP', help:'1 indicates the destination table will be created as a TEMP table.  0 indicates '+
		                    ' the destination table will be created as a normal database table.  Temporary tables '+
		                    ' will not exist between subsequent page reloads. Default: 0.'},
	       {column:'FILE_IMPORT_START_TASK_ID', help:'Indicates the Task (TASK_ID) to automatically be started after '+
	                                                 ' the import of a FILE table (TABLE_TYPE=FILE).'},
               {column:'FILE_IMPORT_AUTOMATE', help:'1 indicates that the file import should be automated upon any '+
		  				  ' subsequent file drop for the given FILE_NAME_DEDUPED.  0 indicates that '+
		                                  ' the file importation should not be automated.  Default: 0.'},
	       //{column:'LAST_TABLE_REFRESH', help:'A datetime stamp when of the last time the URL FILE (TYPE=URL) was '+
               //		                               ' refreshed (Imported).  Used in conjunction with URI_CACHE_MAX_AGE '+
		//				    ' for Caching of local URL file imported. '},
	       {column:'URI_CACHE_MAX_AGE', help:'The number of seconds that must elapse before a URL Import will refetch '+
		                               ' the requested URI when invoked as a Task.  Not applicable (is ignored) if the '+
		                               ' Import is run manually.  If the number of seconds has '+
		                               ' not elapsed since the last refresh, the Import task will complete successfully '+
		                               ' without any fetch/import action.  Applicable only to FILE_TYPE="URL".'},
	       {column:'URI_HEADER_NAME1', help:'An optional HTTP header name that will be passed to a URL table fetch.'},
	       {column:'URI_HEADER_VALUE1', help:'An optional HTTP header value that will be passed to a URL table fetch.'},
	       {column:'URI_HEADER_NAME2', help:'An optional HTTP header name that will be passed to a URL table fetch.'},
	       {column:'URI_HEADER_VALUE2', help:'An optional HTTP header value that will be passed to a URL table fetch.'},
	       {column:'URI_TASK_ID', help:'The Task Id associated with the TYPE=URL table import.'}
	      ]
	     },
            {TABLE: 'VF_SQL',  
             help: 'Used to house SQL Statements.',
	     applicable_screens: 'SQL Statement',
	     primary_key_column: ["LABEL"],
	     COLUMNS: [
              {column:'LABEL', help:'Description of SQL Statement' },          
              {column:'TASK_ID', help:'The Task Id associated with this Statement' },          
              {column:'STATEMENT', help:'The SQL Statement' }          
           ]
	  },
            {TABLE: 'VF_SEQUENCE',  
             help: 'Used to house Sequence definitions.',
	     applicable_screens: 'Sequence',
	     primary_key_column: ["TASK_ID"],
	     COLUMNS: [
              {column:'LABEL', help:'Description of the Sequence' },          
              {column:'TASK_ID', help:'The Task Id associated with this Sequence' },          
              {column:'COMPONENT_TASK_IDS', help:"The component Task Id's that make up this Sequence" }          
           ]
	  },
            {TABLE: 'VF_PROMPT_INPUT',  
             help: 'Used to house Prompt Inputs.',
	     applicable_screens: 'Prompt Input',
	     primary_key_column: ["LABEL"],
	     COLUMNS: [
              {column:'LABEL', help:'Description of Prompt Input' },          
              {column:'PROMPT_TEXT', help:'The Text to Appear in the Prompt' },          
              {column:'QUERY_STRING_NAME', help:'The name of the Query String parameter to be used as both '+
		                                 'the default value and value to be set upon completion' },          
              {column:'TASK_ID', help:'The Task Id associated with this Prompt Input' },          
           ]
	  },
            {TABLE: 'VF_CUSTOM_FUNCTION',  
             help: 'Used to house Custom Functions.',
	     applicable_screens: 'Custom Function',
	     primary_key_column: ["LABEL"],
	     COLUMNS: [
              {column:'LABEL', help:'Description of Custom Function' },          
              {column:'INPUT_SOURCE_TABLE', help:'Input Source Table Name' },          
              {column:'FUNCTION_ID', help:'The Visual Field Function Index Number (Refer to Custom Function Index)' },          
              {column:'RESULT_OUTPUT_TABLE', help:'The Function Output Table Name' },          
              {column:'IS_TEMP', help:'1 - The Result Table should be created as a TEMP table, '+
		                       '0 - the Result Table should be created as a regular table' },          
              {column:'TASK_ID', help:'The Task Id associated with this Custom Function' }        
           ]
	  },
            {TABLE: 'VF_CUSTOM_FUNCTION_PARAMETER',  
             help: 'Used to house Custom Functions Parameters',
	     applicable_screens: 'Custom Function',
	     primary_key_column: ["LABEL","PARAMETER_INDEX"],
	     COLUMNS: [
              {column:'LABEL', help:'Unique Description of Custom Function' },          
              {column:'PARAMETER_INDEX', help:'Index of the Parameter '+
	                               '(specifically relating to the particular Custom Function), Starting with zero. ' },          
              {column:'PARAMETER_TYPE', help:'The Type of the Parameter '+
		                               '("Literal Constant", "Column Value" or "Query String Param"). '+
		                               '"Literal Constant" will use the specified Parameter Value, '+
		                               '"Column Value" - will specify the table column value to be used as '+
		                               'the parameter value and "Query String Param" - specifies the query '+
		                               'string parameter name to be used.'},          
              {column:'PARAMETER_VALUE', help:'The Value of the Parameter' }       
           ]
	  },
            {TABLE: 'VF_RUN_MENU',  
             help: 'Used to house Run Menu Entries',
	     applicable_screens: 'Define Menu',
	     primary_key_column: ["LABEL"],
	     COLUMNS: [
              {column:'LABEL', help:'Description of Run Menu Entry' },          
              {column:'TITLE', help:'The value to be assigned to the Title '+
		                      'attribute of Menu Entry hyperlink'},
              {column:'TASK_ID', help:'The Task Id that will be run upon selection of this menu entry '},
              {column:'RELATIVE_ORDER', help:'The Relative Ordering (sequencing) of the display in the drop down menu' }       
           ]
	  },
            {TABLE: 'VF_TABLE_VISUALIZATION',  
             help: 'Used to house Table Visualizations',
	     applicable_screens: 'Table Visualization',
	     primary_key_column: ["LABEL"],
	     COLUMNS: [
              {column:'LABEL', help:'Unique Description of Table Visualization' },          
              {column:'OBJECT_NAME', help:'The table or view as the source data input to this Table Visualization' },          
              {column:'DISPLAY_THEME', help:'Currently unused. Reserved for future use.  Leave as null/empty.' },          
              {column:'TITLE_TYPE', help:'The type of Title used in the Table Visualization ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table column value.  If this is set to "Column Value" then that particular '+
		                           'column will be omitted from the tabular table listing.' },          
	      {column:'TITLE_VALUE', help:'The value of the Table Visualization Title Displayed'},
	      {column:'TASK_ID', help:'The Task Id that will be for this Table Visualization'},
	      {column:'LINKS_TARGET', help:'If specified will be passed to the "target" attribute of any hyperlinks. '+
		                            'May be useful if the visualization is being called within an iframe.'},
	      {column:'DRILLDOWN_COLUMN', help:'The table column to be used for self referencing Drill Down.  Must be in '+
		                                 'the form of a Query String name value pairs, (eg, p1=v1&p2=v2, etc). '+
		                                 ' Do not include question mark'},
	      {column:'DRILLDOWN_LABEL', help:'The text label to be displayed within the column output instead of this DRILLDOWN_COLUMN field value'},
              {column:'DRILLDOWN_APPEND_METADATA', help:'1 - if the page is invoked with a passed METADATA parameter, this parameter will '+
		                                         ' be appended to the drilldown URL. 0 - the original METADATA parameter will not be '+
		                                         ' appended to the drilldown URL' },       
           ]
	  },
            {TABLE: 'VF_CHART_VISUALIZATION',  
             help: 'Used to house Chart Visualizations',
	     applicable_screens: 'Chart Visualization',
	     primary_key_column: ["LABEL"],
	     COLUMNS: [
              {column:'LABEL', help:'Unique Description of this Chart Visualization' },          
              {column:'OBJECT_NAME', help:'The Table or View as the source data input to this Chart Visualization' },          
              {column:'BACKGROUND_COLOR', help:'The chart background color.  Must be in the form of a hex triplet '+
		       				' as this will internally be converted to an rgba value during rendering. '},
              {column:'DISPLAY_THEME', help:'A CSV (comma separated) list of color hex triplets.  This will be used '+
		                             ' as the color scheme when rendering Pie Chart Visualizations. '+
		                             'Not applicable to Line and Bar charts.'},
              {column:'TITLE_TYPE', help:'The type of Title used in the Chart Visualization ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table column value.' },          
	      {column:'TITLE_VALUE', help:'The value of the Chart Visualization Title Displayed.'},
	      {column:'TASK_ID', help:'The Task Id that will associated with this Chart Visualization'},
	      {column:'LINKS_TARGET', help:'If specified, will be passed to the "target" attribute of any hyperlinks. '+
		                            'May be useful if the visualization is being called within an iframe.'},
              {column:'DRILLDOWN_APPEND_METADATA', help:'1 - if the page is invoked with a passed METADATA parameter, this parameter will '+
		                                         ' be appended to any the drilldown URLs. 0 - the original METADATA parameter will not be '+
		                                         ' appended to any drilldown URLs.' },       
	      {column:'X_AXIS_COLUMN', help:'The column that will make up the X-Axis of a Line or Bar chart or the '+
		                             'or the reference value for a Pie chart.'},
	      {column:'X_AXIS_ORDER_BY_COLUMN', help:'The column that the OBJECT_NAME (input source Table or View) will be ordered by.'+
		                                      ' Or, in the case of a Pie chart, the sector ordering.'},
	      {column:'X_AXIS_ORDER_BY_DIRECTION', help:'The order by direction, either "asc" or "desc"'},
	      {column:'STACKED', help:'Applicable to Line series or Bar series only.  Not applicable to Pie charts. '+
		                       '1 - means the rendering will stack the Line and Bar series in the chart. '+
		                       '0 - means the rendering will NOT stack the Line or Bar series in the chart.'},
	      {column:'SERIES1_TYPE', help:'The charting type for this data series.  Can be either; "Line", "Bar" or "Pie".'+
		                             'Charts can consist of multiple Line and Bar series (upto 4 series).  However, '+
		                             'in the case of a Pie chart - only 1 data series (series 1) is permitted. '+
		                             'If this value is set to "Pie" - then the remaining data series 2-4 '+
		                             'are simply ignored during rendering.'},
	      {column:'SERIES1_AXIS_ORIENT', help:'Applicable only to Line and Bar charts. May be either "Left" or "Right" and '+
		                                   'specifies the Y-Axis alignment.  Line and Bar charts may have both a left and '+
		                                   'right axis for different series.'},
	      {column:'SERIES1_Y_AXIS_COLUMN', help:'This is the numeric data column used for the chart rendering.  For Pie charts '+
		                                     'this is the data column and for Line and Bar charts this will be the Y-Axis '+
		                                     'column.'},
	      {column:'SERIES1_DRILLDOWN_COLUMN', help:'The chart column to be used for self referencing Drill Down.  Must be in '+
		                                        'the form of a Query String name value pairs, (eg, p1=v1&p2=v2, etc). '+
		                                        ' Do not include question mark.  Clicking on the rendered chart element '+
		                                        'will invoke the self referencing drilldown link.'},
	      {column:'SERIES1_COLOR', help:'A hex triplet color for this chart series.  Used for Line and Bar charts only. '+
		                             'This value is not used for Pie chart visualizations.'},
	      {column:'SERIES2_TYPE', help:'The charting type for this data series.  Can be either; "Line" or "Bar".'+
		       		  	    'Charts can consist of multiple Line and Bar series (upto 4 series) '},
	      {column:'SERIES2_AXIS_ORIENT', help:'Applicable only to Line and Bar charts. May be either "Left" or "Right" and '+
		                                   'specifies the Y-Axis alignment.  Line and Bar charts may have both a left and '+
		                                   'right axis for different series.'},
	      {column:'SERIES2_Y_AXIS_COLUMN', help:'This is the numeric data column used for the chart rendering.  '+
		                                     'This is the data column for Line and Bar charts this will be the Y-Axis '+
		                                     'column.'},
	      {column:'SERIES2_DRILLDOWN_COLUMN', help:'The chart column to be used for self referencing Drill Down.  Must be in '+
		                                        'the form of a Query String name value pairs, (eg, p1=v1&p2=v2, etc). '+
		                                        ' Do not include question mark.  Clicking on the rendered chart element '+
		                                        'will invoke the self referencing drilldown link'},
	      {column:'SERIES2_COLOR', help:'A hex triplet color for this chart series.  Used for Line and Bar charts only. '+
		                             'This value is not used for Pie chart visualizations.'},
	      {column:'SERIES3_TYPE', help:'The charting type for this data series.  Can be either; Line, Bar.'+
		       		  	'Charts can consist of multiple Line and Bar series (upto 4 series) '},
	      {column:'SERIES3_AXIS_ORIENT', help:'Applicable only to Line and Bar charts. May be either "Left" or "Right" and '+
		                                   'specifies the Y-Axis alignment.  Line and Bar charts may have both a left and '+
		                                   'right axis for different series.'},
	      {column:'SERIES3_Y_AXIS_COLUMN', help:'This is the numeric data column used for the chart rendering.  '+
		                                     'This is the data column for Line and Bar charts this will be the Y-Axis '+
		                                     'column.'},
	      {column:'SERIES3_DRILLDOWN_COLUMN', help:'The chart column to be used for self referencing Drill Down.  Must be in '+
		                                        'the form of a Query String name value pairs, (eg, p1=v1&p2=v2, etc). '+
		                                        ' Do not include question mark.  Clicking on the rendered chart element '+
		                                        'will invoke the self referencing drilldown link'},
	      {column:'SERIES3_COLOR', help:'A hex triplet color for this chart series.  Used for Line and Bar charts only. '+
		                             'This value is not used for Pie chart visualizations.'},
	      {column:'SERIES4_TYPE', help:'The charting type for this data series.  Can be either; Line, Bar.'+
		       		  	'Charts can consist of multiple Line and Bar series (upto 4 series) '},
	      {column:'SERIES4_AXIS_ORIENT', help:'Applicable only to Line and Bar charts. May be either "Left" or "Right" and '+
		                                   'specifies the Y-Axis alignment.  Line and Bar charts may have both a left and '+
		                                   'right axis for different series.'},
	      {column:'SERIES4_Y_AXIS_COLUMN', help:'This is the numeric data column used for the chart rendering.  '+
		                                     'This is the data column for Line and Bar charts this will be the Y-Axis '+
		                                     'column.'},
	      {column:'SERIES4_DRILLDOWN_COLUMN', help:'The chart column to be used for self referencing Drill Down.  Must be in '+
		                                        'the form of a Query String name value pairs, (eg, p1=v1&p2=v2, etc). '+
		                                        ' Do not include question mark.  Clicking on the rendered chart element '+
		                                        'will invoke the self referencing drilldown link'},
	      {column:'SERIES4_COLOR', help:'A hex triplet color for this chart series.  Used for Line and Bar charts only. '+
		                             'This value is not used for Pie chart visualizations.'}
           ]
	  },

            {TABLE: 'VF_MAP_VISUALIZATION',  
             help: 'Used to house Map Visualizations.  Maps can have up to 6 custom vector styles applied.',
	     applicable_screens: "Map Visualization",
	     primary_key_column: ["LABEL"],
	     COLUMNS: [
              {column:'LABEL', help:'Unique Description of this Map Visualization' },          
              {column:'OBJECT_NAME', help:'The Table or View as the source data input to this Map Visualization' },          
	      {column:'DISPLAY_THEME', help:'Unused. Reserved for future use. Leave as empty or null'},
              {column:'TITLE_TYPE', help:'The type of Title displayed on the Map Visualization ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'Map title then that column will be omitted from any vector popup display'},
	      {column:'TITLE_VALUE', help:'The value of the Map Visualization Title Displayed.'},
	      {column:'TASK_ID', help:'The Task Id that will associated with this Map Visualization'},
	      {column:'LINKS_TARGET', help:'If specified, will be passed to the "target" attribute of any hyperlinks. '},
	      {column:'GEOMETRY_COLUMNS', help:'The geometry column in the OBJECT_NAME (Table or View) to be used for the vector '+
		                                'geometry rendering in the Map.  Assumed to be WGS84 datum.  Currently, only a '+
		                                 'single geometry column is permitted.  This field will be omitted in any '+
		                                 'vector popup display.'},
              {column:'TOOLTIP_TYPE', help:'The type of tooltip value displayed on hover of map vectors (geometry layers). '+
		                             ' ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'Map tooltips then that column will be omitted from any vector popup display'},
	      {column:'TOOLTIP_VALUE', help:'The value of the hover tooltip displayed on hover of map vectors (geometry layers).'},
	      {column:'STYLE1_OPTION', help:'The Leaflet Path Option that a custom styling will be applied against.  Please refer '+
		                              'to Leaflet Path Options documentation for style meanings and default values. In the '+
		                              'case of "radius" - this is the radius in pixels for any point marker.  In the case of '+
		                              '"stroke" - a value of "true" (string) will draw the linestroke - any other value will '+
		                              'not draw a line stroke.  Any styling specified will override the Leaflet default styling '+
		       			      'value.'},
	      {column:'STYLE1_MODE', help:'This indicates how the styling will be applied.  "regular" applies to the normal rendering '+
		                            'vector styling.  A value of "hover" will apply this custom styling upon mouseover of the '+
		                            'map vectors. '},
	      {column:'STYLE1_TYPE', help:'This indicates the type of the custom styling value.  ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'custom map styling then that column will be omitted from any vector popup display'},
	      {column:'STYLE1_VALUE', help:'The value to be applied for this custom styling.'},
	      {column:'STYLE2_OPTION', help:'The Leaflet Path Option that a custom styling will be applied against.  Please refer '+
		                              'to Leaflet Path Options documentation for style meanings and default values. In the '+
		                              'case of "radius" - this is the radius in pixels for any point marker.  In the case of '+
		                              '"stroke" - a value of "true" (string) will draw the linestroke - any other value will '+
		                              'not draw a line stroke.  Any styling specified will override the Leaflet default styling '+
		       			      'value.'},
	      {column:'STYLE2_MODE', help:'This indicates how the styling will be applied.  "regular" applies to the normal rendering '+
		                            'vector styling.  A value of "hover" will apply this custom styling upon mouseover of the '+
		                            'map vectors. '},
	      {column:'STYLE2_TYPE', help:'This indicates the type of the custom styling value.  ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'custom map styling then that column will be omitted from any vector popup display'},
	      {column:'STYLE2_VALUE', help:'The value to be applied for this custom styling.'},
	      {column:'STYLE3_OPTION', help:'The Leaflet Path Option that a custom styling will be applied against.  Please refer '+
		                              'to Leaflet Path Options documentation for style meanings and default values. In the '+
		                              'case of "radius" - this is the radius in pixels for any point marker.  In the case of '+
		                              '"stroke" - a value of "true" (string) will draw the linestroke - any other value will '+
		                              'not draw a line stroke.  Any styling specified will override the Leaflet default styling '+
		       			      'value.'},
	      {column:'STYLE3_MODE', help:'This indicates how the styling will be applied.  "regular" applies to the normal rendering '+
		                            'vector styling.  A value of "hover" will apply this custom styling upon mouseover of the '+
		                            'map vectors. '},
	      {column:'STYLE3_TYPE', help:'This indicates the type of the custom styling value.  ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'custom map styling then that column will be omitted from any vector popup display'},
	      {column:'STYLE3_VALUE', help:'The value to be applied for this custom styling.'},
	      {column:'STYLE4_OPTION', help:'The Leaflet Path Option that a custom styling will be applied against.  Please refer '+
		                              'to Leaflet Path Options documentation for style meanings and default values. In the '+
		                              'case of "radius" - this is the radius in pixels for any point marker.  In the case of '+
		                              '"stroke" - a value of "true" (string) will draw the linestroke - any other value will '+
		                              'not draw a line stroke.  Any styling specified will override the Leaflet default styling '+
		       			      'value.'},
	      {column:'STYLE4_MODE', help:'This indicates how the styling will be applied.  "regular" applies to the normal rendering '+
		                            'vector styling.  A value of "hover" will apply this custom styling upon mouseover of the '+
		                            'map vectors. '},
	      {column:'STYLE4_TYPE', help:'This indicates the type of the custom styling value.  ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'custom map styling then that column will be omitted from any vector popup display'},
	      {column:'STYLE4_VALUE', help:'The value to be applied for this custom styling.'},
	      {column:'STYLE5_OPTION', help:'The Leaflet Path Option that a custom styling will be applied against.  Please refer '+
		                              'to Leaflet Path Options documentation for style meanings and default values. In the '+
		                              'case of "radius" - this is the radius in pixels for any point marker.  In the case of '+
		                              '"stroke" - a value of "true" (string) will draw the linestroke - any other value will '+
		                              'not draw a line stroke.  Any styling specified will override the Leaflet default styling '+
		       			      'value.'},
	      {column:'STYLE5_MODE', help:'This indicates how the styling will be applied.  "regular" applies to the normal rendering '+
		                            'vector styling.  A value of "hover" will apply this custom styling upon mouseover of the '+
		                            'map vectors. '},
	      {column:'STYLE5_TYPE', help:'This indicates the type of the custom styling value.  ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'custom map styling then that column will be omitted from any vector popup display'},
	      {column:'STYLE5_VALUE', help:'The value to be applied for this custom styling.'},
	      {column:'STYLE6_OPTION', help:'The Leaflet Path Option that a custom styling will be applied against.  Please refer '+
		                              'to Leaflet Path Options documentation for style meanings and default values. In the '+
		                              'case of "radius" - this is the radius in pixels for any point marker.  In the case of '+
		                              '"stroke" - a value of "true" (string) will draw the linestroke - any other value will '+
		                              'not draw a line stroke.  Any styling specified will override the Leaflet default styling '+
		       			      'value.'},
	      {column:'STYLE6_MODE', help:'This indicates how the styling will be applied.  "regular" applies to the normal rendering '+
		                            'vector styling.  A value of "hover" will apply this custom styling upon mouseover of the '+
		                            'map vectors. '},
	      {column:'STYLE6_TYPE', help:'This indicates the type of the custom styling value.  ("Literal Constant" or "Column Value").'+
		                           '"Literal Constant" will use the specified value, whereas "Column Value" will '+
		                           'use the table/view column value.  Note that if a "Column Value" is used to generate the '+
		       			   'custom map styling then that column will be omitted from any vector popup display'},
	      {column:'STYLE6_VALUE', help:'The value to be applied for this custom styling.'},
	      {column:'DRILLDOWN_COLUMN', help:'The table/view column to be used for self referencing Drill Down.  Must be in '+
	                                 'the form of a Query String name value pairs, (eg, p1=v1&p2=v2, etc). '+
		                                ' Do not include question mark.  Will be accessible as a column '+
		                                ' via the vector onclick popup.  And clicking on the link will invoke the '+
		                                ' self referencing drilldown.'},
	      {column:'DRILLDOWN_LABEL', help:'A static text label to put in place as anchor text for any self referencing drilldown '+
		                               ' hyperlink in place of the DRILLDOWN_COLUMN.  Default value is "Drilldown" but it may be more '+
		                               ' meaningful to use an alternative text label.'},
              {column:'DRILLDOWN_APPEND_METADATA', help:'1 - if the page is invoked with a passed METADATA parameter, this parameter will '+
		                                         ' be appended to any the drilldown URLs. 0 - the original METADATA parameter will not be '+
		                                         ' appended to any drilldown URLs.' },       
              {column:'TILE_LAYER_URL', help:'Currently unused.  Tile Layers need to be set as part of the general Config. '+
		                               'Leave this field empty or null.  Reserved for future use.'},
              {column:'TILE_LAYER_ATTRIBUTION', help:'Currently unused.  Tile Layers attribution needs to be set as part of the general Config. '+
		                                      'Leave this field empty or null.  Reserved for future use.'},
              {column:'POINT_CLUSTER_ALGORITHM', help:'Currently unused.  Reserved for future use. Leave this field empty/null'}
	]
       }
     ]
    }


// Table browse Metadata

const gBROWSE_META = {
 'VF_TABLES': {
   'HIDDEN_COLUMNS': ['TABLE_NAME','FILE_LAST_MODIFIED','ALL_TABLE_COLUMNS',
	              'HIDDEN_TABLE_COLUMNS', 'DISPLAY_TABLE_COLUMNS'],
   'ADDITIONAL_COLUMNS': ['TABLE_NAME','Edit','Import','Import + Browse','Drop'],
    'MARKUP': {
      'Edit': function(row) {
              if (row.TABLE_TYPE=='FILE')
  	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_filelist(\'edit\','+
		      qescape(row.rowid)+');')+'">'+gEDIT_BUTTON+'</a>';
	      else
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_urllist(\'edit\','+
		      qescape(row.rowid)+');')+'">'+gEDIT_BUTTON+'</a>';
	                        },
      'Drop': function(row) {
               if (row.TABLE_TYPE=='FILE')
   	        return '<a title="Drop" class="blk" href="'+escATTR('javascript:handle_filelist(\'drop\','+
                        qescape(row.rowid)+');')+'">'+gDROP_BUTTON+'</a>';
	       else
	        return '<a title="Drop" class="blk" href="'+escATTR('javascript:handle_urllist(\'drop\','+
	               qescape(row.rowid)+');')+'">'+gDROP_BUTTON+'</a>';
	                        },
     'Import': function(row) {
	        if (row.TABLE_TYPE=='URL')
	         return '<a title="Import" class="blk" href="'+escATTR('javascript:search_url_table_rowid('+
		 qescape(row.rowid)+',true);')+'">'+gRUN_BUTTON+'</button></a>';
		else
		 return '';
	                       },
     'Import + Browse': function(row) {
                         if (row.TABLE_TYPE=='URL')
		          return '<a title="Import then Browse" class="blk" href="'+escATTR('javascript:handle_urllist(\'redo\','+
			         qescape(row.rowid)+');')+'"><button class="nobr"><i class="fa fa-arrow-circle-right"></i> '+
			     '<i class="fa fa-table"></i> Import + Browse</button></a>';
		         else
		          return '';
	                              },
     'TABLE_NAME': function(row) {
		    return '<a title="Browse" class="blk" href="'+escATTR('javascript:go_browse(\''+
  	                   qescape(row.TABLE_NAME)+'\');')+'">'+escHTML(row.TABLE_NAME)+'</a>';
	                              },
     'FILE_SIZE': function(row) {
	           try { return sizeMb(row.FILE_SIZE); } catch(e) { return row.FILE_SIZE; }
	                             },
     'LAST_TABLE_REFRESH': function(row) {
   	                    try { return JSON.parse(row.LAST_TABLE_REFRESH); } catch(e) { return row.LAST_TABLE_REFRESH; }
	                                 }
              }
	 },
 'VF_DB_OBJECTS': {
    'HIDDEN_COLUMNS': ['name'],
     'ADDITIONAL_COLUMNS': ['name'],
     'MARKUP': {
      'name': function(row) {
	       return '<a title="Browse" class="blk" href="'+escATTR('javascript:go_browse(\''+
		       qescape(row.name)+'\');')+'">'+escHTML(row.name)+'</a>';
	                    }
               }
	          },
 'VF_TILE_STORE': {
    'HIDDEN_COLUMNS': [],
     'ADDITIONAL_COLUMNS': [],
     'MARKUP': {
      'CONTENT': function(row) {
                   let content=row['CONTENT'];
                   let content_type=row['CONTENT_TYPE'];
                   let byte_array=JSON.parse(content);
                   let Ui=new Uint8Array(byte_array);
                   let theBlob=new Blob([Ui], {type: content_type});
                   let src=URL.createObjectURL(theBlob);
	           return '<img src="'+escATTR(src)+'" style="max-width:160px"></img>';
	                    },
    'DATE_SAVED': function(row) {
	            try { return JSON.parse(row['DATE_SAVED']); }
	            catch(e) { return row['DATE_SAVED']; }
	          }
               }
	      },
 'VF_PROMPT_INPUT': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_prompt(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_prompt(\'edit\',\''+
		       row.rowid+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_prompt(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_prompt(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             },
 'VF_RUN_MENU': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_menu(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_menu(\'edit\',\''+
		       qescape(row.rowid)+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_menu(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_menu(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             },
 'VF_CUSTOM_FUNCTION': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_cf(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_cf(\'edit\',\''+
		       qescape(row.rowid)+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_cf(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_cf(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             },
 'VF_SEQUENCE': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_sequence(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_sequence(\'edit\',\''+
		       qescape(row.rowid)+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_sequence(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_sequence(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             },
 'VF_TABLE_VISUALIZATION': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_table_viz(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_table_viz(\'edit\',\''+
		       qescape(row.rowid)+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_table_viz(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_table_viz(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             },
 'VF_CHART_VISUALIZATION': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_chart_viz(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_chart_viz(\'edit\',\''+
		       qescape(row.rowid)+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_chart_viz(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_chart_viz(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             },
 'VF_MAP_VISUALIZATION': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_map_viz(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_map_viz(\'edit\',\''+
		       qescape(row.rowid)+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_map_viz(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_map_viz(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             },
 'VF_SQL': {
    'HIDDEN_COLUMNS': ['LABEL'],
    'ADDITIONAL_COLUMNS': ['LABEL','Edit','Run','Drop'],
    'MARKUP': {
      'LABEL': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_saved_sql(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+escHTML(row.LABEL)+'</a>';
	                    },
      'Edit': function(row) {
	       return '<a title="Edit" class="blk" href="'+escATTR('javascript:handle_saved_sql(\'edit\',\''+
		       qescape(row.rowid)+'\');')+'">'+gEDIT_BUTTON+'</a>';
	                    },
      'Run': function(row) {
	       return '<a title="Run" class="blk" href="'+escATTR('javascript:handle_saved_sql(\'execute\',\''+
		       qescape(row.rowid)+'\');')+'">'+gRUN_BUTTON+'</a>';
	          },
      'Drop': function(row) {
	       return '<a title="Drop" class="blk" href="'+escATTR('javascript:delete_saved_sql(\''+
		       qescape(row.rowid)+'\');')+'">'+gDROP_BUTTON+'</a>';
	          }
              }
             }
}


/* ----- End Reference Metadata ----- */


// Global dynamic variables
var gDB;
var gTHE_READ_FILE={};
var gALL_DATA=[];
var gDOWNLOAD_IN_PROGRESS=false;
var gIS_INTERACTIVE=true;
var gCF_IDX={};
var gTHE_CHART;
var gTHE_CHART_OBJECT_NAME;
var gTHE_CHART_POINT_RADIUS=3;
var gTHE_QUERY_STRING_METADATA;
var gTHE_MAP;
var gTHE_MAP_FEATURES=[];
var gTHE_MAP_FEATURE_LAYER;
var gTHE_MAP_CLUSTER_LAYER;
var gMAP_TILE_LAYER;
var gMETADATA;
var gMETADATA_PARSED;
var gSHOW_STATUS=false;

// Abreviations
var gSPIN='<i class="fa fa-circle-o-notch fa-spin fa-fw"></i>';
var gSPIN_2X='<i class="fa fa-circle-o-notch fa-spin fa-2x fa-fw"></i>';
var gEDIT='<span class="nobr"><i class="fa fa-file-o"></i> Edit</span>';
var gEDIT_BUTTON='<button title="Edit">'+gEDIT+'</button>';
var gRUN='<span class="nobr"><i class="fa fa-arrow-circle-right"></i> Run</span>';
var gRUN_BUTTON='<button title="Run">'+gRUN+'</button>';
var gDROP='<span class="nobr"><i class="fa fa-trash-o"></i> Drop</span>';
var gDROP_BUTTON='<button title="Drop">'+gDROP+'</button>';
var $I=function(elem){return document.getElementById(elem);};
var $L=function(a,b,c,d){if(gDEBUG){console.log(a);if(b)console.log(b);if(c)console.log(c);if(d)console.log(d)}};


/* ----- Begin Navigation Bar helper support functions ----- */

function go_reference_guide() {
 set_visible_pane('reference_guide');
}

function go_api_guide() {
 set_visible_pane('api_guide');
}

function go_tips() {
 set_visible_pane('tips');
}

function go_metadata_export() {
 set_visible_pane('metadata_export');
}

function go_metadata_import() {
 set_visible_pane('metadata_import');
}

function go_metadata_reset() {
 set_visible_pane('metadata_reset');
}

function go_table_viz_setup(){
 table_viz_object_list();
 set_visible_pane('table_viz_setup');
}

function go_map_viz_setup(){
 map_viz_object_list();
 set_visible_pane('map_viz_setup');
}

function go_chart_viz_render() {
 set_visible_pane('chart_viz_render');
}

function go_chart_viz_setup(){
 chart_viz_object_list();
 set_visible_pane('chart_viz_setup');
}

function go_pageload(){
 $I("pageload_status").innerHTML="";
 set_visible_pane('pageload');
}

function go_device_attributes(){
 set_visible_pane('device_attributes');
}

function go_map(){
 set_visible_pane('map_container');
}

function go_config(){
 set_visible_pane('config');
}

function go_sequence(){
 set_visible_pane('sequence');
}

function go_import_file(){
 set_visible_pane('fileimport');
}

function go_url_import(){
 set_visible_pane('urlimport');
}

function go_prompt(){
 set_visible_pane('prompt');
}

function go_run_menu(){
 set_visible_pane('run_menu');
}

function go_sql(){
 set_visible_pane('sql');
}

function go_custom_function(){
 set_visible_pane('custom_function');
 custom_function_part1();
}

function go_browse(default_obj,term,context){
 set_visible_pane('browse');
 browse_part1(default_obj,term,context);
}

function go_status() {
 set_visible_pane('status');
}

function go_about() {
 set_visible_pane('about');
}

function set_visible_pane(the_pane){
 var panes=['sql','config','sequence','run_menu','custom_function','fileimport','urlimport',
            'home','about','status','pageload','device_attributes','prompt','browse',
	    'table_viz_setup','map_viz_setup','chart_viz_setup',
            'metadata_export', 'metadata_import', 'metadata_reset',
            'table_viz_render','chart_viz_render', 'map_container', 'reference_guide', 
	    'api_guide','tips'];
 for (let i=0;i<panes.length;i++){
  try {
   let e=$I(panes[i]);
   e.style.display='none';
      }
  catch(e) {};
  }

 var nav=$I('navdiv');
 if (['table_viz_render','chart_viz_render','map_container','status'].indexOf(the_pane)>=0) { 
  if (the_pane != 'status') gSHOW_STATUS=false;
  nav.style.display='none'  //Whole screen (hide nav bar for visualizations)
  }
 else
  nav.style.display='block';

 if (!gSHOW_STATUS) {
  let s=$I(the_pane);
  s.style.display="block";
 } else {
  let s=$I('status');
  s.style.display="block";
  nav.style.display='none'  
 };
}

/* ----- End Navigation Bar helper support functions ----- */


/* ----- Begin primary workflow and page startup functions  ---- */

// Worflow abbreviations
// 1 - Normal page load (no METADATA param)
// 2 - Page load with METADATA param specified
// 3 - User selected "Import Metadata" by file import
// 4 - User selected "Reset Metadata"

function get_pageload_metadata() {
 // Otherwise assume Query String Param
 var url = new URL(window.location);
 for (let p of url.searchParams) {
      var pn=p[0], pv=p[1];
      if (pn.toLowerCase()=='metadata')
       return pv;
 }
 return null;
}

function startupConfig(flow) {
 config_defaults();
 get_config(); 
 openDB(flow);
}

function openDB(flow, meta) {
 var db_name=(localStorage['CONFIG_DB_NAME']||'vf');
 var database_size_mb=parseInt(localStorage['CONFIG_DB_SIZE']||'200');
 try {  gDB = openDatabase(db_name, "1.0", "Visual Field Offline DB", database_size_mb*1024*1204); }
  catch(e) { 
   notify('Unable to create '+database_size_mb.toString()+'Mb Offline database on your device.  This may be a limitation of your device.');
   return;
           };
 if (flow==1) cr_vf_objects(flow);
 if (flow==2) dropTables(flow);
 if (flow==3) cr_vf_objects(flow);
}

function startup_sequence(flow) {
 sync_menu_items(flow);  
}

function startupPost2(flow) {
 import_query_string(flow);
}

function startupPageLoad(flow) {
 run_pageload(false);
}

function import_flow(flow) {
 try {
  gMETADATA_PARSED=JSON.parse(gMETADATA);
 } catch(e) { fetch_metadata(flow);  return; }
 load_config(flow); 
}

function fetch_metadata(flow) {
 try {
  fetch(gMETADATA).
   then(function(response){return response.json();}).
   then(function(data) {gMETADATA_PARSED=data; load_config(flow);});
 } catch(e) { notify('Fetch failed, or JSON Parse, failed for Metadata.'); }
}

function load_config(flow) {
 config_defaults();
 if (gMETADATA_PARSED.CONFIG) {
  var metaparsed=gMETADATA_PARSED.CONFIG;
  var metadef=gVF_DEFINITION.CONFIG;
  if (metaparsed.length==metadef.length) {
   for (var i=0; i<metadef.length; i++) {
    // Special case for DB name as it is fixed in this version
    if (metadef[i].param=='CONFIG_DB_NAME')
     localStorage['CONFIG_DB_NAME']='vf';
    else 
     localStorage[metadef[i].param]=metaparsed[i];
   }
   get_config();
  }
 }
 openDB(flow);
}

function build() {
 // Generic startup routines
 update_app_name();
 set_visible_pane('home');
 setup_file_dd();
 setup_file_dd_quick();
 setup_metadata_file_dd();
 populate_config_sample_map_tiles();
 build_cf_index();
 build_cf_select();
 build_cf_api_select();
 build_api_page_helpers();
 //build_chart_themes();
 update_favicon();

 // Check and run flows 1 or 2
 gMETADATA=get_pageload_metadata();
 if (gMETADATA)
  import_flow(2)
 else
  startupConfig(1); 
}

function dropTables(flow) {
 if ((!flow)||(flow==4)||((flow==2)&&(gMETADATA_PARSED.RESET_DB))) {
  gDB.transaction(function (t) { 
   t.executeSql("drop table if exists VF_TABLES;", []); 
   t.executeSql("drop table if exists VF_SQL", []);
   t.executeSql("drop table if exists VF_SEQUENCE", []);
   t.executeSql("drop table if exists VF_QUERY_STRING", []);
   t.executeSql("drop table if exists VF_PROMPT_INPUT", []);
   t.executeSql("drop table if exists VF_CUSTOM_FUNCTION_PARAMETER", []);
   t.executeSql("drop table if exists VF_CUSTOM_FUNCTION", []);
   t.executeSql("drop table if exists VF_RUN_MENU", []);
   t.executeSql("drop table if exists VF_TABLE_VISUALIZATION", []);
   t.executeSql("drop table if exists VF_CHART_VISUALIZATION", []);
   t.executeSql("drop table if exists VF_MAP_VISUALIZATION", []);
   t.executeSql("drop table if exists VF_TILE_STORE", []);
   t.executeSql("drop table if exists VF_DEVICE_ATTRIBUTES", []);
   t.executeSql("drop view if exists VF_DB_TABLES", []);
   t.executeSql("drop view if exists VF_DB_OBJECTS", []);
		 },$L, 
		  function() {
		   if ((flow==2)||(flow==4)) {
		     cr_vf_objects(flow);
		     return;
		   }
		             }
		 );
  };
 if (flow==2) {
  cr_vf_objects(flow);
  return;
 }
}

function cr_vf_objects(flow) {
    gDB.transaction(function (t) { 
     t.executeSql("create table if not exists VF_TABLES("+
                      "TABLE_TYPE TEXT, "+
                      "TABLE_NAME TEXT PRIMARY KEY, "+
                      "FILE_NAME_DEDUPED TEXT, "+
                      "FILE_SIZE NUMBER, "+
                      "FILE_LAST_MODIFIED TEXT, "+
                      "FILE_LAST_MODIFIED_DATE TEXT, "+
                      "FILE_TYPE TEXT, "+
                      "URI TEXT, "+
                      "CHARSET TEXT, "+
                      "DELIMITER TEXT, "+
                      "CUSTOM_DELIMITER TEXT, "+
                      "SEPARATOR TEXT, "+
                      "CUSTOM_SEPARATOR TEXT, "+
                      "SKIP_FIRST_LINES NUMBER, "+
                      "HEADER_ROW NUMBER ,"+
                      "EMPTY_AS_NULL NUMBER, "+
                      "IS_TEMP NUMBER, "+
                      "FILE_IMPORT_START_TASK_ID NUMBER, "+
                      "FILE_IMPORT_AUTOMATE NUMBER, "+
                      "LAST_TABLE_REFRESH TEXT, "+
                      "URI_CACHE_MAX_AGE TEXT, "+
                      "URI_HEADER_NAME1 TEXT, "+
                      "URI_HEADER_VALUE1 TEXT, "+
                      "URI_HEADER_NAME2 TEXT, "+
                      "URI_HEADER_VALUE2 TEXT, "+
                      "URI_TASK_ID NUMBER, "+
                      "ALL_TABLE_COLUMNS TEXT, "+
                      "HIDDEN_TABLE_COLUMNS TEXT, "+
                      "DISPLAY_TABLE_COLUMNS TEXT)", []); 

     t.executeSql("create table if not exists VF_SQL("+
                      "LABEL TEXT, "+
                      "DATE_SAVED TEXT, "+
                      "TASK_ID NUMBER, "+
                      "STATEMENT TEXT)", []);

     t.executeSql("create table if not exists VF_SEQUENCE("+
                      "LABEL TEXT, "+
                      "DATE_SAVED TEXT, "+
                      "TASK_ID NUMBER PRIMARY KEY, "+
                      "COMPONENT_TASK_IDS TEXT)", []);

     t.executeSql("create table if not exists VF_QUERY_STRING("+
                      "NAME TEXT, "+
                      "VALUE TEXT)", []);

     t.executeSql("create table if not exists VF_PROMPT_INPUT("+
                      "LABEL TEXT PRIMARY KEY, "+
                      "PROMPT_TEXT TEXT, "+
                      "QUERY_STRING_NAME TEXT,"+
                      "TASK_ID NUMBER,"+
                      "DATE_SAVED TEXT)", []);

     t.executeSql("create table if not exists VF_CUSTOM_FUNCTION("+
                      "LABEL TEXT PRIMARY KEY, "+
                      "INPUT_SOURCE_TABLE TEXT, "+
                      "FUNCTION_ID INTEGER,"+
                      "RESULT_OUTPUT_TABLE TEXT,"+
                      "IS_TEMP NUMBER,"+
                      "TASK_ID NUMBER,"+
                      "DATE_SAVED TEXT)", []);

     t.executeSql("create table if not exists VF_CUSTOM_FUNCTION_PARAMETER("+
                      "LABEL TEXT, "+
                      "PARAMETER_INDEX INTEGER,"+
                      "PARAMETER_TYPE TEXT, "+
                      "PARAMETER_VALUE TEXT)", []);

     t.executeSql("create table if not exists VF_RUN_MENU("+
                      "LABEL TEXT PRIMARY KEY, "+
                      "TITLE TEXT,"+
                      "TASK_ID NUMBER, "+
                      "RELATIVE_ORDER NUMBER,"+
                      "DATE_SAVED TEXT)", []);

     t.executeSql("create table if not exists VF_TABLE_VISUALIZATION("+
                      "LABEL TEXT PRIMARY KEY, "+
                      "OBJECT_NAME TEXT,"+
                      "DISPLAY_THEME TEXT,"+
                      "TITLE_TYPE TEXT,"+
                      "TITLE_VALUE TEXT,"+
                      "TASK_ID NUMBER, "+
                      "LINKS_TARGET TEXT,"+
                      "DRILLDOWN_COLUMN TEXT,"+
                      "DRILLDOWN_LABEL TEXT,"+
                      "DRILLDOWN_APPEND_METADATA NUMBER,"+
                      "DATE_SAVED TEXT)", []);

     t.executeSql("create table if not exists VF_CHART_VISUALIZATION("+
                      "LABEL TEXT PRIMARY KEY, "+
                      "OBJECT_NAME TEXT,"+
                      "BACKGROUND_COLOR TEXT,"+
                      "DISPLAY_THEME TEXT,"+
                      "TITLE_TYPE TEXT,"+
                      "TITLE_VALUE TEXT,"+
                      "TASK_ID NUMBER,"+
                      "LINKS_TARGET TEXT,"+
                      "DRILLDOWN_APPEND_METADATA NUMBER,"+
                      "X_AXIS_COLUMN TEXT,"+
                      "X_AXIS_ORDER_BY_COLUMN TEXT,"+
                      "X_AXIS_ORDER_BY_DIRECTION TEXT,"+
                      "STACKED NUMBER,"+
                      "SERIES1_TYPE TEXT,"+
                      "SERIES1_AXIS_ORIENT TEXT,"+
                      "SERIES1_Y_AXIS_COLUMN TEXT,"+
                      "SERIES1_DRILLDOWN_COLUMN TEXT,"+
                      "SERIES1_COLOR TEXT,"+
                      "SERIES2_TYPE TEXT,"+
                      "SERIES2_AXIS_ORIENT TEXT,"+
                      "SERIES2_Y_AXIS_COLUMN TEXT,"+
                      "SERIES2_DRILLDOWN_COLUMN TEXT,"+
                      "SERIES2_COLOR TEXT,"+
                      "SERIES3_TYPE TEXT,"+
                      "SERIES3_AXIS_ORIENT TEXT,"+
                      "SERIES3_Y_AXIS_COLUMN TEXT,"+
                      "SERIES3_DRILLDOWN_COLUMN TEXT,"+
                      "SERIES3_COLOR TEXT,"+
                      "SERIES4_TYPE TEXT,"+
                      "SERIES4_AXIS_ORIENT TEXT,"+
                      "SERIES4_Y_AXIS_COLUMN TEXT,"+
                      "SERIES4_DRILLDOWN_COLUMN TEXT,"+
                      "SERIES4_COLOR TEXT,"+
                      "DATE_SAVED TEXT)", []);

     t.executeSql("create table if not exists VF_MAP_VISUALIZATION("+
                      "LABEL TEXT PRIMARY KEY, "+
                      "OBJECT_NAME TEXT,"+
                      "DISPLAY_THEME TEXT,"+
                      "TITLE_TYPE TEXT,"+
                      "TITLE_VALUE TEXT,"+
                      "TASK_ID NUMBER, "+
                      "LINKS_TARGET TEXT,"+
                      "GEOMETRY_COLUMNS TEXT,"+
                      "TOOLTIP_TYPE TEXT,"+
                      "TOOLTIP_VALUE TEXT,"+
                      "STYLE1_OPTION TEXT,"+
                      "STYLE1_MODE TEXT,"+
                      "STYLE1_TYPE TEXT,"+
                      "STYLE1_VALUE TEXT,"+
                      "STYLE2_OPTION TEXT,"+
                      "STYLE2_MODE TEXT,"+
                      "STYLE2_TYPE TEXT,"+
                      "STYLE2_VALUE TEXT,"+
                      "STYLE3_OPTION TEXT,"+
                      "STYLE3_MODE TEXT,"+
                      "STYLE3_TYPE TEXT,"+
                      "STYLE3_VALUE TEXT,"+
                      "STYLE4_OPTION TEXT,"+
                      "STYLE4_MODE TEXT,"+
                      "STYLE4_TYPE TEXT,"+
                      "STYLE4_VALUE TEXT,"+
                      "STYLE5_OPTION TEXT,"+
                      "STYLE5_MODE TEXT,"+
                      "STYLE5_TYPE TEXT,"+
                      "STYLE5_VALUE TEXT,"+
                      "STYLE6_OPTION TEXT,"+
                      "STYLE6_MODE TEXT,"+
                      "STYLE6_TYPE TEXT,"+
                      "STYLE6_VALUE TEXT,"+
                      "DRILLDOWN_COLUMN TEXT,"+
                      "DRILLDOWN_LABEL TEXT,"+
                      "DRILLDOWN_APPEND_METADATA NUMBER,"+
	              "TILE_LAYER_URL TEXT,"+
	              "TILE_LAYER_ATTRIBUTION TEXT,"+
	              "POINT_CLUSTER_ALGORITHM TEXT,"+
                      "DATE_SAVED TEXT)", []);

   t.executeSql("create table if not exists VF_TILE_STORE("+
                      "KEY TEXT PRIMARY KEY,"+
                      "URL TEXT,"+
                      "CONTENT TEXT,"+
                      "CONTENT_TYPE TEXT,"+
                      "DATE_SAVED TEXT,"+
                      "ENCODING_ALGORITHM TEXT)", []);

   t.executeSql("create table if not exists VF_DEVICE_ATTRIBUTES("+
                     "CATEGORY TEXT,"+
                     "NAME TEXT,"+
                     "VALUE TEXT,"+
                     "DATE_SAVED TEXT)", []);

   t.executeSql("create view if not exists VF_DB_TABLES as "+
                  "select name from (select * from sqlite_master where upper(type) in ('TABLE') "+
	          " and name not like 'VF_%' and name not like '__WebKit%' order by lower(name)) "+
                  "union all "+
                  "select name from (select * from sqlite_master where upper(type) in ('TABLE') "+
	          "and name like 'VF_%' order by name)", []);

   t.executeSql("create view if not exists VF_DB_OBJECTS as "+
                  "select name, type from "+
	          " (select name, type from sqlite_master where upper(type) in ('TABLE','VIEW') "+
	          "  and name not like 'VF_%' and name not like '__WebKit%' order by lower(name)) "+
                  "union all "+
                  "select * from "+
	          " (select name, type from sqlite_master where upper(type) in ('TABLE','VIEW') "+
	          "  and name like 'VF_%' order by name)", []); 
		 
		 },$L, 
		  function() {
                    if (flow==1)
		     startup_sequence(flow);
		    if (flow==2)
		     import_db_objects(flow);
		    if (flow==3)
		     import_db_objects(flow);
	            if (flow==4) {
		     startup_sequence(flow);
		     tick_fade('metadata_reset_progress');
		    }
		    }
		 );
 }

function import_db_objects(flow) {
 let the_tables=gMETADATA_PARSED.TABLES;
 gDB.transaction(function (t) {
  for (table in the_tables) {
   let defn=get_definition_table(table);
   if (defn) {
    let cols=defn.COLUMNS;
    let pks=defn.primary_key_column;
    let pk_indexes=get_pk_indexes(pks, cols);
     for (r=0; r<the_tables[table].length; r++) {
      let the_row_data=the_tables[table][r];
      if (the_tables[table][r].length == cols.length) {
       let SQL_COUNT='select count(*) as row_count from '+
                     sanitise(defn.TABLE)+' where ';
       let WHERE='';
       let PARAMS=[];
       for (let i=0; i<pks.length; i++) {
        if (WHERE) WHERE+=' and ';
        WHERE+= sanitise(pks[i])+'=? ';
        PARAMS.push(the_tables[table][r][pk_indexes[i]]);
       } 
       SQL_COUNT+= WHERE;
       t.executeSql(SQL_COUNT,PARAMS,
        function (tx, r) {
	 if ((r.rows.length>0)&&(r.rows[0].row_count==0)) {
	  let THE_INSERT='insert into '+sanitise(defn.TABLE)+'('+
	                  //Assumes columns don't contain commas.
	                 defn.COLUMNS.map(function(col){return sanitise(col.column)}).join(',')+') values '+
                          generate_placeholders(cols.length);
            t.executeSql(THE_INSERT,the_row_data,$L,$L);

        } else{
	  let THE_UPDATE='update '+sanitise(defn.TABLE)+' set '+
	                  //Assumes columns don't contain commas.
	                 defn.COLUMNS.map(function(col){return sanitise(col.column)+'=? '}).join(',')+' where '+
			 WHERE;
           let all_params=the_row_data.concat(PARAMS);
           t.executeSql(THE_UPDATE,all_params,$L,$L);
		 }
	}, $L);
 
      } else {
       $L('Error: Metadata column count mismatch - '+table);
      }
     }
     } // If defn
  } //for
 },$L,function(){if ((flow==2)||(flow==3)) startup_sequence(flow);  });
}

function get_definition_table(table) {
 var defn=gVF_DEFINITION.TABLES;
 for (var t=0; defn.length; t++) {
  if (defn[t].TABLE==table)
   return defn[t];
 }
 return null;
}

function get_column_index(name, column_def) {
 for (var i=0; i<column_def.length; i++) {
  if (column_def[i].column == name)
   return i;
 }
 return -1;
}

function get_pk_indexes(pks, column_def) {
 var pk_index=[];
 for (var p=0; p<pks.length; p++)
  pk_index.push(get_column_index(pks[p], column_def));
 return pk_index;
}

window.onload=build;

/* ----- End primary workflow and page startup functions  ---- */


/* ---- Begin Custom Function Definitions --------- */

// Custom Function Helpers

function geojson2wkt(gj) {
 let gj_key='#g-'+JSON.stringify(gj);
 var cached_result=null;
 try {
  cached_result=sessionStorage[gj_key];
  if (cached_result) return cached_result;
     }
  catch(e) {}
 var result=stringify(gj);
 try {
   sessionStorage[gj_key]=result;
     }
 catch(e) {}
 return result;
}

function wkt2geojson(wkt) {
 let wkt_key="#w-"+wkt;
 var cached_result=null;
 try {
  cached_result= sessionStorage[wkt_key];
  if (cached_result) return JSON.parse(sessionStorage[wkt_key]);
     }
 catch(e) {}
 var result=parse(wkt);
 try {
  sessionStorage[wkt_key]=JSON.stringify(result);
     }
  catch(e) {}
 return result;
}

function toFeature(geom) {
 if (geom)
  return {type:"Feature",properties:{},geometry:geom};
 else
  return null;
}

function convertFCtoGC(fc) {
 function extr(elem) {
  if (elem.geometry)
   return elem.geometry;
  return null;
  }
 if (!fc)
  return null;
 var features=fc.features;
 if ((features)&&(features.length==1))
  return features[0].geometry;
 var GC= turf.geometryCollection(features.map(extr));
 if (GC.geometry)
  return GC.geometry;
 return GC;
}

function token_search(query,string,threshold) {
 threshold=parseFloat(threshold);
 function split_space(strng){
  return strng.match(/\S+/g);
 };
 function alphanumeric(strng){
  var cleansed=strng.match(/([A-Z])|([a-z])|([0-9])/g);
  if (cleansed)
   return cleansed.join('').toLowerCase();
  return null;
 } 
 function tk_index(str){
  var idx={};
  var tokens=split_space(str);
  for (var i=0; i<tokens.length; i++) {
   var an=alphanumeric(tokens[i]);
   if (!an) 
    continue;
   idx[an]=true;
  }
  return idx;
 }
 var $IX=tk_index(string);
 var qtokens=split_space(query);
 var len1=qtokens.length;
 var matches=0;
 for (var i=0;i<qtokens.length;i++) {
  var an=alphanumeric(qtokens[i]);
  if (!an)
   continue;
  if ($IX[an])
   matches++;
  if (parseFloat(matches/len1) >= threshold)
   return true;
 }
 return false;
};

function metaphone_search(query,string,stemmer,threshold) {
 if (stemmer)
  stemmer=(stemmer.toLowerCase()=='true');
 threshold=parseFloat(threshold);
 function split_space(strng) {
  return strng.match(/\S+/g);
 };
 function alphanumeric(strng) {
  var cleansed=strng.match(/([A-Z])|([a-z])|([0-9])/g);
  if (cleansed)
   return cleansed.join('');
  return null;
 } 
 function dm_index(str) {
  var idx={};
  var tokens=split_space(str);
  for (var i=0; i<tokens.length; i++) {
   var an=alphanumeric(tokens[i]);
   if (!an) 
    continue;
   if (stemmer)
    an=stemmer(an);
   var dm=doubleMetaphone(an);
   idx[dm[0]]=true;
   idx[dm[1]]=true;
  }
  return idx;
 }
 var $IX=dm_index(string);
 var qtokens=split_space(query);
 var len1=qtokens.length;
 var matches=0;
 for (var i=0; i<qtokens.length; i++) {
  var an=alphanumeric(qtokens[i]);
  if (!an)
   continue;
  if (stemmer)
   an=stemmer(an);
  var dm=doubleMetaphone(an);
  if (($IX[dm[0]])||($IX[dm[1]]))
   matches++;
  if (parseFloat(matches/len1)>=threshold)
   return true;
 }
 return false;
};

var numArray = {	
	max:function(array) {
		return Math.max.apply(null,array);
	},
	min:function(array) {
		return Math.min.apply(null,array);
	},
	range:function(array) {
		return numArray.max(array)-numArray.min(array);
	},
	midrange:function(array) {
		return numArray.range(array)/2;
	},
	sum:function(array) {
		var num=0;
		for (var i=0,l=array.length;i<l;i++) 
                num+=parseFloat(array[i]);
		return num;
	},
	mean:function(array) {
		return numArray.sum(array)/array.length;
	},
	median:function(array) {
		array.sort(function(a,b) {
			return a-b;
		});
		var mid=array.length/2;
		return mid%1?array[mid-0.5]:(array[mid-1]+array[mid])/2;
	},
	modes:function(array) {
		if (!array.length) return [];
		var modeMap={},
			maxCount=0,
			modes=[];
		array.forEach(function(val) {
			if (!modeMap[val]) modeMap[val]=1;
			else modeMap[val]++;
			if (modeMap[val]>maxCount) {
				modes=[val];
				maxCount=modeMap[val];
			}
			else if (modeMap[val]===maxCount) {
				modes.push(val);
				maxCount=modeMap[val];
			}
		});
		return modes;
	},
	variance:function(array) {
		var mean=numArray.mean(array);
		return numArray.mean(array.map(function(num) {
			return Math.pow(num-mean,2);
		}));
	},
	standardDeviation:function(array) {
		return Math.sqrt(numArray.variance(array));
	},
	meanAbsoluteDeviation:function(array) {
		var mean = numArray.mean(array);
		return numArray.mean(array.map(function(num) {
			return Math.abs(num-mean);
		}));
	},
	zScores:function(array) {
		var mean=numArray.mean(array);
		var standardDeviation=numArray.standardDeviation(array);
		return array.map(function(num) {
			return (num-mean)/standardDeviation;
		});
	}
};


function build_cf_index() {
 for (var i=0;i<VF_CUSTOM_FUNCTIONS.length;i++)
  gCF_IDX[VF_CUSTOM_FUNCTIONS[i].id]=i;
}


// --- Custom Functions Custom Handlers ----
// -----------------------------------------

// customListSplit as defined in VF_CUSTOM_FUNCTION
function customListSplit(result_table,all_data,state) {
 customListSplit_handler(result_table,0,0,all_data,null,null,0,state);
};

function customListSplit_handler(result_table,offset,list_offset,all_data,current_list,current_batch,running_total,state) {
 /* parameters: List, separator, delimiter */
 if (!running_total) running_total=0;
 var batch;
 if (!current_batch)
   batch=[];
  else
   batch=current_batch;
 if (offset<all_data.length){
  try {
   var list="";
   if ((list_offset==0)||(current_list==null)) {
    list=jQuery.csv.toArray(all_data[offset].params[0],{separator:all_data[offset].params[1],delimiter:all_data[offset].params[2]});
  } 
  else
    list=current_list;
   if (list_offset<list.length) {
    let next_list_offset=list_offset+1;
    var batch_row={};
    batch_row.src_table= all_data[offset].src_table;
    batch_row.src_rowid= all_data[offset].src_rowid;
    batch_row.grouping_result= parseInt(list_offset+1).toString();
    batch_row.status=true;
    batch_row.result=list[list_offset];
    batch_row.err_message=null;
    batch.push(batch_row);
    let next_running_total=running_total+1;
    if (batch.length>150) {
      cf_progress(offset,all_data.length,false,next_running_total);
      customListSplit_insert(result_table,offset,next_list_offset,all_data,list,batch,next_running_total,state);
     }
    else
     customListSplit_handler(result_table,offset,next_list_offset,all_data,list,batch,next_running_total,state);
    return;
   }
       } catch(e) {
       var err_row=[];
       err_row.push(all_data[offset].src_table);
       err_row.push(all_data[offset].src_rowid);
       err_row.push(null);
       err_row.push(false);
       err_row.push(null);
       err_row.push(e.message);
       gDB.transaction(function (t) {
        t.executeSql("insert into "+sanitise(result_table)+
                    "(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values (?,?,?,?,?,?)",err_row);
                                    },$L,function(){customListSplit_handler(result_table,offset+1,0,all_data,running_total,state);});
       return;
                  }
   cf_progress(offset,all_data.length,false,running_total);
   let next_offset=offset+1;
   let next_list_offset=0;
   customListSplit_handler(result_table,next_offset,next_list_offset,all_data,null,batch,running_total,state);
   return;
   }
  if ((batch)&&(batch.length)>0) {
    customListSplit_insert(result_table,all_data.length,0,all_data,list,batch,running_total,state);
    return;
    }
  cf_progress(all_data.length,all_data.length,true,running_total);
  // Finished
  next_task(state);
}

function customListSplit_insert(result_table,offset,list_offset,all_data,list,batch_results,running_total,state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0;i<batch_results.length;i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(the_row.src_table,the_row.src_rowid,the_row.grouping_result,(the_row.status?'true':'false'),the_row.result,the_row.err_message);
 };
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+
	         all_placeholders,all_params);
                            }, null, function () { 
    customListSplit_handler(result_table,offset,list_offset,all_data,list,null,running_total,state);});
}

// ---------------------------------
// As defined in VF_CUSTOM_FUNCTIONS
function customPointSplit(result_table,all_data,state) {
 customPointSplit_handler(result_table,0,0,all_data,null,null,0,state);
};

function customPointSplit_handler(result_table,offset,list_offset,all_data,current_list,current_batch,running_total,state) {
 /* parameters: Point Geometry */
 if (!running_total) running_total=0;
 var batch;
 if (!current_batch)
  batch=[];
 else
  batch=current_batch;
 if (offset<all_data.length){
  try {
   var list="";
   if ((list_offset==0)||(current_list==null)){
    var gj=wkt2geojson(all_data[offset].params[0]);
    list= gj.coordinates;
    } 
  else
    list=current_list;
   if (list_offset<list.length){
    let next_list_offset=list_offset+1;
    var batch_row={};
    batch_row.src_table=all_data[offset].src_table;
    batch_row.src_rowid=all_data[offset].src_rowid;
    batch_row.grouping_result=parseInt(list_offset+1).toString();
    batch_row.status=true;
    batch_row.result=list[list_offset];
    batch_row.err_message=null;
    batch.push(batch_row);
    let next_running_total=running_total+1;
    if (batch.length>150) {
      cf_progress(offset,all_data.length,false,next_running_total);
      customPointSplit_insert(result_table,offset,next_list_offset,all_data,list,batch,next_running_total,state);
     }
    else
     customPointSplit_handler(result_table,offset,next_list_offset,all_data,list,batch,next_running_total,state);
    return;
   }
       } catch(e) {
       var err_row=[];
       err_row.push(all_data[offset].src_table);
       err_row.push(all_data[offset].src_rowid);
       err_row.push(null);
       err_row.push(false);
       err_row.push(null);
       err_row.push(e.message);
       gDB.transaction(function(t){
        t.executeSql("insert into "+sanitise(result_table)+
                    "(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values (?,?,?,?,?,?)",err_row);
                                    },$L,function(){ customPointSplit_handler(result_table,offset+1,0,all_data,running_total,state);});
       return;
                  }
   cf_progress(offset,all_data.length,false,running_total);
   let next_offset=offset+1;
   let next_list_offset=0;
   customPointSplit_handler(result_table,next_offset,next_list_offset,all_data,null,batch,running_total,state);
   return;
   }
  if ((batch)&&(batch.length)>0) {
    customPointSplit_insert(result_table,all_data.length,0,all_data,list,batch,running_total,state);
    return;
    }
  cf_progress(all_data.length,all_data.length,true,running_total);
  // Finished
  next_task(state);
}

function customPointSplit_insert(result_table,offset,list_offset,all_data,list,batch_results,running_total,state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0;i<batch_results.length;i++){
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(the_row.src_table,the_row.src_rowid,the_row.grouping_result,(the_row.status?'true':'false'),the_row.result,the_row.err_message);
 };
 gDB.transaction(function (t) {
   t.executeSql('insert into '+sanitise(result_table)+
	         '(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values '+all_placeholders,all_params);
                              },$L,function(){ 
    customPointSplit_handler(result_table,offset,list_offset,all_data,list,null,running_total,state);});
}


// ---------------------------------
// As defined in VF_CUSTOM_FUNCTIONS
function customGeometryCollectionSplit(result_table,all_data,state) {
 customGeometryCollectionSplit_handler(result_table,0,0,all_data,null,null,0,state);
};

function customGeometryCollectionSplit_handler(result_table,offset,list_offset,all_data,current_list,current_batch,running_total,state) {
 /* parameters: GeometryCollection Geometry */
 if (!running_total) running_total=0;
 var batch;
 if (!current_batch)
  batch=[];
 else
   batch=current_batch;
 if (offset<all_data.length){
 try {
  var list="";
  if ((list_offset==0)||(current_list==null)){
   var a=wkt2geojson(all_data[offset].params[0]);
   if (a.type.toLowerCase()!='geometrycollection')
    list=[all_data[offset].params[0]];
   else
    list=a.geometries.map(geojson2wkt);
   } 
 else
   list=current_list;
  if (list_offset<list.length){
   let next_list_offset=list_offset+1;
   var batch_row={};
   batch_row.src_table=all_data[offset].src_table;
   batch_row.src_rowid=all_data[offset].src_rowid;
   batch_row.grouping_result=parseInt(list_offset+1).toString();
   batch_row.status=true;
   batch_row.result=list[list_offset];
   batch_row.err_message=null;
   batch.push(batch_row);
   let next_running_total=running_total+1;
   if (batch.length > 150) {
     cf_progress(offset,all_data.length,false,next_running_total);
     customGeometryCollectionSplit_insert(result_table,offset,next_list_offset,all_data,list,batch,next_running_total,state);
    }
   else
    customGeometryCollectionSplit_handler(result_table,offset,next_list_offset,all_data,list,batch,next_running_total,state);
   return;
  }
       } catch(e) {
       var err_row=[];
       err_row.push(all_data[offset].src_table);
       err_row.push(all_data[offset].src_rowid);
       err_row.push(null);
       err_row.push(false);
       err_row.push(null);
       err_row.push(e.message);
       gDB.transaction(function(t){
        t.executeSql('insert into '+sanitise(result_table)+
                    '(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values (?,?,?,?,?,?)',err_row);
                                    },$L,function(){ customGeometryCollectionSplit_handler(result_table,offset+1,0,all_data,running_total,state);});
       return;
                  }
   cf_progress(offset,all_data.length,false,running_total);
   let next_offset=offset+1;
   let next_list_offset=0;
   customGeometryCollectionSplit_handler(result_table,next_offset,next_list_offset,all_data,null,batch,running_total,state);
   return;
   }
  if ((batch)&&(batch.length)>0) {
    customGeometryCollectionSplit_insert(result_table,all_data.length,0,all_data,list,batch,running_total,state);
    return;
    }
  cf_progress(all_data.length,all_data.length,true,running_total);
  // Finished
  next_task(state);
}

function customGeometryCollectionSplit_insert(result_table,offset,list_offset,all_data,list,batch_results,running_total,state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0;i<batch_results.length;i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(the_row.src_table,the_row.src_rowid,the_row.grouping_result,(the_row.status?'true':'false'),the_row.result,the_row.err_message);
 };
 gDB.transaction(function(t) {
   t.executeSql('insert into '+sanitise(result_table)+'(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values '+
	         all_placeholders,all_params);
                             }, $L,function(){ 
    customGeometryCollectionSplit_handler(result_table,offset,list_offset,all_data,list,null,running_total,state);});
}


// As defined in VF_CUSTOM_FUNCTIONS
function customClusterDbscan(result_table,all_data,state) {
 /* parameters: Point, maxDistance, Units, minPoints, ResultType */
 var feat_array=[];
 var opts={};
 var maxDistance='';
 var src_table='';
 try { src_table=all_data[0].src_table; } catch(e) {};
 for (var i=0;i<all_data.length;i++) {
  try {
   var gj=wkt2geojson(all_data[i].params[0]);
   var ft=toFeature(gj);
   ft.properties={src_rowid:all_data[i].src_rowid, src_table:all_data[i].src_table, result_type: all_data[i].params[4]};
   feat_array.push(ft);
      } catch(e) { /* Ignoring non-valid geometry? */ }
   if (i==0) {
    if (all_data[i].params[1])
     maxDistance=all_data[i].params[1];
    if (all_data[i].params[2])
     opts["units"]=all_data[i].params[2];
    if (all_data[i].params[3])
     opts["minPoints"]=all_data[i].params[3];
    opts["mutate"]=true;
   }
 }
 var FC= turf.featureCollection(feat_array);
 try {
  var cluster=turf.clustersDbscan(FC,maxDistance,opts);
     } catch(e) { CustomInvocationFail(result_table, src_table, e.message, state); return; };
 var data=[]
 if ((cluster)&&(cluster.features)) {
  data= cluster.features;
  customClusterDbscan_handler(result_table, 0, data, null, state);
  return;
 }
 // No data found
 next_task(state);
}

function customClusterDbscan_handler(result_table, offset, all_data, batch, state) {
  if (!offset)
   offset=0;
  if (!batch)
   batch=[];
  for (var i=offset; i<all_data.length; i++) {
   var batch_row={};
   batch_row.src_table=all_data[i].properties.src_table;
   batch_row.src_rowid=all_data[i].properties.src_rowid;
   batch_row.grouping_result=null;
   batch_row.result=all_data[i].properties.cluster; 
   var rt=all_data[i].properties.result_type.toLowerCase();
   if (rt=='dbscan')
    batch_row.result=all_data[i].properties.dbscan;
   if (rt=='point')
    batch_row.result=geojson2wkt(all_data.geometry);
   if (rt=='all') {
    //Should really use CSV to stringify
    var rs='';
    var cluster=all_data[i].properties.cluster;
    if ((cluster)||(cluster==0))
     rs+='"'+cluster.toString()+'"';
    else
     rs+='""';
    var dbscan=all_data[i].properties.dbscan;
    if (dbscan)
     rs+=',"'+dbscan+'"';
    else
     rs+=',""';
    rs+=',"'+geojson2wkt(all_data[i].geometry)+'"';
    batch_row.result=rs;
    }
   batch_row.status=true;
   batch_row.err_message=null;
   batch.push(batch_row);
   let next_offset=Math.min(all_data.length, offset+150);
   if (batch.length > 150) {
     cf_progress(offset, all_data.length, false, null);
     customClusterDbscan_insert(result_table, next_offset, all_data, batch, state);
     return;
     }
   }
  // Residual
  if (offset<all_data.length) {
   cf_progress(offset, all_data.length, false, null);
   customClusterDbscan_insert(result_table, all_data.length, all_data, batch, state);
   return;
  }
  cf_progress(all_data.length, all_data.length, true, null);
  // Finished
  next_task(state);
}

function customClusterDbscan_insert(result_table, offset, all_data, batch_results, state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0; i<batch_results.length; i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(the_row.src_table, the_row.src_rowid, the_row.grouping_result, (the_row.status ? 'true' : 'false'), the_row.result, the_row.err_message);
 };
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+all_placeholders,all_params);
                            }, null, function () { 
    customClusterDbscan_handler(result_table, offset, all_data, null, state); });
}



// ------------------------------------------------------

// As defined in VF_CUSTOM_FUNCTIONS
function customClusterKmeans(result_table, all_data, state) {
 /* parameters: Point, numberOfClusters, ResultType */
 var feat_array=[];
 var opts={};
 var src_table='';
 try { src_table=all_data[0].src_table; } catch(e) {};
 for (var i=0; i<all_data.length; i++) {
  try {
   var gj= wkt2geojson(all_data[i].params[0]);
   var ft=toFeature(gj);
   ft.properties = {src_rowid: all_data[i].src_rowid, src_table: all_data[i].src_table, result_type: all_data[i].params[2]};
   feat_array.push(ft);
      } catch(e) { /* Ignoring non-valid geometry */ }
   if (i==0) {
    if (all_data[i].params[1])
     opts["numberOfClusters"]=all_data[i].params[1];
    opts["mutate"]=true;
   }
 }
 var FC= turf.featureCollection(feat_array);
 try {
  var cluster=turf.clustersKmeans(FC,opts);
     } catch(e) { CustomInvocationFail(result_table, src_table, e.message, state); return; };
 var data=[]
 if ((cluster)&&(cluster.features)) {
  data= cluster.features;
  customClusterKmeans_handler(result_table, 0, data, null, state);
  return;
 }
 // No data found
 next_task(state);
}

function customClusterKmeans_handler(result_table, offset, all_data, batch, state) {
  if (!offset)
   offset=0;
  if (!batch)
   batch=[];
  for (var i=offset; i<all_data.length; i++) {
   var batch_row={};
   batch_row.src_table=all_data[i].properties.src_table;
   batch_row.src_rowid=all_data[i].properties.src_rowid;
   batch_row.grouping_result=null;
   batch_row.result=all_data[i].properties.cluster; 
   var rt=all_data[i].properties.result_type.toLowerCase();
   if (rt=='centroid')
    batch_row.result=geojson2wkt(turf.point(all_data[i].properties.centroid));
   if (rt=='point')
    batch_row.result=geojson2wkt(all_data.geometry);
   if (rt=='all') {
    //Should really use CSV to stringify
    var rs='';
    var cluster = all_data[i].properties.cluster;
    if ((cluster)||(cluster==0))
     rs+='"'+cluster.toString()+'"';
    else
     rs+='""';
    var centroid=geojson2wkt(turf.point(all_data[i].properties.centroid));
    if (centroid)
     rs+=',"'+centroid+'"';
    else
     rs+=',""';
    rs+=',"'+geojson2wkt(all_data[i].geometry)+'"';
    batch_row.result=rs;
    }
   batch_row.status=true;
   batch_row.err_message=null;
   batch.push(batch_row);
   let next_offset=Math.min(all_data.length, offset+150);
   if (batch.length>150) {
     cf_progress(offset, all_data.length, false, null);
     customClusterKmeans_insert(result_table, next_offset, all_data, batch, state);
     return;
     }
   }
  // Residual
  if (offset<all_data.length) {
   cf_progress(offset, all_data.length, false, null);
   customClusterKmeans_insert(result_table, all_data.length, all_data, batch, state);
   return;
  }
  cf_progress(all_data.length, all_data.length, true, null);
  // Finished
  next_task(state);
}

function customClusterKmeans_insert(result_table, offset, all_data, batch_results, state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0; i<batch_results.length; i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(the_row.src_table, the_row.src_rowid, the_row.grouping_result, (the_row.status ? 'true' : 'false'), the_row.result, the_row.err_message);
 };
 gDB.transaction(function(t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+all_placeholders,all_params);
                            }, null, function () { 
    customClusterKmeans_handler(result_table, offset, all_data, null, state); });  
}


// ------------------------------------------------------
// As defined in VF_CUSTOM_FUNCTIONS
function customInterpolate(result_table, all_data, state) {
 /* parameters: Point, cellSize, gridType, Property, Units, Weight */
 var feat_array=[];
 var opts={};
 var src_table="";
 try { src_table=all_data[0].src_table; } catch(e) {};
 var cellSize="";
 for (var i=0; i<all_data.length; i++) {
  try {
   var gj= wkt2geojson(all_data[i].params[0]);
   var ft=toFeature(gj);
   ft.properties = {src_rowid: all_data[i].src_rowid, src_table: all_data[i].src_table, z: all_data[i].params[3]};
   feat_array.push(ft);
      } catch(e) { /* Ignoring non-valid geometry? */ }
   if (i==0) {
    src_table=all_data[i].src_table;
    if (all_data[i].params[1])
     cellSize=all_data[i].params[1];
    if (all_data[i].params[2])
     opts["gridType"]=all_data[i].params[2];
    opts["property"]="z";
    if (all_data[i].params[4])
     opts["units"]=all_data[i].params[4];
    if (all_data[i].params[5])
     opts["weight"]=parseFloat(all_data[i].params[5]);
    opts["mutate"]=true;
   }
 }
 var FC= turf.featureCollection(feat_array);
 try {
  var grid = turf.interpolate(FC, cellSize, opts);
     } catch(e) { CustomInvocationFail(result_table, src_table, e.message, state); return; };
 var data=[]
 if ((grid)&&(grid.features)) {
  data= grid.features;
  customInterpolate_handler(src_table, result_table, 0, data, null, state);
  return;
 }
 // No data found
 next_task(state);
}

function customInterpolate_handler(src_table, result_table, offset, all_data, batch, state) {
  if (!offset)
   offset=0;
  if (!batch)
   batch=[];
  for (var i=offset; i<all_data.length; i++) {
   var batch_row={};
   batch_row.src_table=all_data[i].properties.src_table;
   batch_row.src_rowid=all_data[i].properties.src_rowid;
   batch_row.grouping_result=all_data[i].properties.z;
   batch_row.result=geojson2wkt(all_data[i].geometry);
   batch_row.status=true;
   batch_row.err_message=null;
   batch.push(batch_row);
   let next_offset=Math.min(all_data.length, offset+150);
   if (batch.length > 150) {
     cf_progress(offset, all_data.length, false, null);
     customInterpolate_insert(src_table, result_table, next_offset, all_data, batch, state);
     return;
     }
   }
  // Residual
  if (offset < all_data.length) {
   cf_progress(offset, all_data.length, false, null);
   customInterpolate_insert(src_table, result_table, all_data.length, all_data, batch, state);
   return;
  }
  cf_progress(all_data.length, all_data.length, true, null);
  // Finished
  next_task(state);
}

function customInterpolate_insert(src_table, result_table, offset, all_data, batch_results, state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0; i<batch_results.length; i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(src_table, null, the_row.grouping_result, (the_row.status ? 'true' : 'false'), the_row.result, the_row.err_message);
 };
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+all_placeholders,all_params);
                            }, $L, function () { 
    customInterpolate_handler(src_table, result_table, offset, all_data, null, state); });
}



// ---------------------
// As defined in VF_CUSTOM_FUNCTIONS
function customTIN(result_table, all_data, state) {
 /* parameters: Point, z-Value */
 var feat_array=[];
 var src_table='';
 try { src_table=all_data[0].src_table; } catch(e) {};
 for (var i=0; i<all_data.length; i++) {
  try {
   var gj=wkt2geojson(all_data[i].params[0]);
   var ft=toFeature(gj);
   ft.properties = {src_rowid: all_data[i].src_rowid, src_table: all_data[i].src_table, z: all_data[i].params[1]};
   feat_array.push(ft);
      } catch(e) { /* Ignoring non-valid geometry? */ }
 }
 var FC=turf.featureCollection(feat_array);
 try {
  var tin=turf.tin(FC,'z');
     } catch(e) { CustomInvocationFail(result_table, src_table, e.message, state); return; };
 var data=[];
 if ((tin)&&(tin.features)) {
  data= tin.features;
  customTIN_handler(src_table, result_table, 0, data, null, state);
  return;
 }
 // No data found
 next_task(state);
}

function customTIN_handler(src_table, result_table, offset, all_data, batch, state) {
  if (!offset)
   offset=0;
  if (!batch)
   batch=[];
  for (var i=offset; i<all_data.length; i++) {
   var batch_row={};
   batch_row.src_table=all_data[i].properties.src_table;
   batch_row.src_rowid=all_data[i].properties.src_rowid;
   if ((all_data[i].properties.a)||(all_data[i].properties.a == 0)) 
    batch_row.grouping_result=all_data[i].properties.a.toString()+','+
                              all_data[i].properties.b.toString()+','+
                              all_data[i].properties.c.toString();
   else
    batch_row.grouping_result=null;
   batch_row.result=geojson2wkt(all_data[i].geometry);
   batch_row.status=true;
   batch_row.err_message=null;
   batch.push(batch_row);
   let next_offset=Math.min(all_data.length, offset+150);
   if (batch.length>150) {
     cf_progress(offset, all_data.length, false, null);
     customTIN_insert(src_table, result_table, next_offset, all_data, batch, state);
     return;
     }
   }
  // Residual
  if (offset < all_data.length) {
   cf_progress(offset, all_data.length, false, null);
   customTIN_insert(src_table, result_table, all_data.length, all_data, batch, state);
   return;
  }
  cf_progress(all_data.length, all_data.length, true, null);
  // Finished
  next_task(state);
}

function customTIN_insert(src_table, result_table, offset, all_data, batch_results, state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0; i<batch_results.length; i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(src_table, null, the_row.grouping_result, (the_row.status ? 'true' : 'false'), the_row.result, the_row.err_message);
 };
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+all_placeholders,all_params);
                            }, null, function () { 
    customTIN_handler(src_table, result_table, offset, all_data, null, state); });
}


// ------------------------------------------------------
// As defined in VF_CUSTOM_FUNCTIONS

function customISO(result_table, all_data, state) {
 /* Parameters; Points, z-Value, breaks (list), separator, delimiter, ISO-type */
 var feat_array=[];
 var src_table="";
 try { src_table=all_data[0].src_table; } catch(e) {};
 for (var i=0; i<all_data.length; i++) {
  try {
   var gj=wkt2geojson(all_data[i].params[0]);
   var ft=toFeature(gj);
   ft.properties = {src_rowid: all_data[i].src_rowid, src_table: all_data[i].src_table, z: all_data[i].params[1]};
   feat_array.push(ft);
      } catch(e) { /* Ignoring non-valid geometry? */ }
  }
 var FC= turf.featureCollection(feat_array);
 var iso='';
 try {
  var breaks=jQuery.csv.toArray(all_data[0].params[2],{separator: all_data[0].params[3], delimiter: all_data[0].params[4]});
  if (all_data[0].params[5].toLowerCase() == 'isobands')
   iso= turf.isobands(FC,breaks,{zProperty: "z"});
  else
   iso=turf.isolines(FC,breaks,{zProperty:"z"});
     } catch(e) { CustomInvocationFail(result_table, src_table, e.message, state); return; };
 var data=[];
 if ((iso)&&(iso.features)) {
  data= iso.features;
  customISO_handler(src_table, result_table, 0, data, null, state);
  return;
 }
 // No data found
 next_task(state);
}

function customISO_handler(src_table, result_table, offset, all_data, batch, state) {
  if (!offset)
   offset=0;
  if (!batch)
   batch=[];
  for (var i=offset; i<all_data.length; i++) {
   var batch_row={};
   batch_row.src_table=src_table;
   batch_row.src_rowid=null;
   batch_row.grouping_result=all_data[i].properties.z;
   batch_row.result=geojson2wkt(all_data[i].geometry); 
   batch_row.status=true;
   batch_row.err_message=null;
   batch.push(batch_row);
   let next_offset=Math.min(all_data.length, offset+150);
   if (batch.length > 150) {
     cf_progress(offset, all_data.length, false, null);
     customISO_insert(src_table, result_table, next_offset, all_data, batch, state);
     return;
     }
   }
  // Residual
  if (offset<all_data.length) {
   cf_progress(offset, all_data.length, false, null);
   customISO_insert(src_table, result_table, all_data.length, all_data, batch, state);
   return;
  }
  cf_progress(all_data.length, all_data.length, true, null);
  // Finished
  next_task(state);
}

function customISO_insert(src_table, result_table, offset, all_data, batch_results, state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0; i<batch_results.length; i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(src_table, null, the_row.grouping_result, (the_row.status ? 'true' : 'false'), the_row.result, the_row.err_message);
 };
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+all_placeholders,all_params);
                            }, null, function () { 
    customISO_handler(src_table, result_table, offset, all_data, null, state); });
}


// ------------------------------------------------------
// As defined in VF_CUSTOM_FUNCTIONS

function customVoronoi(result_table, all_data, state) {
 /* Parameters; Points */
 var feat_array=[];
 var src_table="";
 try { src_table=all_data[0].src_table; } catch(e) {};
 for (var i=0; i<all_data.length; i++) {
  try {
   var gj=wkt2geojson(all_data[i].params[0]);
   var ft=toFeature(gj);
   ft.properties = {src_rowid: all_data[i].src_rowid, src_table: all_data[i].src_table};
   feat_array.push(ft);
      } catch(e) { /* Ignoring non-valid geometry? */ }
  }
 var FC= turf.featureCollection(feat_array);
 var voronoi="";
 try {
   voronoi=turf.voronoi(FC);
     } catch(e) { CustomInvocationFail(result_table, src_table, e.message, state); return; };
 var data=[]
 if ((voronoi)&&(voronoi.features)) {
  data= voronoi.features;
  customVoronoi_handler(src_table, result_table, 0, data, null, state);
  return;
 }
 // No data found
 next_task(state);
}

function customVoronoi_handler(src_table, result_table, offset, all_data, batch, state) {
  if (!offset)
   offset=0;
  if (!batch)
   batch=[];
  for (var i=offset; i<all_data.length; i++) {
   var batch_row={};
   batch_row.src_table=src_table;
   batch_row.src_rowid=null;  //? Unsure if this maps back
   batch_row.grouping_result=null;
   batch_row.result=geojson2wkt(all_data[i].geometry); 
   batch_row.status=true;
   batch_row.err_message=null;
   batch.push(batch_row);
   let next_offset=Math.min(all_data.length, offset+150);
   if (batch.length > 150) {
     cf_progress(offset, all_data.length, false, null);
     customVoronoi_insert(src_table, result_table, next_offset, all_data, batch, state);
     return;
     }
   }
  // Residual
  if (offset<all_data.length) {
   cf_progress(offset, all_data.length, false, null);
   customVoronoi_insert(src_table, result_table, all_data.length, all_data, batch, state);
   return;
  }
  cf_progress(all_data.length, all_data.length, true, null);
  // Finished
  next_task(state);
}

function customVoronoi_insert(src_table, result_table, offset, all_data, batch_results, state) {
 var all_params=[];
 var placeholders="(?,?,?,?,?,?)";
 var all_placeholders="";
 for (var i=0; i<batch_results.length; i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(src_table, null, the_row.grouping_result, (the_row.status ? 'true' : 'false'), the_row.result, the_row.err_message);
 };
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+all_placeholders,all_params);
                            }, null, function () { 
    customVoronoi_handler(src_table, result_table, offset, all_data, null, state); });
}

function CustomInvocationFail(result_table, src_table, msg, state) {
 // General Catch all for custom function invocation fail
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+"(SRC_TABLE, RESULT_STATUS, ERR_MESSAGE) values (?,?,?)",[src_table,"false",msg]);
                            }, function(e) { next_task(state); }, function () { next_task(state); });
}



/* ----- Begin Custom Function Metadata ----- */

var VF_CUSTOM_FUNCTIONS =
[
 { id: 1010,
   library: "Math",
   name: "abs",
   type: "immutable",
   help: "Returns the absolute value of x (Note; this may be a database builtin).",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.abs(params[0]);
                          }
 },
{ id: 1020,
   library: "Math",
   name: "acos",
   type: "immutable",
   help: "Returns the arccosine of x, in radians",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.acos(params[0]);
                          }
 },
{ id: 1030,
   library: "Math",
   name: "acosh",
   type: "immutable",
   help: "	Returns the hyperbolic arccosine of x",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.acosh(params[0]);
                          }
 },
{ id: 1040,
   library: "Math",
   name: "asin",
   type: "immutable",
   help: "Returns the arcsine of x, in radians",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.asin(params[0]);
                          }
 },
{ id: 1050,
   library: "Math",
   name: "asinh",
   type: "immutable",
   help: "Returns the hyperbolic arcsine of x, in radians",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.asinh(params[0]);
                          }
 },
{ id: 1060,
   library: "Math",
   name: "atan",
   type: "immutable",
   help: "Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.atan(params[0]);
                          }
 },
{ id: 1070,
   library: "Math",
   name: "atan2",
   type: "immutable",
   help: "Returns the arctangent of the quotient of its arguments",
   parameters: [{name: "y", help: "y", optional: false, default: null},
                {name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.atan2(params[0],params[1]);
                          }
 },
{ id: 1080,
   library: "Math",
   name: "atanh",
   type: "immutable",
   help: "Returns the hyperbolic arctangent of x",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.atanh(params[0]);
                          }
 },
{ id: 1090,
   library: "Math",
   name: "cbrt",
   type: "immutable",
   help: "Returns the cubic root of x",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.cbrt(params[0]);
                          }
 },
{ id: 1100,
   library: "Math",
   name: "ceil",
   type: "immutable",
   help: "Returns the value of x rounded up to its nearest integer",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.ceil(params[0]);
                          }
 },
{ id: 1110,
   library: "Math",
   name: "cos",
   type: "immutable",
   help: "Returns the cosine of x (x is in radians)",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.cos(params[0]);
                          }
 },
{ id: 1120,
   library: "Math",
   name: "cosh",
   type: "immutable",
   help: "Returns the hyperbolic cosine of x",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.cosh(params[0]);
                          }
 },
{ id: 1130,
   library: "Math",
   name: "exp",
   type: "immutable",
   help: "Returns the value of exp(x)",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.exp(params[0]);
                          }
 },
{ id: 1140,
   library: "Math",
   name: "floor",
   type: "immutable",
   help: "Returns the value of x rounded down to its nearest integer",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.floor(params[0]);
                          }
 },
{ id: 1150,
   library: "Math",
   name: "log",
   type: "immutable",
   help: "Returns the natural logarithm (base E) of x",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.log(params[0]);
                          }
 },
{ id: 1160,
   library: "Math",
   name: "pow",
   type: "immutable",
   help: "Returns the value of x to the power of y",
   parameters: [{name: "x", help: "x", optional: false, default: null},
                {name: "y", help: "y", optional: false, default: null}],
   func: function(params) {
            return Math.pow(params[0],params[1]);
                          }
 },
{ id: 1170,
   library: "Math",
   name: "random",
   type: "immutable",
   help: "Returns a random number between 0 and 1. (Note: this may be a database builtin)",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.random(params[0]);
                          }
 },
{ id: 1180,
   library: "Math",
   name: "round",
   type: "immutable",
   help: "Returns the value of x rounded to its nearest integer.  (Note: this may be a database builtin)",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.round(params[0]);
                          }
 },
{ id: 1190,
   library: "Math",
   name: "sin",
   type: "immutable",
   help: "Returns the sine of x (x is in radians)",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.sin(params[0]);
                          }
 },
{ id: 1200,
   library: "Math",
   name: "sqrt",
   type: "immutable",
   help: "Returns the square root of x",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.sqrt(params[0]);
                          }
 },
{ id: 1210,
   library: "Math",
   name: "tan",
   type: "immutable",
   help: "Returns the tangent of an angle",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.tan(params[0]);
                          }
 },
{ id: 1220,
   library: "Math",
   name: "tanh",
   type: "immutable",
   help: "Returns the hyperbolic tangent of a number",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.tanh(params[0]);
                          }
 },
{ id: 1230,
   library: "Math",
   name: "trunc",
   type: "immutable",
   help: "Returns the integer part of a number (x). (Note: this may be a database builtin)",
   parameters: [{name: "x", help: "x", optional: false, default: null}],
   func: function(params) {
            return Math.trunc(params[0]);
                          }
 },

{ id: 1300,
   library: "Stats",
   name: "NumListMax",
   type: "immutable",
   help: "Returns the maximum value from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.max(the_list);
          return a;
                          }
 },
{ id: 1310,
   library: "Stats",
   name: "NumListMin",
   type: "immutable",
   help: "Returns the minimum value from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.min(the_list);
          return a;
                          }
 },
{ id: 1320,
   library: "Stats",
   name: "NumListRange",
   type: "immutable",
   help: "Returns the range from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.range(the_list);
          return a;
                          }
 },
{ id: 1330,
   library: "Stats",
   name: "NumListMidRange",
   type: "immutable",
   help: "Returns the Mid range (range/2) from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.midrange(the_list);
          return a;
                          }
 },
{ id: 1340,
   library: "Stats",
   name: "NumListSum",
   type: "immutable",
   help: "Returns the Sum of values from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.sum(the_list);
          return a;
                          }
 },
{ id: 1350,
   library: "Stats",
   name: "NumListMean",
   type: "immutable",
   help: "Returns the Mean (average) value from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.mean(the_list);
          return a;
                          }
 },
{ id: 1360,
   library: "Stats",
   name: "NumListModes",
   type: "immutable",
   help: "Returns a list of comma separated Modes from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.modes(the_list);
          var list = a.join(',');
          return list;
                          }
 },
{ id: 1370,
   library: "Stats",
   name: "NumListVariance",
   type: "immutable",
   help: "Returns the Variance value from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.variance(the_list);
          return a;
                          }
 },
{ id: 1380,
   library: "Stats",
   name: "NumListStdDeviation",
   type: "immutable",
   help: "Returns the Standard Deviation value from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.standardDeviation(the_list);
          return a;
                          }
 },
{ id: 1390,
   library: "Stats",
   name: "NumListMeanAbsDev",
   type: "immutable",
   help: "Returns the Mean Absolute Deviation value from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.meanAbsoluteDeviation(the_list);
          return a;
                          }
 },
{ id: 1395,
   library: "Stats",
   name: "NumListzScores",
   type: "immutable",
   help: "Returns a list of comma separated zScores from a delimited list of numeric values",
   parameters: [{name: "Numeric List", help: "A list of numeric values separated by a delimiter.", optional: false, default: null},
                {name: "Separator", help: "Character separating values in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each value in list", optional: true, default: '"'}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var the_list = jQuery.csv.toArray(params[0],csv_opts);
          var a = numArray.zScores(the_list);
          var list = a.join(',');
          return list;
                          }
 },
 { id: 1400,
   library: "Misc",
   name: "TokenMatch",
   type: "immutable",
   help: "Translates 'query' and 'string' terms to alphanumeric tokens. "+
         "The function will return 'true' if the 'query' tokens are present in the 'string' tokens irrespective of order.",
   parameters: [{name: "Query", help: "The search term to be tested", optional: false, default: null},
                {name: "String", help: "The text string to be searched", optional: false, default: null},
                {name: "Match Ratio", help: "The ratio of number of tokens in 'query' (that have matching tokens in 'string') divided by the total number of tokens in 'query'. "+
                                               "If the match ratio is higher than the threshold, the function will return 'true'. Ie, can make a 'looser' search.  A value of 1 means that "+
                                               "all tokens in 'query' must be found in 'string'.  Eg, a value of 0.8 means 4 out 5 tokens must be found. Valid range: 0 .. 1", optional: true, default: "1"}],
   func: function(params) {
            return token_search(params[0], params[1], params[2]);  
                          }
 },
 { id: 1410,
   library: "Misc",
   name: "DbleMetaphoneMatch",
   type: "immutable",
   help: "Translates 'query' and 'string' terms to alphanumeric tokens then computes double metaphones for both 'query' and 'string'. "+
         "The function will return 'true' if the 'query' metaphones are present in the 'string' metaphones. Not suitable for numeric tokens.",
   parameters: [{name: "Query", help: "The search term to be tested", optional: false, default: null},
                {name: "String", help: "The text string to be searched", optional: false, default: null},
                {name: "Stemmer", help: "Optional parameter. Indicates where prefix searching (Porter) is to be applied.", optional: true, default: "false"},
                {name: "Match Ratio", help: "The ratio of number of tokens in 'query' (that have matching metaphones in 'string') divided by the total number of tokens in 'query'. "+
                                               "If the match ratio is higher than the threshold, the function will return 'true'. Ie, can make a 'looser' search by reducing the value below 1."+
                                               "  A value of 1 means all token double metaphones in 'query' must be found in 'string'.  Eg, a value of 0.8 means that 4 out of 5 metaphones must match. "+
                                               " Valid range: 0 .. 1", optional: true, default: "1"}],
   func: function(params) {
            return metaphone_search(params[0], params[1], params[2], params[3]);  
                          }
 },
 { id: 1420,
   library: "Misc",
   name: "encodeURIComponent",
   type: "immutable",
   help: "The encodeURIComponent() function encodes a URI component.",
   parameters: [{name: "URI", help: "The URI string to be encoded", optional: false, default: null}],
   func: function(params) {
            return encodeURIComponent(params[0]);  
                          }
 },
 { id: 1430,
   library: "Misc",
   name: "isValidGeometry",
   type: "immutable",
   help: "Returns true if WKT is a valid; Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon or GeometryCollection.",
   parameters: [{name: "WKT", help: "The WKT to be tested", optional: false, default: null}],
   func: function(params) {
            if (!params[0])
             return false;
            var WKT="";
            try {
             var gj=wkt2geojson(params[0]);
             WKT=geojson2wkt(gj);
                 } catch(e) { return false; };
            if (WKT)
             return true;
            return false;
                          }
 },
 { id: 1440,
   library: "Misc",
   name: "makeSimplePoint",
   type: "immutable",
   help: "Creates a simple WKT Point Geometry from provided ordinates.  Note, no M or Z qualifiers will be added",
   parameters: [{name: "Ordinate1", help: "The first ordinate", optional: false, default: null},
                {name: "Ordinate2", help: "The second ordinate", optional: false, default: null},
                {name: "Ordinate3", help: "The third ordinate (optional)", optional: true, default: null}],
   func: function(params) {
            var o1=parseFloat(params[0]).toString();
            var o2=parseFloat(params[1]).toString();
            var o3='';
            if (params[2])
             o3=' '+parseFloat(params[2]).toString();
            return 'POINT ('+o1+' '+o2+o3+')';  
                          }
 },
{ id: 1450,
  library: "Misc",
   name: "makeLineString",
   type: "immutable",
   help: "Creates a WKT LineString Geometry from a list of Ordinates.",
   parameters: [{name: "Ordinate List", help: "Ordinates that will make up the LineString", optional: false, default: null},
                {name: "Dimension", help: "The dimension of the ordinates; Eg; 2 for 2 dimension (pair), 3 for 3 dimension, etc.", optional: false, default: "2"},
                {name: "Separator", help: "character separating ordinates in list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each ordinate", optional: true, default: '"'}],
    func: function(params) {
          var csv_opts={};
          if (params[2])
           csv_opts["separator"]=params[2];
          if (params[3])
           csv_opts["delimiter"]=params[3];
          var ordinate_array = jQuery.csv.toArray(params[0],csv_opts);
          var dim=2;
          if (params[1])
           dim= parseInt(params[1]);
          if ((!dim)||(dim <= 0))
           throw "Invalid dimension.";
          if (!ordinate_array)
           return null;
          var position_array=[];
          for (var i=0; i<=(ordinate_array.length-dim); i=i+dim) {
           var position=[];
           for (var p=0; p<dim; p++)
            position.push(parseFloat(ordinate_array[i+p]));
           position_array.push(position);
          }
         var LineString= turf.lineString(position_array);
         var WKT= geojson2wkt(LineString);
         return WKT;
          }
 },
{ id: 1460,
  library: "Misc",
   name: "makePolygon",
   type: "immutable",
   help: "Creates a WKT Polygon Geometry from a list of LinearRings, where a LinearRing is a list of Ordinates.",
   parameters: [{name: "Ring Ordinate List", help: "LinearRing Ordinates that will make up the Polygon", optional: false, default: null},
                {name: "Dimension", help: "The dimension of the ordinates.  Eg; 2 for 2 dimension (pair), 3 for 3 dimension, etc.", optional: false, default: "2"},
                {name: "Ordinate Separator", help: "Character separating ordinates in list", optional: false, default: ","},
                {name: "Ordinate Delimiter", help: "Optional Parameter. Delimiter character enclosing each ordinate", optional: true, default: '"'},
                {name: "Ring Separator", help: "Character separating each LinearRing ordinates list", optional: false, default: "|"},
                {name: "Ring Delimiter", help: "Optional Parameter. Delimiter character enclosing each LinearRing", optional: true, default: "'"}],

    func: function(params) {
          var dim=2;
          if (params[1])
           dim= parseInt(params[1]);
          if ((!dim)||(dim <= 0))
           throw "Invalid dimension.";
          var ord_csv_opts={};
          if (params[2])
           ord_csv_opts["separator"]=params[2];
          if (params[3])
           ord_csv_opts["delimiter"]=params[3];
          var ring_csv_opts={};
          if (params[4])
           ring_csv_opts["separator"]=params[4];
          if (params[5])
           ring_csv_opts["delimiter"]=params[5];
          var rings=jQuery.csv.toArray(params[0],ring_csv_opts);
          var result=[];
          for (var r=0; r<rings.length; r++) {
           var ordinate_array = jQuery.csv.toArray(rings[r],ord_csv_opts);
           if (!ordinate_array)
            continue;
           var position_array=[];
           for (var i=0; i<=(ordinate_array.length-dim); i=i+dim) {
            var position=[];
            for (var p=0; p<dim; p++)
             position.push(parseFloat(ordinate_array[i+p]));
            position_array.push(position);
           }
          result.push(position_array);
         }         
        var poly= turf.polygon(result);
        var WKT= geojson2wkt(poly);
        return WKT;
        }
 },
 { id: 1470,
   library: "Misc",
   name: "DistanceVincenty",
   type: "immutable",
   help: "Computes distance between 2 Points using Vincenty algorithm.  May be more accurate than Turf:distance but also computationally more expensive.  Assumes; (Long,Lat) "+
         "point ordinate ordering and ordinates are WGS84.  Results are in meters.",
   parameters: [{name: "From", help: "The source Point", optional: false, default: null},
                {name: "To", help: "The destination Point", optional: false, default: null}],
   func: function(params) {
           var from = wkt2geojson(params[0]);
           var to = wkt2geojson(params[1]);
           if (from.type != 'Point')
            throw "from - not a Point geometry";
           if (to.type != 'Point')
            throw "to - not a Point geometry";
           var vinc=distVincenty(from.coordinates[1],from.coordinates[0],to.coordinates[1],to.coordinates[0]);
           return vinc.distance; 
                          }
 },
 { id: 1500,
   library: "Misc",
   name: "ListSplit",
   type: "custom",
   help: "Splits a list of delimited values into an individual row of the list element value. "+
         "Note: For each repeated SRC_ROWID, the GROUPING_RESULT will have the extracted list element index starting at 1 and"+
         "the RESULT will be populated with the element value.",
   parameters: [{name: "List", help: "A list of delimited values to be split out.", optional: false, default: null},
                {name: "Separator", help: "Character separating the elements in the list", optional: false, default: ","},
                {name: "Delimiter", help: "Optional Parameter. Delimiter character enclosing each element in the list", optional: true, default: '"'}],
   func: customListSplit
 },
{ id: 1510,
   library: "Misc",
   name: "PointOrdinateSplit",
   type: "custom",
   help: "Splits a Point Geometry to an individual row of the Point ordinates. "+
         "Note: For each repeated SRC_ROWID, the GROUPING_RESULT will have the extracted ordinate index starting at 1."+
         " The RESULT field will be populated with the extracted ordinate value.",
   parameters: [{name: "Point", help: "A WKT Point Geometry.", optional: false, default: null}],
   func: customPointSplit
 },
{ id: 1520,
   library: "Misc",
   name: "GeometryCollectionSplit",
   type: "custom",
   help: "Splits a Geometry Collection to an individual row of the component geometries. "+
         "Note: For each repeated SRC_ROWID, the GROUPING_RESULT will have the extracted geometry index starting at 1 and the"+
         "RESULT field will have the extracted component Geometry",
   parameters: [{name: "GeometryCollection", help: "A WKT GeometryCollection Geometry.", optional: false, default: null}],
   func: customGeometryCollectionSplit
 },
{ id: 1530,
   library: "Misc",
   name: "clustersDbscan",
   type: "custom",
   help: "Internally calls Turf.clustersDbscan. Takes a set (table) of points and partition them into clusters according"+
          " to https://en.wikipedia.org/wiki/DBSCAN data clustering algorithm.",
   parameters: [{name: "Point", help: "The WKT Point Geometry to be clustered.", optional: false, default: null},
                {name: "maxDistance", help: "Maximum Distance between any point of the cluster to generate the clusters (kilometers only)", 
                 optional: false, default: "10"},
                {name: "Units", help: "Optional Parameter. In Which.", optional: true, default: "kilometers"},
                {name: "minPoints", help: "Minimum number of points to generate a single cluster, points which do not meet this requirement will be classified as an 'edge' or 'noise",
                 optional: true, default: "3"},
                {name: "ResultType", help: 'Either; cluster|dbscan|point|all. "cluster" will return the cluster id, "dbscan" will return the '+
                       'cluster dbscan value, "point" will return the Point geometry and "all" will return a list of all of these values.',
                 optional: true, default: "cluster"}],
   func: customClusterDbscan
 },
{ id: 1540,
   library: "Misc",
   name: "clustersKmeans",
   type: "custom",
   help: "Internally calls Turf.clustersKmeans. Takes a set (table) of points and partition them into clusters using the k-mean. It uses the k-means algorithm",
   parameters: [{name: "Point", help: "The WKT Point Geometry to be clusterd.", optional: false, default: null},
                {name: "numberOfClusters", help: "numberOfClusters that will be generated. Default; Math.sqrt(numberOfPoints/2)", 
                 optional: true, default: null},
                {name: "ResultType", help: 'Either; cluster|centroid|point|all. "cluster" will return the cluster id, "centroid" will return the '+
                       'cluster centroid Point geometry, "point" will return the geometry and "all" will return a list of all of these values.', 
                       optional: true, default: "cluster"}],
   func: customClusterKmeans
 },
{ id: 1550,
   library: "Misc",
   name: "TIN",
   type: "custom",
   help: "Internally calls Turf.tin.  Takes a set (table) of points and creates a Triangulated Irregular Network, "+
         "or a TIN for short, returned as a table of Polygons."+
         " These are often used for developing elevation contour maps or stepped heat visualizations. "+
         " Note that the SRC_ROWID output result will not be populated.  The RESULT field will be populated "+
         " with the output Polygon and the GROUPING_RESULT field will be populated with a 3 value comma separated "+
         ' list representing the Tin "a","b","c" values (the values of each point in the triangle) - this will '+
         " only be populated if the z Value field is passed in.",
   parameters: [{name: "Point", help: "The input WKT Point Geometry", optional: false, default: null},
                {name: "z-Value", help: "This is optional: if not given, then there will be no extra data added to the derived triangles.", 
                 optional: false, default: null}],
    func: customTIN
 },
 { id: 1560,
   library: "Misc",
   name: "Interpolate",
   type: "custom",
   help: "Internally calls Turf.interpolate.  Takes a set (table) of points and estimates their 'property' values"+
         " on a grid using the Inverse Distance Weighting (IDW) method.  The SRC_ROWID will not be populated. "+
         " The RESULT field will be populated with the generated grid Geometry and the GROUPING_RESULT will be "+
         " populated with the interpolated value.",
   parameters: [{name: "Point", help: "The input WKT Point Geometry", optional: false, default: null},
               {name: "cellSize", help: "The distance across each grid point", optional: false, default: null},
               {name: "gridType", help: "defines the output format based on a Grid Type (options: square|point|hex|triangle)",
                optional: true, default: 'point'},
               {name: "property", help: "the property (value) name in", optional: false, default: null},
               {name: "Units", help: "used in calculating cellSize, can be degrees, radians, miles, or kilometers", optional: false, default: "kilometers"},
               {name: "Weight", help: "exponent regulating the distance-decay weighting", optional: true, default: "1"}],
    func: customInterpolate
 },
 { id: 1570,
   library: "Misc",
   name: "ISO",
   type: "custom",
   help: "Internally calls Turf.isolines or Turf.isobands.  Takes a set (table) grid of Points with z-values and a list "+
         " of numeric break values and will generate either filled isobands or isolines.  Note that the input set of points "+
         ' must be uniformly spaced as in a point grid.  For non-uniformly spaced points - please use the "Misc:Interpolate" '+
         " function output to generate a point grid to pass to this function.  The RESULT field will be populated with the isoband "+
         " or isoline geometry"+
         " and the GROUPING_RESULT field will be populated with the break value.  The breaks parameter is evaluated upon initial "+
         " invocation.",
  parameters: [{name: "Point", help: "The input WKT Point Geometry that makes up a Point Grid", optional: false, default: null},
               {name: "z-Value", help: "Numeric z-Values.", optional: false, default: null},
               {name: "Breaks list", help: "A delimited list of numeric values where to draw isolines/bands"},
               {name: "Breaks Separator", help: "Character separating the breaks list element values", optional: false, default: ","},
               {name: "Breaks Delimiter", help: "Optional Parameter. Delimiter character enclosing each breaks values", optional: true, default: '"'},
               {name: "ISO type", help: 'Optional Parameter. Either isolines|isobands. "isolines" will produce Linestring geometries '+
                      'whereas "isobands" will produce Polygon geometries.', optional: true, default: "isolines"}],

    func: customISO
 },

{ id: 1580,
   library: "Misc",
   name: "voronoi",
   type: "custom",
   help: "Takes a set (table) of Point and returns a table of Voronoi polygons.",
   parameters: [{name: "Point", help: "To find the Voronoi polygon around point.", optional: false, default: null}],
   func: customVoronoi
 },
 { id: 1700,
   library: "Turf",
   name: "along",
   type: "immutable",
   help: "Takes a LineString and returns a Point at a specified distance along the line.",
   parameters: [{name: "Line", help: "input line", optional: false, default: null},
                {name: "Distance", help: "distance along the line", optional: false, default: null},
                {name: "Units", help: "Optional parameter. Can be degrees, radians, miles, or kilometers. Default: kilometers", optional: true, default: "kilometers"}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var opts = {};
           if (params[2])
            opts["units"]=params[2];
           var result = turf.along(gj, params[1], opts);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1710,
  library: "Turf",
   name: "area",
   type: "immutable",
   help: "Takes a Geometry(ies) and returns their area in square meters.",
   parameters: [{name: "Geometry", help: "input Geometry", optional: false, default: null}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var result = turf.area(gj);         
           return result;
          }
 },
{ id: 1720,
   library: "Turf",
   name: "bboxPolygon",
   type: "immutable",
   help: "Takes a Geometry and calculates the bbox of all input Geometries and returns a bounding box.",
   parameters: [{name: "Geometry", help: "any Geometry object", optional: false, default: null}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var result = turf.bboxPolygon(turf.bbox(gj));
           var WKT = geojson2wkt(result);         
           return WKT;
          }
 },
 { id: 1730,
   library: "Turf",
   name: "bearing",
   type: "immutable",
   help: "Takes two Points and finds the geographic bearing between them, i.e. the angle measured in degrees from the north line (0 degrees)",
   parameters: [{name: "Start", help: "starting Point", optional: false, default: null},
                {name: "End", help: "ending Point", optional: false, default: null},
                {name: "Final", help: "calculates the final bearing if true", optional: true, default: "false"}],
   func: function(params) {
           var start = wkt2geojson(params[0]);
           var end = wkt2geojson(params[1]);
           var final = false;
           var opts = {}
           if (params[2])
            opts["final"]=(params[2].toLowerCase() == 'true'); 
           var result = turf.bearing(start, end, opts);         
           return result;
          }
 },
 { id: 1740,
   library: "Turf",
   name: "center",
   type: "immutable",
   help: "Takes a Geometry and returns the absolute center point of all component geometries.",
   parameters: [{name: "Geometry", help: "Geometry to be centered", optional: false, default: null}],
   func: function(params) {
           var feat = wkt2geojson(params[0]);
           var result = turf.center(feat);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
 { id: 1750,
   library: "Turf",
   name: "centerOfMass",
   type: "immutable",
   help: "Takes any Geometry and returns its center of mass using this formula: Centroid of Polygon.",
   parameters: [{name: "Geometry", help: "Geometry to be centered", optional: false, default: null}],
   func: function(params) {
           var feat = wkt2geojson(params[0]);
           var result = turf.centerOfMass(feat);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
 { id: 1760,
   library: "Turf",
   name: "centroid",
   type: "immutable",
   help: "Takes a Geometry and calculates the centroid using the mean of all vertices. This lessens the effect of small islands and artefacts when calculating the centroid of a set of polygons.",
   parameters: [{name: "Geometry", help: "Geometry to be centered", optional: false, default: null}],
   func: function(params) {
           var feat = wkt2geojson(params[0]);
           var result = turf.centroid(feat);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1770,
   library: "Turf",
   name: "destination",
   type: "immutable",
   help: "Takes a Point and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the Haversine formula to account for global curvature.",
   parameters: [{name: "Origin", help: "starting Point", optional: false, default: null},
                {name: "Distance", help: "distance from the origin point", optional: false, default: null},
                {name: "Bearing", help: "ranging from -180 to 180", optional: true, default: null},
                {name: "Units", help: "Optional Parameter. miles, kilometers, degrees, or radians", optional: true, default: "kilometers"}],
   func: function(params) {
           var origin = wkt2geojson(params[0]);
           var opts = {};
           if (params[3])
            opts["units"]=params[3];
           var result = turf.destination(origin, params[1], params[2], opts);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1780,
  library: "Turf",
   name: "distance",
   type: "immutable",
   help: "Calculates the distance between two Points in degrees, radians, miles, or kilometers. This uses the Haversine formula to account for global curvature.",
   parameters: [{name: "From", help: "origin Point", optional: false, default: null},
                {name: "To", help: "destination Point", optional: false, default: null},
                {name: "Units", help: "Optional parameter. can be degrees, radians, miles, or kilometers", optional: true, default: "kilometers"}],
   func: function(params) {
           var from = wkt2geojson(params[0]);
           var to = wkt2geojson(params[1]);
           var opts = {};
           if (params[2])
            opts["units"]=params[2];
           var result = turf.distance(from, to, opts);         
           return result;
          }
 },
 { id: 1790,
   library: "Turf",
   name: "envelope",
   type: "immutable",
   help: "Takes a Geometry and returns a rectangular Polygon that encompasses all vertices.",
   parameters: [{name: "Geometry", help: "input geometry", optional: false, default: null}],
   func: function(params) {
           var feat = wkt2geojson(params[0]);
           var result = turf.envelope(feat);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1800,
   library: "Turf",
   name: "length",
   type: "immutable",
   help: "Takes a Geometry and measures its length in the specified units, (Multi)Point 's distance are ignored.",
   parameters: [{name: "Geometry", help: "Geometry to measure", optional: false, default: null},
                {name: "Units", help: "Optional parameter. can be degrees, radians, miles, or kilometers", optional: true, default: "kilometers"}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
            var opts = {};
           if (params[1])
            opts["units"]=params[1];
           var result = turf.length(gj, opts);         
           return result;
          }
 },
{ id: 1810,
   library: "Turf",
   name: "midpoint",
   type: "immutable",
   help: "Takes two Points and returns a point midway between them. The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.",
   parameters: [{name: "Point1", help: "first point", optional: false, default: null},
                {name: "Point2", help: "second point", optional: false, default: null}],
   func: function(params) {
           var point1 = wkt2geojson(params[0]);
           var point2 = wkt2geojson(params[1]);
           var result = turf.midpoint(point1, point2); 
           var WKT = geojson2wkt(result);        
           return WKT;
          }
 },
{ id: 1820,
   library: "Turf",
   name: "pointOnGeometry",
   type: "immutable",
   help: "Takes a Geometry and returns a Point guaranteed to be on the surface of the Geometry.",
   parameters: [{name: "Geometry", help: "any Geometry including GeometryCollection", optional: false, default: null}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var result = turf.pointOnFeature(gj); 
           var WKT= geojson2wkt(result);        
           return WKT;
          }
 },
{ id: 1830,
   library: "Turf",
   name: "pointToLineDistance",
   type: "immutable",
   help: "Returns the minimum distance between a Point and a LineString , being the distance from a line the minimum distance between the point and any segment of the LineString.",
   parameters: [{name: "Pt", help: "Point Geometry", optional: false, default: null},
                {name: "Line", help: "Line Geometry", optional: false, default: null},
                {name: "Units", help: "Optional Parameter.  Can be degrees, radians, miles, or kilometers", optional: true, default: "kilometers"},      
                {name: "Mercator", help: "Optional parameter. if distance should be on Mercator or WGS84 projection", optional: true, default: "false"}],
   func: function(params) {
           var pt = wkt2geojson(params[0]);
           var line = wkt2geojson(params[1]);
           var opts={};
           if (params[2])
            opts["units"]= params[2];
           if (params[3])
            opts["mercator"]= (params[3].toLowerCase() == 'true');
           var result = turf.pointToLineDistance(pt, line, opts);        
           return result;
          }
 },
{ id: 1840,
   library: "Turf",
   name: "rhumbBearing",
   type: "immutable",
   help: "Takes two Points and finds the bearing angle between them along a Rhumb line i.e. the angle measured in degrees start the north line (0 degrees).",
   parameters: [{name: "Start", help: "starting Point", optional: false, default: null},
                {name: "End", help: "ending Point", optional: false, default: null},
                {name: "Final", help: "Optional Parameter.  calculates the final bearing if true", optional: true, default: "false"}],
   func: function(params) {
           var start = wkt2geojson(params[0]);
           var end = wkt2geojson(params[1]);
           var opts={};
           if (params[2])
            opts["final"]= (params[2].toLowerCase() == 'true');
           var result = turf.rhumbBearing(start, end, opts);        
           return result;
          }
 },
{ id: 1850,
   library: "Turf",
   name: "rhumbDestination",
   type: "immutable",
   help: "Returns the destination Point having travelled the given distance along a Rhumb line from the origin Point with the (varant) given bearing.",
   parameters: [{name: "Origin", help: "starting Point", optional: false, default: null},
                {name: "Distance", help: "distance from the starting Point", optional: false, default: null},
                {name: "Bearing", help: "varant bearing angle ranging from -180 to 180 degrees from north", optional: false, default: null},
                {name: "Units", help: "Optional Parameter.  can be degrees, radians, miles, or kilometers", optional: true, default: "kilometers"}],
   func: function(params) {
           var origin = wkt2geojson(params[0]);
           var opts={};
           if (params[3])
            opts["final"]= params[3];
           var result = turf.rhumbDestination(origin, params[1], params[2], opts);        
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1860,
   library: "Turf",
   name: "rhumbDistance",
   type: "immutable",
   help: "Calculates the distance along a rhumb line between two Points in degrees, radians, miles, or kilometers.",
   parameters: [{name: "From", help: "origin Point", optional: false, default: null},
                {name: "To", help: "destination Point", optional: false, default: null},
                {name: "Units", help: "Optional Parameter.  can be degrees, radians, miles, or kilometers", optional: true, default: "kilometers"}],
   func: function(params) {
           var from = wkt2geojson(params[0]);
           var to = wkt2geojson(params[1]);
           var opts={};
           if (params[2])
            opts["units"]= params[2];
           var result = turf.rhumbDistance(from, to, opts);        
           return result;
          }
 },
{ id: 1870,
   library: "Turf",
   name: "greatCircle",
   type: "immutable",
   help: "Calculate great circles routes as LineString",
   parameters: [{name: "Start", help: "source Point geometry", optional: false, default: null},
                {name: "End", help: "destination Point geometry", optional: false, default: null},
                {name: "Npoints", help: "Optional Parameter.  Number of Points", optional: true, default: "100"},
                {name: "Offset", help: "Optional Parameter.  Offset controls the likelyhood that lines will be split which cross the dateline. The higher the number the more likely.", optional: true, default: "10"}],
   func: function(params) {
           var start = wkt2geojson(params[0]);
           var end = wkt2geojson(params[1]);
           var opts={};
           if (params[2])
            opts["npoints"]= params[2];
           if (params[3])
            opts["offset"]= params[3];
           var result = turf.greatCircle(start, end, opts);        
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1880,
   library: "Turf",
   name: "cleanCoords",
   type: "immutable",
   help: "Removes redundant coordinates from any Geometry.",
   parameters: [{name: "Geometry", help: "Geometry", optional: false, default: null}],
  func: function(params) {
           var geojson = wkt2geojson(params[0]);
           var result = turf.cleanCoords(geojson, {mutate: true});        
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1890,
   library: "Turf",
   name: "flip",
   type: "immutable",
   help: "Takes input Geometry and flips its coordinates from [x, y] to [y, x].",
   parameters: [{name: "Geometry", help: "input Geometry", optional: false, default: null}],
  func: function(params) {
           var geojson = wkt2geojson(params[0]);
           var result = turf.flip(geojson, {mutate: true});        
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1900,
   library: "Turf",
   name: "rewind",
   type: "immutable",
   help: "Rewind (Multi)LineString or (Multi)Polygon outer ring counterclockwise and inner rings clockwise (Uses Shoelace Formula ).",
   parameters: [{name: "Geometry", help: "input Geometry Polygon", optional: false, default: null},
                {name: "Reverse", help: "enable reverse winding", optional: false, default: "false"}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var opts={};
           if (params[2])
            opts["reverse"]= (params[2].toLowerCase() == 'true');
           var result = turf.rewind(gj, opts);
           var WKT= geojson2wkt(result);        
           return WKT;
          }
 },
{ id: 1910,
   library: "Turf",
   name: "truncate",
   type: "immutable",
   help: "Takes a Geometry or GeometryCollection and truncates the precision of the geometry.",
   parameters: [{name: "Geometry", help: "any Geometry or GeometryCollection.", optional: false, default: null},
                {name: "Precision", help: "Coordinate decimal precision", optional: true, default: "6"},
                {name: "Coordinates", help: "Maximum number of coordinates (primarily used to remove z coordinates)", optional: true, default: "3"}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var opts={};
           if (params[1])
            opts["precision"]= parseInt(params[1]);
           if (params[2])
            opts["coordinates"]= parseInt(params[2]);
           opts["mutate"]= true;
           var result = turf.truncate(gj, opts);
           var WKT= geojson2wkt(result);        
           return WKT;
          }
 },
{ id: 1920,
   library: "Turf",
   name: "bezierSpline",
   type: "immutable",
   help: "Takes a Line and returns a curved version by applying a Bezier spline algorithm.",
   parameters: [{name: "Line", help: "input LineString", optional: false, default: null},
                {name: "Resolution", help: "Optional Parameter. time in milliseconds between points", optional: false, default: "10000"},
                {name: "Sharpness", help: "Optional Parameter. a measure of how curvy the path should be between splines", optional: false, default: "0.85"}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var opts={};
           if (params[1])
            opts["resolution"]= parseFloat(params[1]);
           if (params[2])
            opts["sharpness"]= parseFloat(params[2]);
           var result = turf.bezierSpline(gj, opts);
           var WKT= geojson2wkt(result);        
           return WKT;
          }
 },
 { id: 1930,
   library: "Turf",
   name: "buffer",
   type: "immutable",
   help: "Calculates a buffer for input Geometry for a given radius. Units supported are miles, kilometers, and degrees.",
   parameters: [{name: "Geometry", help: "input to be buffered", optional: false, default: null},
                {name: "Radius", help: "distance to draw the buffer (negative values are allowed)", optional: false, default: null},
                {name: "Units", help: "Optional parameter. Any of the options supported by turf units. Default: kilometers", optional: true, default: "kilometers"},
                {name: "Steps", help: "Optional parameter. Number of Steps. Default: 64", optional: true, default: null}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var opts = {};
           if (params[2])
            opts["units"]=params[2];
           if (params[3])
            opts["steps"]=parseInt(params[3]);
           var result = turf.buffer(gj, params[1], opts);       
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
 { id: 1940,
   library: "Turf",
   name: "circle",
   type: "immutable",
   help: "Takes a Point and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.",
   parameters: [{name: "Center", help: "Center Point", optional: false, default: null},
                {name: "Radius", help: "radius of the circle", optional: false, default: null},
                {name: "Units", help: "Optional parameter. Any of the options supported by turf units. Default: kilometers", optional: true, default: "kilometers"},
                {name: "Steps", help: "Optional paramter. Number of Steps. Default: 64", optional: true, default: null}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var opts = {};
           if (params[2])
            opts["units"]=params[2];
           if (params[3])
            opts["steps"]=parseInt(params[3]);
           var result = turf.circle(gj, params[1], opts);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 1950,
   library: "Turf",
   name: "concave",
   type: "immutable",
   help: "Takes a set of points and returns a concave hull Polygon or MultiPolygon. Internally, this uses turf-tin to generate geometries.",
   parameters: [{name: "Points", help: "a list of input points", optional: false, default: null},
                {name: "Separator", help: "character separating WKT points in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'},
                {name: "maxEdge", help: "Optional paramter. the length (in 'units') of an edge necessary for part of "+
			                 "the hull to become concave.", optional: true, default: null},
                {name: "Units", help: "Optional parameter. Any of the options supported by turf units. Default: kilometers", 
			               optional: true, default: "kilometers"}],
   func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          opts={};
          if (params[3])
           opts["maxEdge"]=parseInt(params[3]);
          if (params[4])
           opts["units"]=params[4];
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var feature_array = wkt_array.map(function(wkt) { return toFeature(wkt2geojson(wkt)); } );
          var feature_collection = turf.featureCollection(feature_array);
          var result = turf.concave(feature_collection, opts);         
          var WKT = geojson2wkt(result);
          return WKT;
          }
 },
 { id: 1960,
   library: "Turf",
   name: "convex",
   type: "immutable",
   help: "Takes a Geometry or GeometryCollection and returns a convex hull Polygon.",
   parameters: [{name: "Geometry", help: "input Geometry or GeometryCollection", optional: false, default: null},
                {name: "Concavity", help: "Optional parameter. 1 - thin shape. Infinity - convex hull.", optional: true, default: null}],
   func: function(params) {
           var gj = wkt2geojson(params[0]);
           var opts = {};
           if (params[1])
            opts["concavity"]=parseInt(params[1]);
           var result = turf.convex(gj, opts);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
 { id: 1970,
   library: "Turf",
   name: "difference",
   type: "immutable",
   help: "Finds the difference between two polygons by clipping the second polygon from the first.",
   parameters: [{name: "Polygon1", help: "input Polygon", optional: false, default: null},
                {name: "Polygon2", help: "Polygon to difference from polygon1", optional: false, default: null}],
   func: function(params) {
           var polygon1 = wkt2geojson(params[0]);
           var polygon2 = wkt2geojson(params[1]);
           var result= turf.difference(polygon1, polygon2);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
 // dissolve not implemented
 { id: 1990,
   library: "Turf",
   name: "intersect",
   type: "immutable",
   help: "Takes two Polygons and finds their intersection. If they share a border, returns the border; if they don't intersect, returns undefined.",
   parameters: [{name: "Poly1", help: "the first Polygon", optional: false, default: null},
                {name: "Poly2", help: "the second Polygon", optional: false, default: null}],
    func: function(params) {
           var poly1= wkt2geojson(params[0]);
           var poly2= wkt2geojson(params[1]);
           var result= turf.intersect(poly1, poly2);         
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2000,
   library: "Turf",
   name: "lineOffset",
   type: "immutable",
   help: "Takes a Line and returns a line at offset by the specified distance.",
   parameters: [{name: "Geometry", help: "input Geometry", optional: false, default: null},
                {name: "Distance", help: "distance to offset the line (can be of negative value)", optional: false, default: null},
                {name: "Units", help: "Optional parameter: can be degrees, radians, miles, kilometers, inches, yards, meters", optional: true, default: "kilometers"}],
    func: function(params) {
           var gj= wkt2geojson(params[0]);
           var dist= parseFloat(params[1]);
           var opts={};
           if (params[2])
            opts["units"]= params[2];     
           var result= turf.lineOffset(gj,dist,opts);
           var WKT = geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2010,
  library: "Turf",
   name: "simplify",
   type: "immutable",
   help: "Takes a Geometry object and returns a simplified version. Internally uses simplify-js to perform simplification using the Ramer-Douglas-Peucker algorithm.",
   parameters: [{name: "Geometry", help: "object to be simplified", optional: false, default: null},
                {name: "Tolerance", help: "simplification tolerance", optional: true, default: "1"},
                {name: "highQuality", help: "whether or not to spend more time to create a higher-quality simplification with a different algorithm", optional: true, default: "false"}],
    func: function(params) {
           var gj= wkt2geojson(params[0]);
           var opts={};
           if (params[1])
            opts["tolerance"]= parseFloat(params[1]);
           if (params[2])
            opts["units"]= params[2];
           opts["mutate"]=true;
           var result= turf.simplify(gj,opts);
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2020,
  library: "Turf",
   name: "tesselelate",
   type: "immutable",
   help: "Tesselates a Geometry into a GeometryCollection of triangles using earcut.",
   parameters: [{name: "Poly", help: "the polygon to tesselate", optional: false, default: 1}],
   func: function(params) {
           var gj= wkt2geojson(params[0]);
	   var feat=toFeature(gj);
           var result= turf.tesselate(feat);
           var geomCollection = convertFCtoGC(result);
           var WKT= geojson2wkt(geomCollection);
           return WKT;
          }
 },
{ id: 2030,
   library: "Turf",
   name: "transformRotate",
   type: "immutable",
   help: "Rotates any Geometry of a specified angle, around its centroid or a given pivot point; all rotations follow the right-hand rule: https://en.wikipedia.org/wiki/Right-hand_rule",
   parameters: [{name: "Geometry", help: "object to be rotated", optional: false, default: null},
                {name: "Angle", help: "of rotation (along the vertical axis), from North in decimal degrees, negative clockwise", optional: false, default: 1},
                {name: "Pivot", help: "point around which the rotation will be performed", optional: true, default: "centroid"}],
    func: function(params) {
           var gj= wkt2geojson(params[0]);
           var angle= parseFloat(params[1]);
           var opts={};
           if (params[2])
            opts["pivot"]= wkt2geojson(params[2]);
           var result= turf.transformRotate(gj,angle,opts);
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2040,
  library: "Turf",
   name: "transformTranslate",
   type: "immutable",
   help: "Moves any Geometry of a specified distance along a Rhumb Line on the provided direction angle.",
   parameters: [{name: "Geometry", help: "object to be translated", optional: false, default: null},
                {name: "Distance", help: "length of the motion; negative values determine motion in opposite direction", optional: false, default: null},
                {name: "Direction", help: "of the motion; angle from North in decimal degrees, positive clockwise", optional: false, default: null},
                {name: "Units", help: "in which", optional: true, default: "kilometers"},
                {name: "zTranslation", help: "length of the vertical motion, same unit of distance", optional: true, default: "0"}],
    func: function(params) {
           var gj= wkt2geojson(params[0]);
           var distance= parseFloat(params[1]);
           var direction= parseFloat(params[2]);
           var opts={};
           if (params[3])
            opts["units"]= params[3];
           if (params[4])
            opts["zTranslation"]= parseFloat(params[4]);
           opts["mutate"]=true;
           var result= turf.transformTranslate(gj,distance,direction,opts);
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2050,
   library: "Turf",
   name: "transformScale",
   type: "immutable",
   help: "Moves any Geometry of a specified distance along a Rhumb Line on the provided direction angle.",
   parameters: [{name: "Geometry", help: "object to be scaled", optional: false, default: null},
                {name: "Factor", help: "of scaling, positive or negative values greater than 0", optional: false, default: null},
                {name: "Origin", help: "Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)", optional: true, default: "centroid"}],
    func: function(params) {
           var gj= wkt2geojson(params[0]);
           var factor= parseFloat(params[1]);
           var opts={};
           if (params[2])
            opts["origin"]= wkt2geojson(params[2]);
           opts["mutate"]=true;
           var result= turf.transformScale(gj,factor,opts);
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2060,
   library: "Turf",
   name: "union",
   type: "immutable",
   help: "Takes two or more polygons and returns a combined polygon. If the input polygons are not contiguous, this function returns a MultiPolygon feature.",
   parameters: [{name: "Geometry List", help: "list of polygon(s) to combine", optional: false, default: null},
                {name: "Separator", help: "character separating WKT polygons in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'}],
    func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var feature_array = wkt_array.map(function(wkt) { return toFeature(wkt2geojson(wkt)); });
          var result = turf.union.apply(this, feature_array);
          var WKT = geojson2wkt(result);
          return WKT;
          }
 },
{ id: 2070,
   library: "Turf",
   name: "voronoi",
   type: "immutable",
   help: "Takes a list of Point and returns a GeometryCollection of Voronoi polygons.",
   parameters: [{name: "Point List", help: "to find the Voronoi polygons around list of point(s).", optional: false, default: null},
                {name: "Separator", help: "character separating WKT polygons in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'},
                {name: "bboxPolygon", help: "clipping rectangle, in (WKT)", optional: true, default: null}],
    func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          opts={};
          if (params[3])
           opts["bbox"]= wkt2geojson(params[3]);
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var feature_array = wkt_array.map(function(wkt) { return toFeature(wkt2geojson(wkt)); } );
          var feature_collection = turf.featureCollection(feature_array);
          var result= turf.voronoi(feature_collection);
          var geomCollection = convertFCtoGC(result);
          var WKT = geojson2wkt(geomCollection);
          return WKT;
          }
 },
{ id: 2080,
   library: "Turf",
   name: "combine",
   type: "immutable",
   help: "Combines a list of Point, LineString, or Polygon Geometries into MultiPoint , MultiLineString , or MultiPolygon geometries",
   parameters: [{name: "Geometry List", help: "a list of either, Point, LineString or Polygon", optional: false, default: null},
                {name: "Separator", help: "character separating WKT geometries in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'}],
    func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          opts={};
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var feature_array = wkt_array.map(function(wkt) { return toFeature(wkt2geojson(wkt)); } );
          var feature_collection = turf.featureCollection(feature_array);
          var result= turf.combine(feature_collection);
          var geomCollection = convertFCtoGC(result);
          var WKT = geojson2wkt(geomCollection);
          return WKT;
          }
 },
 { id: 2090,
   library: "Turf",
   name: "explode",
   type: "immutable",
   help: "Takes a Geometry or GeometryCollection and returns all positions as points.",
   parameters: [{name: "Geometry", help: "Input Geometry", optional: false, default: null}],
    func: function(params) {
          var gj= wkt2geojson(params[0]);
          var result = turf.explode(gj);
          var geomCollection = convertFCtoGC(result);
          var WKT = geojson2wkt(geomCollection);
          return WKT;
          }
 },
 { id: 2100,
   library: "Turf",
   name: "flatten",
   type: "immutable",
   help: "Flattens any Geometry to a GeometryCollection inspired by geojson-flatten.",
   parameters: [{name: "Geometry", help: "Any valid Geometry", optional: false, default: null}],
    func: function(params) {
          var gj= wkt2geojson(params[0]);
          var result = turf.flatten(gj);
          var geomCollection = convertFCtoGC(result);
          var WKT = geojson2wkt(geomCollection);
          return WKT;
          }
 },
{ id: 2110,
   library: "Turf",
   name: "lineToPolygon",
   type: "immutable",
   help: "Converts (Multi)LineString(s) to Polygon(s).",
   parameters: [{name: "Line", help: "a LineString or MultiLineString", optional: false, default: null},
                {name: "autoComplete", help: "auto complete linestrings (matches first & last coordinates)", optional: true, default: "true"},
                {name: "orderCoords", help: "sorts linestrings to place outer ring at the first position of the coordinates", optional: true, default: "true"}],
    func: function(params) {
          opts={};
          if (params[1])
           opts["autoComplete"] = (params[1].toLowerCase() == 'true');
          if (params[2])
           opts["orderCoords"] = (params[2].toLowerCase() == 'true');
          var gj= wkt2geojson(params[0]);
          var result= turf.lineToPolygon(gj, opts);
          var WKT = geojson2wkt(result);
          return WKT;
          }
 },
{ id: 2120,
   library: "Turf",
   name: "polygonize",
   type: "immutable",
   help: "Polygonizes a list of (Multi)LineString(s) into Polygons.",
   parameters: [{name: "LineString List", help: "Lines in order to polygonize", optional: false, default: null},
                {name: "Separator", help: "character separating WKT geometries in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'}],
    func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          opts={};
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var feature_array = wkt_array.map(function(wkt) { return toFeature(wkt2geojson(wkt)); } );
          var feature_collection = turf.featureCollection(feature_array);
          var result= turf.polygonize(feature_collection);
          var geomCollection = convertFCtoGC(result);
          var WKT = geojson2wkt(geomCollection);
          return WKT;
          }
 },
{ id: 2130,
   library: "Turf",
   name: "polygonToLine",
   type: "immutable",
   help: "Converts a Polygon to (Multi)LineString or MultiPolygon to a GeometryCollection of (Multi)LineString.",
   parameters: [{name: "Polygon", help: "geometry to convert", optional: false, default: null}],
    func: function(params) {
          var gj= wkt2geojson(params[0]);
          var result= turf.polygonToLine(gj);
          if (result.geometry)
           return geojson2wkt(result);
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
          }
 },
{ id: 2140,
  library: "Turf",
   name: "kinks",
   type: "immutable",
   help: "Takes a Linestring, MultiLinestring, Polygon, or MultiPolygon and returns points at all self-intersections.",
   parameters: [{name: "Geometry", help: "input geometry", optional: false, default: null}],
    func: function(params) {
          var gj= wkt2geojson(params[0]);
          var result= turf.kinks(toFeature(gj));
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
          }
 },
{ id: 2150,
   library: "Turf",
   name: "lineArc",
   type: "immutable",
   help: "Creates a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.",
   parameters: [{name: "Center", help: "Center Point", optional: false, default: null},
                {name: "Radius", help: "radius of the circle", optional: false, default: null},
                {name: "Bearing1", help: "angle, in decimal degrees, of the first radius of the arc", optional: false, default: null},
                {name: "Bearing2", help: "angle, in decimal degrees, of the second radius of the arc", optional: false, default: null},
                {name: "Steps", help: "number of steps", optional: false, default: "64"},
                //TODO units default kilometers seems buggy in Turf.js
	        {name: "Units", help: "miles, kilometers, degrees, or radians", optional: true, default: null}
              ],
    func: function(params) {
          var gj= wkt2geojson(params[0]);
          var radius= parseFloat(params[1]);
          var bearing1 = parseFloat(params[2]);
          var bearing2= parseFloat(params[3]);
          var opts={};
          if (params[4])
           opts["steps"]= parseInt(params[4]);
          if (params[5])
           opts["units"]= params[5];
          var result= turf.lineArc(gj, radius, bearing1, bearing2, opts);
          var WKT = geojson2wkt(result);
          return WKT;
         }
 },
{ id: 2160,
  library: "Turf",
   name: "lineChunk",
   type: "immutable",
   help: "Divides a LineString into chunks of a specified length. If the line is shorter than the segment length then the original line is returned.",
   parameters: [{name: "Geometry", help: "Line(s) to split", optional: false, default: null},
                {name: "segmentLength", help: "How long to make each segment", optional: false, default: null},
                {name: "Units", help: "miles, kilometers, degrees, or radians", optional: false, default: 'kilometers'},
                {name: "Reverse", help: "reverses coordinates to start the first chunked segment at the end", optional: false, default: 'false'}],
    func: function(params) {
          var gj= wkt2geojson(params[0]);
          var segmentLength = parseFloat(params[1]);
          var opts={};
          if (params[2])
           opts["units"]= params[2];
          if (params[3])
           opts["reverse"]= (params[3].toLowerCase() == 'true');
          var result= turf.lineChunk(gj, segmentLength, opts);
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
         }
 },
{ id: 2170,
   library: "Turf",
   name: "lineIntersect",
   type: "immutable",
   help: "Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).",
   parameters: [{name: "line1", help: "Any LineString or Polygon", optional: false, default: null},
                {name: "line2", help: "Any LineString or Polygon", optional: false, default: null}],
    func: function(params) {
          var line1 = wkt2geojson(params[0]);
          var line2 = wkt2geojson(params[1]);
          var result = turf.lineIntersect(line1, line2);
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
         }
 },
{ id: 2180,
   library: "Turf",
   name: "lineOverlap",
   type: "immutable",
   help: "Takes any LineString or Polygon and returns the overlapping lines between both geometries.",
   parameters: [{name: "Line1", help: "Any LineString or Polygon", optional: false, default: null},
                {name: "Line2", help: "Any LineString or Polygon", optional: false, default: null},
                {name: "tolerance", help: "Tolerance distance to match overlapping line segments (in kilometers)", optional: false, default: '0'}],
    func: function(params) {
          var line1 = wkt2geojson(params[0]);
          var line2 = wkt2geojson(params[1]);
          var opts={};
          if (params[2])
           opts["tolerance"]= parseFloat(params[3]);
          var result = turf.lineOverlap(line1, line2, opts);
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
         }
 },
{ id: 2190,
   library: "Turf",
   name: "lineSegment",
   type: "immutable",
   help: "Creates a GeometryCollection of 2-vertex LineString segments from a (Multi)LineString or (Multi)Polygon.",
   parameters: [{name: "Geometry", help: "Polygon or LineString", optional: false, default: null}],
    func: function(params) {
          var gj = wkt2geojson(params[0]);
          var result = turf.lineSegment(gj);
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
         }
 },
{ id: 2200,
   library: "Turf",
   name: "lineSlice",
   type: "immutable",
   help: "Takes a line , a start Point , and a stop point and returns a subsection of the line in-between those points. The start & stop points don't need to fall exactly on the line.",
   parameters: [{name: "startPt", help: "Starting Point", optional: false, default: null},
                {name: "stopPt", help: "Stopping Point", optional: false, default: null},
                {name: "Line", help: "Line to Slice", optional: false, default: null}],
    func: function(params) {
          var startPt = wkt2geojson(params[0]);
          var stopPt = wkt2geojson(params[1]);
          var line = wkt2geojson(params[2]);
          var result = turf.lineSlice(startPt, stopPt, line);
          return geojson2wkt(result);
         }
 },
{ id: 2210,
  library: "Turf",
   name: "lineSliceAlong",
   type: "immutable", 
   help: "Takes a line , a specified distance along the line to a start Point , and a specified distance along the line to a stop point and returns a subsection of the line in-between those points.",
   parameters: [{name: "Line", help: "Input Line", optional: false, default: null},
                {name: "startDist", help: "Distance along the line to starting point", optional: false, default: null},
                {name: "stopDist", help: "Distance along the line to ending point", optional: false, default: null},
                {name: "Units", help: "Can be degrees, radians, miles, or kilometers", optional: false, default: 'kilometers'}],
    func: function(params) {
          var line = wkt2geojson(params[0]);
          var startDist = parseFloat(params[1]);
          var stopDist = parseFloat(params[2]);
          var opts={};
          if (params[3])
           opts["units"]= params[3];
          var result = turf.lineSliceAlong(line, startDist, stopDist, opts);
          return geojson2wkt(result);
         }
 },
{ id: 2220,
   library: "Turf",
   name: "lineSplit",
   type: "immutable",
   help: "Split a LineString by another Geometry",
   parameters: [{name: "Line", help: "LineString to split", optional: false, default: null},
                {name: "Splitter", help: "Geometry used to split line", optional: false, default: null}],
    func: function(params) {
          var line = wkt2geojson(params[0]);
          var splitter = wkt2geojson(params[1]);
          var result = turf.lineSplit(toFeature(line), toFeature(splitter));
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
         }
 },
{ id: 2230,
   library: "Turf",
   name: "mask",
   type: "immutable",
   help: "Takes any type of polygon and an optional mask and returns a polygon exterior ring with holes.",
   parameters: [{name: "Polygon", help: "Polygon used as interior rings or holes.", optional: false, default: null},
                {name: "Mask", help: "Polygon used as the exterior ring (if undefined, the world extent is used)", optional: false, default: null}],
    func: function(params) {
          var polygon = wkt2geojson(params[0]);
          var mask = wkt2geojson(params[1]);
          var result = turf.mask(toFeature(polygon), toFeature(mask));
          return geojson2wkt(result);
         }
 },
{ id: 2240,
   library: "Turf",
   name: "nearestPointOnLine",
   type: "immutable",
   help: "Takes a Point and a LineString and calculates the closest Point on the (Multi)LineString.",
   parameters: [{name: "Lines", help: "Lines to snap to", optional: false, default: null},
                {name: "Point", help: "Point to snap from", optional: false, default: null},
                {name: "Units", help: "miles, kilometers, degrees, or radians", optional: false, default: 'kilometers'}],
   func: function(params) {
          var lines = wkt2geojson(params[0]);
          var point = wkt2geojson(params[1]);
          var opts={};
          if (params[2])
           opts["units"]= params[2];
          var result = turf.nearestPointOnLine(lines, point, opts);
          return geojson2wkt(result);
         }
 },
{ id: 2250,
   library: "Turf",
   name: "sector",
   type: "immutable",
   help: "Creates a circular sector of a circle of given radius and center Point , between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.",
   parameters: [{name: "Center", help: "Center Point", optional: false, default: null},
                {name: "Radius", help: "radius of the circle", optional: false, default: null},
                {name: "Bearing1", help: "angle, in decimal degrees, of the first radius of the arc", optional: false, default: null},
                {name: "Bearing2", help: "angle, in decimal degrees, of the second radius of the arc", optional: false, default: null},
                {name: "Steps", help: "number of steps", optional: false, default: "64"},
                //{name: "Units", help: "miles, kilometers, degrees, or radians", optional: false, default: 'kilometers'}],
	        //TODO, turf seems flaky with units
                {name: "Units", help: "miles, kilometers, degrees, or radians", optional: false, default: ''}],
    func: function(params) {
          var gj= wkt2geojson(params[0]);
          var radius= parseFloat(params[1]);
          var bearing1 = parseFloat(params[2]);
          var bearing2= parseFloat(params[3]);
          var opts={};
          if (params[4])
           opts["steps"]= parseInt(params[4]);
          if (params[5])
           opts["units"]= params[5];
          var result= turf.sector(gj, radius, bearing1, bearing2, opts);
          var WKT = geojson2wkt(result);
          return WKT;
         }
 },
{ id: 2260,
   library: "Turf",
   name: "shortestPath",
   type: "immutable",
   help: "Returns the shortest path from start to end without colliding with any Feature in obstacles",
   parameters: [{name: "Start", help: "Point", optional: false, default: null},
                {name: "End", help: "Point", optional: false, default: null},
                {name: "Obstacles", help: "Areas which path cannot travel", optional: false, default: null},
                {name: "minDistance", help: "Minimum distance between shortest path and obstacles", optional: false, default: null},
                {name: "Units", help: "miles, kilometers, degrees, or radians", optional: false, default: 'kilometers'},
                {name: "Resolution", help: "distance between matrix points on which the path will be calculated", optional: false, default: 100}],
    func: function(params) {
          var start= wkt2geojson(params[0]);
          var end= wkt2geojson(params[1]);
          var opts={};
          if (params[2])
           opts["obstacles"] = wkt2geojson(params[2]);
          if (params[3])
           opts["units"]= params[3];
          if (params[4])
           opts["resolution"]= parseFloat(params[4]);
          var result= turf.shortestPath(start,end,opts);
          var WKT = geojson2wkt(result);
          return WKT;
         }
 },
{ id: 2270,
   library: "Turf",
   name: "unkinkPolygon",
   type: "immutable",
   help: "Takes a kinked polygon and returns a feature collection of polygons that have no kinks. Uses simplepolygon internally.",
   parameters: [{name: "Geometry", help: "GeoJSON Polygon or MultiPolygon", optional: false, default: null}],
  func: function(params) {
          var poly= wkt2geojson(params[0]);
          var result= turf.unkinkPolygon(poly);
          var geomCollection = convertFCtoGC(result);
          return geojson2wkt(geomCollection);
         }
 },
{ id: 2280,
   library: "Turf",
   name: "geometryCollection",
   type: "immutable",
   help: "Creates a GeometryCollection from a list of Geometries.",
   parameters: [{name: "Geometries list", help: "Geometry List", optional: false, default: null},
                {name: "Separator", help: "character separating WKT geometries in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'}],
    func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          opts={};
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var geom_array = wkt_array.map(wkt2geojson);
          var geometry_collection = turf.geometryCollection(geom_array);
          if (geometry_collection.geometry)
           return geojson2wkt(geometry_collection.geometry);
          return geojson2wkt(geometry_collection);
          }
 },
{ id: 2290,
   library: "Turf",
   name: "multiLineString",
   type: "immutable",
   help: "Creates a MultiLineString Geometry from a list of LineString Geometries.",
   parameters: [{name: "LineStrings list", help: "List of LineString Geometries", optional: false, default: null},
                {name: "Separator", help: "character separating WKT geometries in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'}],
    func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          opts={};
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var ord_array = wkt_array.map(function (wkt) { return wkt2geojson(wkt).coordinates; });
          var feat = turf.multiLineString(ord_array);
          if (feat.geometry)
           return geojson2wkt(feat.geometry);
          return geojson2wkt(feat);
          }
 },
{ id: 2300,
   library: "Turf",
   name: "multiPolygon",
   type: "immutable",
   help: "Creates a MultiPolygon Geometry from a list of Polygon Geometries.",
   parameters: [{name: "Polygons list", help: "List of Polygon Geometries", optional: false, default: null},
                {name: "Separator", help: "character separating WKT geometries in list", optional: false, default: ","},
                {name: "Delimiter", help: "delimiter character enclosing each WKT", optional: true, default: '"'}],
    func: function(params) {
          var csv_opts={};
          if (params[1])
           csv_opts["separator"]=params[1];
          if (params[2])
           csv_opts["delimiter"]=params[2];
          opts={};
          var wkt_array = jQuery.csv.toArray(params[0],csv_opts);
          var geom_array = wkt_array.map(function(wkt) { return wkt2geojson(wkt).coordinates; });
          var feat = turf.multiPolygon(geom_array);
          if (feat.geometry)
           return geojson2wkt(feat.geometry);
          return geojson2wkt(feat);
          }
 },
{ id: 2310,
   library: "Turf",
   name: "booleanClockwise",
   type: "immutable",
   help: "Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.",
   parameters: [{name: "Line", help: "LineString to be evaluated", optional: false, default: null}],
   func: function(params) {
           var line= wkt2geojson(params[0]);
           var result = turf.booleanClockwise(line);          
           var string_result = result.toString();
           return string_result;
          }
 },
{ id: 2320,
   library: "Turf",
   name: "booleanContains",
   type: "immutable",
   help: "Boolean-contains returns True if the second geometry is completely contained by the first geometry. "+
         " The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b) "+
         "must not intersect the exterior of the primary (geometry a). Boolean-contains returns the exact opposite result "+
         "of the @turf/boolean-within.",
   parameters: [{name: "Geometry 1", help: "First Geometry", optional: false, default: null},
                {name: "Geometry 2", help: "Second Geometry", optional: false, default: null}],
   func: function(params) {
           var geom1 = wkt2geojson(params[0]);
           var geom2 = wkt2geojson(params[1]);
           var options = {};
           var result = turf.booleanContains(geom1, geom2);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2340,
  library: "Turf",
   name: "booleanCrosses",
   type: "immutable",
   help: "Boolean-Crosses returns True if the intersection results in a geometry whose dimension is one less than"+
         " the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.",
   parameters: [{name: "Geometry 1", help: "First Geometry", optional: false, default: null},
                {name: "Geometry 2", help: "Second Geometry", optional: false, default: null}],
   func: function(params) {
           var geom1 = wkt2geojson(params[0]);
           var geom2 = wkt2geojson(params[1]);
           var options = {};
           var result = turf.booleanCrosses(geom1, geom2);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2350,
   library: "Turf",
   name: "booleanDisjoint",
   type: "immutable",
   help: "Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.",
   parameters: [{name: "Geometry 1", help: "First Geometry", optional: false, default: null},
                {name: "Geometry 2", help: "Second Geometry", optional: false, default: null}],
   func: function(params) {
           var geom1 = wkt2geojson(params[0]);
           var geom2 = wkt2geojson(params[1]);
           var options = {};
           var result = turf.booleanDisjoint(geom1, geom2);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2360,
  library: "Turf",
   name: "booleanEqual",
   type: "immutable",
   help: "Determine whether two geometries of the same type have identical X,Y coordinate values."+
         " See http://edndoc.esri.com/arcsde/9.0/general_topics/understand_spatial_relations.htm",
   parameters: [{name: "Geometry 1", help: "First Geometry", optional: false, default: null},
                {name: "Geometry 2", help: "Second Geometry", optional: false, default: null}],
   func: function(params) {
           var geom1 = wkt2geojson(params[0]);
           var geom2 = wkt2geojson(params[1]);
           var options = {};
           var result = turf.booleanEqual(geom1, geom2);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2370,
  library: "Turf",
   name: "booleanOverlap",
   type: "immutable",
   help: "Compares two geometries of the same dimension and returns true if their intersection set results in a"+
         " geometry different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString, "+
         "Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.",
   parameters: [{name: "Geometry 1", help: "First Geometry", optional: false, default: null},
                {name: "Geometry 2", help: "Second Geometry", optional: false, default: null}],
   func: function(params) {
           var geom1 = wkt2geojson(params[0]);
           var geom2 = wkt2geojson(params[1]);
           var options = {};
           var result = turf.booleanOverlap(geom1, geom2);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2380,
  library: "Turf",
   name: "booleanParallel",
   type: "immutable",
   help: "Boolean-Parallel returns True if each segment of Line 1 is parallel to the correspondent segment of Line 2.",
   parameters: [{name: "Line 1", help: "First Geometry", optional: false, default: null},
                {name: "Line 2", help: "Second Geometry", optional: false, default: null}],
   func: function(params) {
           var geom1 = wkt2geojson(params[0]);
           var geom2 = wkt2geojson(params[1]);
           var options = {};
           var result = turf.booleanParallel(geom1, geom2);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2390,
  library: "Turf",
   name: "booleanPointInPolygon",
   type: "immutable",
   help: "Takes a Point and a Polygon or MultiPolygon and determines if the point resides inside the polygon. "+
         "The polygon can be convex or concave. The function accounts for holes.",
   parameters: [{name: "Point", help: "input point", optional: false, default: null},
                {name: "Polygon", help: "input polygon or multipolygon", optional: false, default: null},
                {name: "ignoreBoundary", help: "Optional parameter. True if polygon boundary should be ignored "+
                                                "when determining if the point is inside the polygon otherwise false.",
                 optional: true, default: "false"}],
   func: function(params) {
           var pnt = wkt2geojson(params[0]);
           var poly = wkt2geojson(params[1]);
           var opts = {};
           if (params[2])
            opts["ignoreBoundary"]= (params[2].toLowerCase() == 'true');
           var result = turf.booleanPointInPolygon(pnt, poly, opts);          
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2400,
  library: "Turf",
   name: "booleanPointOnLine",
   type: "immutable",
   help: "Returns true if a point is on a line. Accepts a optional parameter to ignore the start and end vertices of the linestring.",
   parameters: [{name: "Point", help: "Point", optional: false, default: null},
                {name: "Line", help: "LineString", optional: false, default: null},
                {name: "ignoreEndVertices", help: "whether to ignore the start and end vertices.", optional: true, default: 'false'}],
   func: function(params) {
           var pnt = wkt2geojson(params[0]);
           var line = wkt2geojson(params[1]);
           var opts = {};
           if (params[2])
            opts["ignoreEndVertices"]= (params[2].toLowerCase() == 'true');
           var result = turf.booleanPointOnLine(pnt, line, opts);          
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2410,
  library: "Turf",
   name: "booleanWithin",
   type: "immutable",
   help: "Boolean-within returns true if the first geometry is completely within the second geometry."+
         " The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a) "+
         "must not intersect the exterior of the secondary (geometry b). Boolean-within returns the exact opposite result "+
         "of the @turf/boolean-contains.",
   parameters: [{name: "Geometry a", help: "Geometry a", optional: false, default: null},
                {name: "Geometry b", help: "Geometry b", optional: false, default: null}],
   func: function(params) {
           var geoma= wkt2geojson(params[0]);
           var geomb = wkt2geojson(params[1]);
           var result = turf.booleanWithin(geoma, geomb);          
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2420,
  library: "Turf",
   name: "bearingToAzimuth",
   type: "immutable",
   help: "Converts any bearing angle from the north line direction (positive clockwise) and returns an angle between 0-360 "+
         "degrees (positive clockwise), 0 being the north line",
   parameters: [{name: "Bearing", help: "angle, between -180 and +180 degrees", optional: false, default: null}],
   func: function(params) {
           var a=parseFloat(params[0]);
           var result = turf.bearingToAzimuth(a);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2430,
   library: "Turf",
   name: "convertArea",
   type: "immutable",
   help: "Converts a area to the requested unit. Valid units: kilometers, kilometres, meters, "+
         "centimetres, millimeters, acres, miles, yards, feet, inches",
   parameters: [{name: "Area", help: "to be converted", optional: false, default: null},
                {name: "Original Unit", help: "Of the distance", optional: false, default: null},
                {name: "Final Unit", help: "Returned Unit", optional: false, default: null}],
   func: function(params) {
           var a= parseFloat(params[0]);
           var orig= params[1];
           var final= params[2];
           var result = turf.convertArea(a, orig, final);          
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2440,
   library: "Turf",
   name: "convertLength",
   type: "immutable",
   help: "Converts a length to the requested unit. Valid units: miles, nauticalmiles, inches,"+
         " yards, meters, metres, kilometers, centimeters, feet",
   parameters: [{name: "Length", help: "to be converted", optional: false, default: null},
                {name: "Original Unit", help: "Of the length", optional: false, default: null},
                {name: "Final Unit", help: "Returned Unit", optional: false, default: null}],
   func: function(params) {
           var l= parseFloat(params[0]);
           var orig= params[1];
           var final= params[2];
           var result = turf.convertLength(l, orig, final);          
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2450,
  library: "Turf",
   name: "degreesToRadians",
   type: "immutable",
   help: "Converts an angle in degrees to radians.",
   parameters: [{name: "Degrees", help: "angle between 0 and 360 degrees", optional: false, default: null}],
   func: function(params) {
           var d=parseFloat(params[0]);
           var result = turf.degreesToRadians(d);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2460,
   library: "Turf",
   name: "lengthToRadians",
   type: "immutable",
   help: "Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians Valid units: "+
         " miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet",
   parameters: [{name: "Distance", help: "in real units", optional: false, default: null},
                {name: "Units", help: "can be degrees, radians, miles, or kilometers inches, yards, metres,"+
                                      " meters, kilometres, kilometers.", optional: false, default: null}],
   func: function(params) {
           var l= parseFloat(params[0]);
           var units= params[1];
           var result = turf.lengthToRadians(l, units);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2470,
   library: "Turf",
   name: "lengthToDegrees",
   type: "immutable",
   help: "Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees Valid units: "+
         "miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet",
   parameters: [{name: "Distance", help: "in real units", optional: false, default: null},
                {name: "Units", help: "can be degrees, radians, miles, or kilometers inches, yards, metres,"+
                                      " meters, kilometres, kilometers.", optional: false, default: null}],
   func: function(params) {
           var l= parseFloat(params[0]);
           var units= params[1];
           var result = turf.lengthToDegrees(l, units);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2480,
  library: "Turf",
   name: "radiansToLength",
   type: "immutable",
   help: "Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit. Valid units: "+
          "miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet",
   parameters: [{name: "Radians", help: "in radians across the sphere", optional: false, default: null},
                {name: "Units", help: "can be degrees, radians, miles, or kilometers inches, yards, metres,"+
                                      " meters, kilometres, kilometers.", optional: false, default: null}],
   func: function(params) {
           var r= parseFloat(params[0]);
           var units= params[1];
           var result = turf.radiansToLength(r, units);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2490,
  library: "Turf",
   name: "radiansToDegrees",
   type: "immutable",
   help: "Converts an angle in radians to degrees",
   parameters: [{name: "Radians", help: "angle in radians", optional: false, default: null}],
   func: function(params) {
           var d=parseFloat(params[0]);
           var result = turf.radiansToDegrees(d);
           var ts_result = result.toString();
           return ts_result;
          }
 },
{ id: 2500,
   library: "Turf",
   name: "toMercator",
   type: "immutable",
   help: "Converts a WGS84 Geometry into Mercator (EPSG:900913) projection",
   parameters: [{name: "Geometry", help: "WGS84 Geometry", optional: false, default: null}],
   func: function(params) {
           var gj= wkt2geojson(params[0]);
           var result = turf.toMercator(gj,{mutate: true});
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2510,
   library: "Turf",
   name: "toWgs84",
   type: "immutable",
   help: "Converts a Mercator (EPSG:900913) Geometry into WGS84 projection",
   parameters: [{name: "Geometry", help: "Mercator Geometry", optional: false, default: null}],
   func: function(params) {
           var gj= wkt2geojson(params[0]);
           var result = turf.toWgs84(gj,{mutate: true});
           var WKT= geojson2wkt(result);
           return WKT;
          }
 },
{ id: 2520,
   library: "Turf",
   name: "getType",
   type: "immutable",
   help: "Get Geometries Type",
   parameters: [{name: "Geometry", help: "WKT Geometry", optional: false, default: null}],
   func: function(params) {
           var gj= wkt2geojson(params[0]);
           var result = turf.getType(gj);
           return result;
          }
 }
];

 
/* ----- End Custom Function Metadata ----- */


/* ----- End of Custom Functions ----- */


/* ----- Begin General Page element helper functions ----- */

// Nav Bar support function
function NavRender() {
  var x = $I("navdiv");
  if (x.className==="topnav") {
    x.className+=" responsive";
  } else {
    x.className="topnav";
  }
}

function chunked_file_reader(file, status_elem, is_quick) {
 var CHUNK_SIZE = 4*1024*1024;
 let RESULTS=[];
 let readline=[];
 var offset=0;
 var fr=new FileReader();
 fr.onload = function() {
  var view = new Uint8Array(fr.result);
  for (var i=0; i<view.length; i++) {
   if (view[i] === 10 || view[i] === 13) {
    if (readline.length>0) {
     let line = new Uint8Array(readline);
     let arr = new TextDecoder().decode(line);
     RESULTS.push(arr)
    };
    readline=[];
   } else
    readline.push(view[i]);
  }
  offset+= view.length;
  if (status_elem)  {
   var blurb='<progress value="'+escATTR(offset.toString())+'"' +
             ' max="'+escATTR(file.size.toString())+'"></progress> ' +
 	     '<span style="color:blue;">'+escHTML(sizeMb(offset))+'</span>';
   $I(status_elem).innerHTML= blurb;
  }
  seek();
 };
 fr.onerror = function() {
  if (status_elem)  {
   var blurb='<span style="color:blue;">Error Reading File</span>';
   $I(status_elem).innerHTML= blurb;
  }
 };
 seek();
 function seek() {
  if (offset >= file.size) {
   if (status_elem) $I(status_elem).innerHTML='';
   gTHE_READ_FILE={};
   gTHE_READ_FILE.raw_lines=RESULTS;
   gTHE_READ_FILE.handle=file;
   file_drop(file, RESULTS, is_quick);
  } else {
    var slice=file.slice(offset,offset+CHUNK_SIZE);
    fr.readAsArrayBuffer(slice);
  }
 }
}

function chunked_url_reader(view, preview, content_type, receivedLength, state, browse)  {
 var CHUNK_SIZE = 32*1024;
 let RESULTS=[];
 let readline=[];
 let total_length=parseInt(view.length);
 let total_length2=parseInt(view.length);
 for (var i=0; i<view.length; i++) {
  if (view[i] === 10 || view[i] === 13) {
   if (readline.length>0) {
    let line = new Uint8Array(readline);
    let arr = new TextDecoder().decode(line);
    RESULTS.push(arr)
   };
   readline=[];
  } else
   readline.push(view[i]);
  if ((i%CHUNK_SIZE<1)||(i==total_length)) {
   var blurb='<progress value="'+escATTR(i.toString())+'"' +
             ' max="'+escATTR(total_length.toString())+'"></progress> ' +
       '<span style="color:blue;">'+escHTML(sizeMb(i))+'</span>';
   download_progress(i, total_length);
  }
 }

 var blurb='<progress value="'+escATTR(total_length2.toString())+'"' +
           ' max="'+escATTR(total_length2.toString())+'"></progress> ' +
           '<span style="color:blue;">'+escHTML(sizeMb(total_length2))+'</span>';
 download_progress(i, total_length2);

 $I("urlextract").innerHTML=make_preview(RESULTS);
 if (!preview)
  prepare_url_load_for_import(RESULTS, content_type, receivedLength, state, browse);
}


// File Drag and Drop functions

function setup_file_dd() {
 var fileInput=$I('thefile');
 var dropzone = document.querySelector('.filediv');
 fileInput.addEventListener('change', function(evt) {
  dropzone.classList.remove('dragover');
  var f = evt.target.files[0];
  chunked_file_reader(f, 'filereadstatus', false);
 });
 fileInput.addEventListener('dragenter', function() {
  dropzone.classList.add('dragover');
 });
 fileInput.addEventListener('dragleave', function() {
  dropzone.classList.remove('dragover');
 });
}

function setup_file_dd_quick() {
 var fileInput=$I('quickfile');
 var dropzone = document.querySelector('.quickfilediv');
 fileInput.addEventListener('change', function(evt) {
  dropzone.classList.remove('dragover');
  var f = evt.target.files[0];
  chunked_file_reader(f, 'quickreadstatus', true);
 });
 fileInput.addEventListener('dragenter', function() {
  dropzone.classList.add('dragover');
 });
 fileInput.addEventListener('dragleave', function() {
  dropzone.classList.remove('dragover');
 });
}

// File Pane input helpers
function filedelimchange() {
 var e=$I("filedelim");
 var delim=e.options[e.selectedIndex].value;
 $I("filecustomdelim").disabled=((delim=='Custom')?false:true);
}

function filesepchange() {
 var e=$I("filesep");
 var sep=e.options[e.selectedIndex].value;
 $I("filecustomsep").disabled=((sep=='Custom')?false:true);
}

function file_drop(f, raw_lines, is_quick) {
 clear_import_lists();
 $I("filedescription").innerHTML=make_file_description(f);
 $I("fileextract").innerHTML=make_preview(raw_lines);
 var fname=windows_filename_dededuper(basename(f.name));
 search_table_filename(fname, f, raw_lines, is_quick);
}

function new_file(f, raw_lines, is_quick) {
//function new_file(f,is_quick) {
 $I("filedelim").options[0].selected=true;
 $I("filecustomdelim").value='';
 $I("filecustomdelim").disabled=true;
 $I("filesep").options[0].selected=true;
 $I("filecustomsep").value='';
 $I("filecustomsep").disabled=true;
 $I("fileskiplines").value= 0;
 $I("fileheader").checked=true;
 $I("fileasnull").checked=true;
 var tablename=strip_csv_suffix(windows_filename_dededuper(basename(f.name)));
 $I("filetablename").value=tablename;
 $I("filetabletemp").checked=false;
 $I("filetaskid").value="";
 $I("fileauto").checked=false;
 //Temp setting may be overwritten
 if (!gALL_DATA[tablename]) {
  gALL_DATA[tablename]={};
  gALL_DATA[tablename].raw_lines=raw_lines;
  gALL_DATA[tablename].file_raw_lines=raw_lines;
  gALL_DATA[tablename].handle=f;
  //gTHE_READ_FILE={};
  //gTHE_READ_FILE.raw_lines=raw_lines;
  //gTHE_READ_FILE.handle=f;
 }
 if (is_quick) {
  set_visible_pane('fileimport');
  create_file_table_metadata(false,true,raw_lines, f);
 }
}


// URL Pane helper functions

function urldelimchange() {
 var e=$I("urldelim");
 var delim=e.options[e.selectedIndex].value;
 $I("urlcustomdelim").disabled=((delim=='Custom')?false:true);
}

function urlsepchange() {
 var e=$I("urlsep");
 var sep=e.options[e.selectedIndex].value;
 $I("urlcustomsep").disabled=((sep=='Custom')?false:true);
}

function new_url() {
 $I('urlurl').value='';
 $I("urllist_summary").innerHTML='';
 $I("urllist_progress").innerHTML='';
 $I("urllist_results").innerHTML='';
 $I("urllist_results_smallscreen").innerHTML='';
 $I("urllist_save_progress").innerHTML='';
 $I("urldelim").options[0].selected=true;
 $I("urlcustomdelim").value='';
 $I("urlcustomdelim").disabled=true;
 $I("urlsep").options[0].selected=true;
 $I("urlcustomsep").value='';
 $I("urlcustomsep").disabled=true;
 $I("urlskiplines").value='0';
 $I("urlheader").checked=true;
 $I("urlasnull").checked=true;
 $I("urltablename").value='';
 $I("urltabletemp").checked=false;
 $I("urltaskid").value='';
 $I("urlmaxage").value='0';
 $I("urlheadername1").value='';
 $I("urlheadervalue1").value='';
 $I("urlheadername2").value='';
 $I("urlheadervalue2").value='';
 $I("urlextract").innerHTML='';
 url_progress('');
}

function qsHtml(qs,msg){
 for (var i=0;i<qs.length;i++)
  qs[i].innerHTML=msg;
}

function update_app_name() {
 var app=$I('application-name').getAttribute('content');
 var qs=document.querySelectorAll('.application');
 qsHtml(qs,app);
}

function update_status(override_message){
 var qs= document.querySelectorAll('.importstatus');
 qsHtml(qs,'');
 var msg='';
 if (override_message){
  qsHtml(qs,override_message);
  return;
 }
 for (i in gALL_DATA){
  if (gALL_DATA[i].status=='Extracting')
   msg+='<br/>'+escHTML(i)+' <span class="info1">Extracting</span> '+gSPIN;
  if (gALL_DATA[i].status=='Importing'){
   msg+='<br/>'+escHTML(i)+' <span class="info1">Importing</span> '+
         '<progress max="'+escATTR(gALL_DATA[i].row_count.toString())+'" value="'+escATTR(gALL_DATA[i].load_value.toString())+'"></progress>';
   if (gALL_DATA[i].load_value>0)
     msg+=' <span style="color:green;">'+gALL_DATA[i].load_value+'</span>';
   }
  if (gALL_DATA[i].status=='Initialising')
   msg+='<br/>'+escHTML(i)+' <span class="info1">Intialising database objects</span> '+gSPIN;
  if (gALL_DATA[i].status=='Splitting')
   msg+='<br/>'+escHTML(i)+' <span class="info1">Parsing</span> '+gSPIN;
  if (gALL_DATA[i].status=='Loaded'){
   if (gALL_DATA[i].failures>0)
    msg+= '<br/>'+escHTML(i)+' <span class="info_success">Loaded</span> '+
          '<span class="info_success">('+escHTML(gALL_DATA[i].load_value)+' rows)</span> '+
          '<span class="alert">(failures <b>'+escHTML(gALL_DATA[i].failures)+'</b>)</span>'
   else
    msg+= '<br/>'+escHTML(i)+' <span class="info_success">Loaded</span> '+
          '<span class="info_success">('+escHTML(gALL_DATA[i].load_value)+' rows)</span>';
  }
  if (gALL_DATA[i].error_msg) {
   msg+= '<br/>'+escHTML(i)+' <span class="error">'+escHTML(gALL_DATA[i].error_msg)+'</span>';  
  }
 }
 var msg1=msg.replace(/^\<br\/\>/,''); // Strip leading br if any.
 qsHtml(qs,msg1);
}


/* ----- End General Page element helper functions ----- */


/* ----- Begin generic Utility functions ----- */

function basename(x) {
 if (!x) return x;
 return x.split(/[\\/]/).pop(); 
}

function windows_filename_dededuper(str) {
 var dedup=str.match(/\s+\([0-9]+\)\./);
 if (dedup) 
  return str.replace(dedup[0],'.');
 else
 return str; 
}

function strip_csv_suffix(str) {
 var isCSV=str.match(/\.CSV$/);
 if (!isCSV)
  isCSV=str.match(/\.csv$/);
 if (isCSV)
  return str.replace(isCSV[0],'');
 else
  return str;
}

function sizeMb(sz) {
 if (!sz)
  return null;
 var mb=sz/(1024*1024);
 return mb.toFixed(2)+" Mb";
}

function onlyHex(hex_color) 
 {return (hex_color.charAt(0)=="#")?hex_color.substring(1,7):hex_color}

function hexToRGBA(hex_color, opacity) {
 if ((!opacity)&&(opacity!=0)) opacity=1;
 var red_color=parseInt((onlyHex(hex_color)).substring(0,2),16), 
     green_color=parseInt((onlyHex(hex_color)).substring(2,4),16), 
     blue_color=parseInt((onlyHex(hex_color)).substring(4,6),16);
 return 'rgba('+red_color+ ', '+green_color+', '+blue_color+', '+opacity+')';
}
 
function tick_fade(elem_id){
 try {
  $I(elem_id).innerHTML='<i class="fa fa-check" style="color: green;"></i>';
  window.setTimeout(function(){$I(elem_id).innerHTML='';},1000);
     } catch(e) {};
}

function download_file(data, filename, content_type) {
 var a=window.document.createElement('a');
 a.download=filename;
 a.href=window.URL.createObjectURL(new Blob([data], {type: content_type}));
 document.body.appendChild(a);
 a.click(); 
 document.body.removeChild(a);
 delete a;
}

function notify(msg) {
 if (gIS_INTERACTIVE)
  alert(msg);
 else
  $L(msg);
}

/* ----- End generic Utility functions ----- */

/* ------ Begin Web Safe escape functions ----- */

function chopFIELD(str) {
 if (!str)
  return str;
 var max_len= parseInt(get_simple_value('CONFIG_FIELD_TRUNCATE'));
 if (!max_len)
  max_len=10000;
 if (str.length>=max_len)
  return str.substring(0,max_len)+' ....';
 return str;
}

var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': '&quot;',
  "'": '&#39;',
  "/": '&#x2F;'
};

function entityStrip(string) {
 return String(string).replace(/[&<>"'\/]/g,function(s){return entityMap[s];});
}

function escHTML(string, link_target) {
 if (string==null)
  return null;
 if (string.length==0)
  return '';
 if (safeURL(string)) {
  string=chopFIELD(string);
  var target='';
  if (link_target)
   target='target="'+escATTR(link_target)+'"';
  return '<a class="blk" '+target+' href="'+escATTR(string)+'">'+entityStrip(string)+'</a>';
  }   
 var str=entityStrip(string);
 return chopFIELD(str);
}

function drilldownURL(query_string, append_metadata, link_target, anchor) {
 if (!query_string)
  return null;
 var cur=window.location.href;
 var suffix=window.location.search+window.location.hash;
 if (suffix)
  cur=cur.replace(suffix,'');
 cur+='?'+query_string;
 if ((append_metadata)&&(gMETADATA))
  cur+='&METADATA='+encodeURIComponent(gMETADATA);
 if ((!safeURL(cur))&&(window.location.protocol!='file:'))
  return null;
 var target='';
 if (link_target)
  target='target="'+escATTR(link_target)+'"';
 return '<a class="blk" '+target+' href="'+escATTR(cur)+'">'+entityStrip(anchor)+'</a>';
}

function drilldownClick(query_string, append_metadata, link_target) {
 if (!query_string)
  return null;
 var cur=window.location.href;
 var suffix=window.location.search+window.location.hash;
 if (suffix)
  cur=cur.replace(suffix,'');
 cur+='?'+query_string;
 if ((append_metadata)&&(gMETADATA))
  cur+='&METADATA='+encodeURIComponent(gMETADATA);
 if ((!safeURL(cur))&&(window.location.protocol!='file:'))
  return null;
 if (!link_target)
  window.location=cur;
 else
  window.open(cur,link_target);
}

function escATTR(string) {
 if (!string)
  return '';
 var arr1=[];
 for (var n=0, l=string.length; n<l; n++) {
  var c=string.charCodeAt(n);
  var hex=c.toString(16);
  var codeHex=hex.toUpperCase();
  while (codeHex.length<4) {
   codeHex = "0" + codeHex;
  }
  arr1.push('&#x'+codeHex+';');
 }
 return arr1.join('');
}

function safeURL(string) {
 if (!string)
  return false;
 else
  return re_weburl.test(string);
}

function qescape(string) {
 if (!string) return string;
 if (typeof string == 'number')
  return string;
 else
  return string.replace(/\\/g,'\\\\').replace(/'/g,"\\'");
}

/* ------ End Web Safe escape functions ----- */

/* ----- Begin Core Assist functions ----- */

// Param tokenizer
function tokenise_search_string(str) {
 var result = str.split(" ").
               filter(function(el){ return el != "" }).
                 map(function(el) { return '%'+el+'%' });
 return result;
}

function get_new_sort_dir(dir) {
 if (!dir)
  return "asc";
 if (dir=="asc")
  return "desc";
 if (dir=="desc")
  return "asc";
 return "asc";
}

function get_sort_icon(dir) {
 if (dir=="asc")
  return '<i class="fa fa-sort-asc" style="color: blue;"></i>';
 if (dir=="desc")
  return '<i class="fa fa-sort-desc" style="color: blue;"></i>';
 return '<i class="fa fa-unsorted" style="color: blue; opacity: 0.4"></i>';
}

function make_file_description(f) {
 var name=basename(f.name);
 var type=f.type;  
 var size='';
 if (f.size)
  size=sizeMb(f.size);
 if (type)
  type='('+type+')';
 return '<b>'+escHTML(name)+'</b> '+escHTML(type)+' '+size;
}

/* ----- End Core Assist functions ----- */




/* ===== Begin Core functions (heavy lifters)  ===== */

function search_table_filename(filename, handle, raw_lines, is_quick) {
 var file_metadata=null;
 gDB.transaction(
  function(t) {
   t.executeSql("select t.* from VF_TABLES t where file_name_deduped = ?;", [filename],
    function (tx, r) {
     if (r.rows.length > 0) {
      // Found record
      var i=0;
      var tup = r.rows.item(i); 
      file_metadata= {"table_name": tup.TABLE_NAME,
	              "file_name": filename,
                      "charset": tup.CHARSET,
                      "skip_lines": (tup.SKIP_FIRST_LINES||0),
                      "delimiter":  tup.DELIMITER,
                      "custom_delimiter": tup.CUSTOM_DELIMITER,
                      "separator": tup.SEPARATOR,
                      "custom_separator": tup.CUSTOM_SEPARATOR,
                      "header_row": tup.HEADER_ROW,
                      "empty_as_null": tup.EMPTY_AS_NULL,
                      "is_temp": tup.IS_TEMP,
                      "file_import_start_task_id": tup.FILE_IMPORT_START_TASK_ID,
                      "file_automate": tup.FILE_IMPORT_AUTOMATE};
                          };
                       });
                 }, $L , function() {
			 if (!file_metadata) 
                          new_file(handle, raw_lines, is_quick);
			 else 
                          found_file_metadata(file_metadata, handle, raw_lines, false, is_quick); 
			               });
 }

function search_file_table_rowid(rowid) {
 set_visible_pane('fileimport'); //May be called from "Browse"
 var file_metadata=null;
 var file_type=null;
 var file_name=null;
 gDB.transaction(
  function(t) {
   t.executeSql("select t.* from VF_TABLES t where rowid = ?;", [rowid],
    function (tx, r) {
     if (r.rows.length > 0) {
      // Found record
      var i=0;
      var tup = r.rows.item(i); 
      file_type=tup.FILE_TYPE;
      file_name=tup.FILE_NAME_DEDUPED,
      file_metadata= {"table_name": tup.TABLE_NAME,
                      "file_name": file_name,
                      "skip_lines": (tup.SKIP_FIRST_LINES||0),
                      "charset": tup.CHARSET,
                      "charset": tup.CHARSET,
                      "delimiter":  tup.DELIMITER,
                      "custom_delimiter": tup.CUSTOM_DELIMITER,
                      "separator": tup.SEPARATOR,
                      "custom_separator": tup.CUSTOM_SEPARATOR,
                      "header_row": tup.HEADER_ROW,
                      "empty_as_null": tup.EMPTY_AS_NULL,
                      "is_temp": tup.IS_TEMP,
                      "file_import_start_task_id": tup.FILE_IMPORT_START_TASK_ID,
                      "file_automate": tup.FILE_IMPORT_AUTOMATE};
                          };
                       });
                 }, null, function() { 
			     var t={};
			     t.name=file_name;
			     t.type=file_type;
			     t.size=null;
                             var descr= make_file_description(t);
                             $I("filedescription").innerHTML= descr;
                             found_file_metadata(file_metadata, null, null, false, false); 
                                     });
 }
       
function found_file_metadata(md, handle, raw_lines, browse, is_quick) {
 if (!gALL_DATA[md.table_name]) {
  gALL_DATA[md.table_name]={};
  gALL_DATA[md.table_name].raw_lines=raw_lines;
  gALL_DATA[md.table_name].handle=handle;
 }

 $I("filetablename").value=md.table_name;
 //$I("filecharset").value= md.charset; //Future Implementation 
 $I("fileskiplines").value=(md.skip_lines||0);
 $I("filesep").value=md.separator;
 $I("filecustomsep").value=md.custom_separator;
 $I("filedelim").value=md.delimiter;
 $I("filecustomdelim").value=md.custom_delimiter;
 $I("fileheader").checked=(md.header_row) ? true : false;
 $I("fileasnull").checked=(md.empty_as_null > 0) ? true : false;
 $I("filetabletemp").checked=(md.is_temp) ? true : false;
 $I("filetaskid").value=md.file_import_start_task_id;
 $I("fileauto").checked=(md.file_automate) ? true : false;
 if ((handle)&&(md.file_automate)) {
  set_visible_pane('fileimport'); 
  create_file_table_metadata(false,browse,raw_lines,handle);
  return;
 }
 if (is_quick) {
  set_visible_pane('fileimport');
  create_file_table_metadata(false,true,raw_lines,handle);
  return;
 }
};

function  create_file_table_metadata(no_import,browse,raw_lines,handle) {
 try { raw_lines = (raw_lines || gTHE_READ_FILE.raw_lines.slice()); } catch(e) {};
 try { handle = (handle || gTHE_READ_FILE.handle ); } catch(e) {};
 // File needs to be loaded and read.
 if (!no_import) {
  if ((!raw_lines)) {
   notify("No File.");
   return;
  }
  if (!handle) {
   notify("Unable to determine Import File.");
   return;
  }
 }
 var table_name=$I("filetablename").value;
 var file_separator=$I("filesep").value;
 var file_custom_separator=$I("filecustomsep").value;
 var file_delimiter=$I("filedelim").value;
 var file_custom_delim=$I("filecustomdelim").value;
 var file_skip_lines=$I("fileskiplines").value;
 var separator=((file_separator=="Custom")?file_custom_separator:file_separator);
 var delimiter=((file_delimiter=="Custom")?file_custom_delim:file_delimiter);
 var header_row =(($I("fileheader").checked)?1:0);
 var empty_as_null=(($I('fileasnull').checked)?1:0);
 var prelim_metadata=
  {"table_name":table_name,
   "separator":separator,
   "delimiter":delimiter,
   "skip_lines":file_skip_lines};
 //Reset Metadata
 gALL_DATA[table_name]={};
 gALL_DATA[table_name].status='Splitting';
 gALL_DATA[table_name].row_count=0;
 gALL_DATA[table_name].load_value=0;    
 gALL_DATA[table_name].failures=0;    
 gALL_DATA[table_name].parsed_data=null;
 gALL_DATA[table_name].raw_lines=skip_lines(raw_lines, (file_skip_lines||0));
 gALL_DATA[table_name].raw_data=[]; 
 gALL_DATA[table_name].handle=handle;
 update_status();
 if (!is_small_file(gALL_DATA[table_name].raw_lines)) {
  // Using iterative line-by-line parser (large input file)
  gALL_DATA[table_name].row_count=gALL_DATA[table_name].raw_lines.length;
  var first_row=gALL_DATA[table_name].raw_lines[0];
  var table_columns=get_columns(first_row,header_row,separator,delimiter);
  if (!table_columns) {
   notify('Unable to determine columns from dataset. (Check "Skip Lines" is not set too high).');
  return;
 } else {
   gALL_DATA[table_name].table_columns=table_columns;
   prelim_metadata.table_columns=table_columns;
 };
  //load_file_chunked(prelim_metadata, 'Initialise', browse, null);
  create_file_table_metadata_continue(no_import, browse, raw_lines);
 } else {
  // Using full standards csv parser (small input file)
  gALL_DATA[table_name].raw_data=re_combine(gALL_DATA[table_name].raw_lines);
  window.setTimeout(
   function(){data_parse(table_name,
  	                 prelim_metadata,
	                 function(data){
				var cleansed_data;
				if (empty_as_null)
				 cleansed_data=cleanse_record_set(data,empty_as_null);
				else
				 cleansed_data=data;
 				gALL_DATA[table_name].parsed_data=cleansed_data;
 				gALL_DATA[table_name].row_count=data.length;
	                        create_file_table_metadata_continue(no_import, browse, raw_lines); }
                       );
           },
           1);
 }
}

function create_file_table_metadata_continue(no_import,browse,raw_lines) {
 // File needs to be loaded and read.
 if (!no_import) {
  if (!raw_lines) {
   notify("No data");
   return;
  }
 }
	
 var table_name = $I("filetablename").value;
 var file_name, file_size, file_last_modified, file_last_modified_date, file_type;

 try {
  file_name = windows_filename_dededuper(basename(gALL_DATA[table_name].handle.name));
  file_size = gALL_DATA[table_name].handle.size;
  file_last_modified = gALL_DATA[table_name].handle.lastModified;
  file_last_modified_date = gALL_DATA[table_name].handle.lastModifiedDate;
  file_type = gALL_DATA[table_name].handle.type;
     } catch(e) {};

 //var file_charset=$I("filecharset").value;
 var file_separator=$I("filesep").value;
 var file_custom_separator=$I("filecustomsep").value;
 var file_delimiter=$I("filedelim").value;
 var file_custom_delim=$I("filecustomdelim").value;
 var skip_lines=$I("fileskiplines").value;
 var header_row=(($I("fileheader").checked)?1:0);
 var empty_as_null=(($I("fileasnull").checked)?1:0);
 var is_temp=(($I("filetabletemp").checked)?1:0);
 var file_task_id=$I("filetaskid").value;
 var file_automate=(($I("fileauto").checked)?1:0);
 var last_refresh=null;

 var separator = (file_separator=="Custom")?file_custom_separator:file_separator;
 var delimiter = (file_delimiter=="Custom")?file_custom_delim:file_delimiter;

 var the_columns=null;
 //Get header line
 if (!gALL_DATA[table_name].table_columns) {  // Already determined columns
  var first_row=gALL_DATA[table_name].parsed_data[0];
  the_columns=((header_row>0)?first_row:make_columns(first_row));
  if (!the_columns) {
   notify('Unable to determine columns from dataset. (Check "Skip Lines" is not set too high).');
   return;
  }
 } else
  the_columns=gALL_DATA[table_name].table_columns;

 var ALL_COLUMNS= JSON.stringify(the_columns);
 var NO_COLUMNS= JSON.stringify([]);

 var cr_table_sql=null;
 if (the_columns)
  cr_table_sql= cr_table_creation_script(is_temp, table_name, the_columns);

 var table_import_metadata =
   {"table_name": table_name,
    "file_name": file_name,
    "skip_lines": skip_lines,
    "separator": separator,
    "delimiter": delimiter,
    "header_row": header_row,
    "empty_as_null": empty_as_null,
    "table_columns": the_columns,
    "file_task_id": file_task_id,
    "file_automate": file_automate };


 gDB.transaction(
  function(t) {

  t.executeSql("delete from VF_TABLES where file_name_deduped = ? or table_name = ?", [file_name, table_name]);
  t.executeSql("insert into VF_TABLES(TABLE_TYPE, TABLE_NAME, FILE_NAME_DEDUPED, FILE_SIZE, FILE_LAST_MODIFIED, FILE_LAST_MODIFIED_DATE, "+
                                       "FILE_TYPE, CHARSET, SKIP_FIRST_LINES, DELIMITER, CUSTOM_DELIMITER, SEPARATOR, CUSTOM_SEPARATOR,"+
                                       "HEADER_ROW, EMPTY_AS_NULL, IS_TEMP, FILE_IMPORT_START_TASK_ID, FILE_IMPORT_AUTOMATE,"+
                                       "LAST_TABLE_REFRESH, ALL_TABLE_COLUMNS, HIDDEN_TABLE_COLUMNS, DISPLAY_TABLE_COLUMNS) "+
                               "values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
                               ["FILE",
                                table_name,
                                file_name,
                                file_size,
                                file_last_modified,
                                file_last_modified_date,
                                file_type,
                                'UTF-8', //Future Implementation
				skip_lines,
                                file_delimiter,
                                file_custom_delim,
                                file_separator,
                                file_custom_separator,
                                header_row,
                                empty_as_null,                                 
                                is_temp,
                                file_task_id,
                                file_automate,
                                null, //last_refresh,
                                null, //ALL_COLUMNS,
                                null, //NO_COLUMNS,
                                null, //ALL_COLUMNS
                                ]);

  if (cr_table_sql) {
   t.executeSql("drop table if exists "+sanitise(table_name));
   t.executeSql(cr_table_sql);
  };

          }, function(e,t) {filetable_error(e,t,table_name); }, function() { 
			 if (!no_import) 
			     start_file_import(table_import_metadata, browse); 
			    else { //Local Save
                             tick_fade('filelist_save_progress');
			     list_fileimports();
			    }
		                     });
}
        
function start_file_import(md,browse) {
 gALL_DATA[md.table_name].status='Splitting';
 gALL_DATA[md.table_name].load_value=0;    
 gALL_DATA[md.table_name].failures=0;    
 update_status();
 if (is_small_file(gALL_DATA[md.table_name].raw_lines)) 
  load_parsed_file(md,'Initialise',null,browse);
 else 
  load_file_chunked(md,'Initialise',browse,null);
}

function filetable_error(e,t, table_name){
 var msg='<span class="error">'+escHTML(e.message)+'</span>';
 $I("filelist_summary").innerHTML=msg;
 if (table_name) {
  gALL_DATA[table_name].status='Failed';
  gALL_DATA[table_name].err_msg='Parse failure';
  update_status();
 }
}

function update_only_file_table_metadata() {
 var table_name=$I("filetablename").value;
 //var file_charset=$I("filecharset").value;
 var file_separator=$I("filesep").value;
 var file_custom_separator=$I("filecustomsep").value;
 var file_delimiter=$I("filedelim").value;
 var file_custom_delim=$I("filecustomdelim").value;
 var skip_lines=$I("fileskiplines").value;
 var header_row=(($I("fileheader").checked)?1:0);
 var empty_as_null=(($I("fileasnull").checked)?1:0);
 var is_temp=(($I("filetabletemp").checked)?1:0);
 var file_task_id=$I("filetaskid").value;
 var file_automate=(($I("fileauto").checked)?1:0);
 var last_refresh=null;

 var separator = (file_separator=="Custom")?file_custom_separator:file_separator;
 var delimiter = (file_delimiter=="Custom")?file_custom_delim:file_delimiter;

 //Basic validation
  if (!table_name) {
   notify('Table Name is required.');
   return;
 }

 $I("filelist_save_progress").innerHTML=gSPIN;

 gDB.transaction(
  function(t) {

  t.executeSql("update VF_TABLES set CHARSET=?, SKIP_FIRST_LINES=?, "+
	       "DELIMITER=?, CUSTOM_DELIMITER=?, SEPARATOR=?, CUSTOM_SEPARATOR=?, "+
               "HEADER_ROW=?, EMPTY_AS_NULL=?, IS_TEMP=?, FILE_IMPORT_START_TASK_ID=?, FILE_IMPORT_AUTOMATE=? "+
               "where table_name=? ",
                               ['UTF-8', //Future Implementation
				skip_lines,
                                file_delimiter,
                                file_custom_delim,
                                file_separator,
                                file_custom_separator,
                                header_row,
                                empty_as_null,                                 
                                is_temp,
                                file_task_id,
                                file_automate,
                                table_name
                                ]);

                 }, $L, function() { update_only_file_table_metadata_post(); });
}

function update_only_file_table_metadata_post() {
 tick_fade('filelist_save_progress');
}

function list_fileimports() {
 $I("filelist_summary").innerHTML='';
 $I("filelist_progress").innerHTML=gSPIN;
 $I("filelist_results").innerHTML='';
 $I("filelist_results_smallscreen").innerHTML='';
 $I("filelist_summary").innerHTML='';
 gDB.transaction(function (t) {
   t.executeSql("select rowid, table_name, file_name_deduped, file_import_start_task_id, "+
	        "file_last_modified_date from vf_tables where table_type='FILE' order by file_name_deduped", [],
    function (tx, r) {
     var shown="";
     if (r.rows.length > gUNPAGINATED_MAX_ROWS)
      shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
     $I('filelist_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved File Import Tables "+shown;
     if (parseInt(r.rows.length)>0) {
      let msg='<tr class="hdr1 bold"><td>Table</td><td>File Name (deduped)</td><td>Last Modified</td>'+
               //'<td>Date Saved</td>
             '<td>Task Id</td><td>Edit</td><td>Drop</td></tr>';
      $I('filelist_results').innerHTML=msg;
                                      };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
      let row_results='<tr class="rs"><td>'+escHTML(r.rows.item(i).TABLE_NAME)+'</td>'+
		      '<td>'+escHTML(r.rows.item(i).FILE_NAME_DEDUPED)+'</td>'+
		      '<td>'+escHTML(r.rows.item(i).FILE_LAST_MODIFIED_DATE)+'</td>'+
		      //'<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td>'+
		      '<td>'+escHTML(r.rows.item(i).FILE_IMPORT_START_TASK_ID)+'</td>'+
                      '<td><button title="Edit" onclick="'+escATTR('handle_filelist(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
		      '<td><button title="Drop" onclick="'+escATTR('handle_filelist(\'drop\','+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
      $I('filelist_results').innerHTML+= row_results;
      let row_smallscreen='<tr class="rs"><td><dl>'+
       '<dt class="hdrg">Table</dt>'+
       '<dd>'+escHTML(r.rows.item(i).TABLE_NAME)+'</dd>'+
       '<dt class="hdrg">File Name</dt>'+
       '<dd>'+escHTML(r.rows.item(i).FILE_NAME_DEDUPED)+'</dd>'+
       '<dt class="hdrg">Last Modified</dt>'+
       '<dd>'+escHTML(r.rows.item(i).FILE_LAST_MODIFIED_DATE)+'</dd>'+
       //'<dt class="hdrg">Date Saved</dt>'+
       //'<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
       '<dt class="hdrg">Task Id</dt>'+
       '<dd>'+escHTML(r.rows.item(i).FILE_IMPORT_START_TASK_ID)+'</dd>'+
       '<dt class="hdrg">Action</dt>'+
       '<dd><button title="Edit" onclick="'+escATTR('handle_filelist(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
            '<button title="Drop" onclick="'+escATTR('handle_filelist(\'drop\','+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
       '</dd></dl></td></tr>';
      $I('filelist_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
					 },$L,filelist_loaded );
 }

function filelist_loaded() {
 $I("filelist_progress").innerHTML='';
}

function drop_file_table(rowid) {
 $I("filelist_progress").innerHTML=gSPIN;
 $I("filelist_summary").innerHTML='';
 var table_name="";
 gDB.transaction(
  function(t) {
   t.executeSql("select table_name from vf_tables where rowid=?", [rowid],
    function (tx,r){
     table_name=r.rows.item(0).TABLE_NAME;
                     });
     },$L,function(){process_drop_file_table(rowid,table_name);});
}

function process_drop_file_table(rowid,table_name){
 gDB.transaction(
  function(t) {
   t.executeSql('delete from vf_tables where rowid=?', [rowid]);
   t.executeSql('drop table if exists '+sanitise(table_name), []);
     },$L,list_fileimports);
}

function filelist_reset() {
 $I("filelist_summary").innerHTML='';
 $I("filelist_progress").innerHTML='';
 $I("filelist_results").innerHTML='';
 $I("filelist_results_smallscreen").innerHTML='';
 $I("filelist_save_progress").innerHTML='';
 $I("filedescription").innerHTML='';
 $I("filetablename").value='';
 //$I("filecharset").value='UTF-8'
 $I("fileskiplines").value='0';
 $I("filesep").options[0].selected=true;
 $I("filecustomsep").value="";
 $I("filecustomsep").disabled=true;
 $I("filedelim").options[0].selected=true;
 $I("filecustomdelim").value="";
 $I("filecustomdelim").disabled=true;
 $I("fileheader").checked=true;
 $I("fileasnull").checked=true;
 $I("filetabletemp").checked=false;
 $I("filetaskid").value='';
 $I("fileauto").checked=false;
 $I("fileextract").innerHTML=''
 //gTHE_READ_FILE=null;
}

function filelist_save() {
 update_only_file_table_metadata();
}

function handle_filelist(mode, rowid) {
 if (mode == 'drop') {
  drop_file_table(rowid);
  return;
 }
 if (mode == 'edit') {
  search_file_table_rowid(rowid);
  return;
 }
}




/* ----- Begin CSV Parsing support functions ----- */

function cleanse(string1, empty_as_null) {
 return string1||((empty_as_null>0)?null:'');
}

function cleanse_record_set(data,empty_as_null) {
 var result=[];
 for (i=0; i<data.length; i++) {
  result[i]=[];
  for (j=0; j<data[i].length; j++)
    result[i][j]=cleanse(data[i][j],empty_as_null);
 }
 return result;
};

function chunked_csv_reader(md, initial_offset, offset, chunk_size) {
 if (!chunk_size) chunk_size=10000;
 if (!offset) offset=(md.header_row)?1:0;
 if (!initial_offset) initial_offset=(md.header_row)?1:0;
 if (!gALL_DATA[md.table_name].raw_lines) return null;
 var upper_bound = Math.min(offset+chunk_size, gALL_DATA[md.table_name].row_count);
 var chunked_rows = [];
 for (var i=offset; i<upper_bound; i++) {
 try {
  var row= jQuery.csv.toArray(gALL_DATA[md.table_name].raw_lines[i],{separator: md.separator, delimiter: md.delimiter});
  var cleansed_row = [];
  for (var j=0; j<row.length; j++)
   cleansed_row.push(cleanse(row[j],md.empty_as_null));
   chunked_rows.push(cleansed_row);
    }
  catch(e) {
   // CSV parse error
   gALL_DATA[md.table_name].failures++;
   }
  }
 return chunked_rows;
}

// load_parsed_file - Loads entire parsed CSV
function load_parsed_file(md, offset, state, browse) {
 var starting_offset=((md.header_row)?1:0);
 var total_rows=0;
 if (gALL_DATA[md.table_name])
  total_rows=gALL_DATA[md.table_name].row_count-starting_offset;
 if (offset>=(total_rows+starting_offset)) { 
  gALL_DATA[md.table_name].status='Loaded';
  update_status();
  // Run assigned file task, browse or next task in sequence.
  // File assigned task has precedence over Browse (for drag/dop start task)
  // Sequence has precedence over Browse
  if (md.file_task_id)
   sequence_execute(md.file_task_id);
  if (state) {
   next_task(state);
   return;
  }
  if (browse) {
   go_browse(md.table_name);								  
   return;
  }
  return;
 }
 if ((offset==null)||(offset=='Initialise')) {
  gALL_DATA[md.table_name].failures=0;
  gALL_DATA[md.table_name].status='Initialising';
  gALL_DATA[md.table_name].load_value=0;
  total_rows=gALL_DATA[md.table_name].row_count;
  update_status();
  load_parsed_file(md,starting_offset,state,browse);
  return;
 }
 gALL_DATA[md.table_name].status="Importing";
 update_status();
 var next_offset=Math.min((total_rows+starting_offset),offset+1);
 var the_insert="insert into "+sanitise(md.table_name)+" values ";  
 var the_placeholders=generate_placeholders(md.table_columns.length);
 var batch_size=parseInt((999/md.table_columns.length)-1);  // 999/(column count)
 var batch_index=0;
 var all_placeholders='';
 var all_values=[];
 gDB.transaction(
  function(t) {
   for (var i=offset;i<gALL_DATA[md.table_name].row_count;i++){ 
    var fields= gALL_DATA[md.table_name].parsed_data[i];
    batch_index++;
    if (all_placeholders!="")
     all_placeholders+=','+the_placeholders
    else
      all_placeholders=the_placeholders;
    for (let f=0;f<md.table_columns.length;f++){
      all_values.push(fields[f]);
     }
    if (batch_index >= batch_size) {
     t.executeSql(the_insert+all_placeholders, all_values, 
                  function(tx,results){load_file_row(tx,results,md);}, 
                  function(tx,err){load_file_error(tx,err,md);});
     next_offset=i+1;
     return;
    }
  } // For loop
  // Run residual
  if (batch_index>0){
    t.executeSql(the_insert+all_placeholders, all_values, 
                 function(tx,results){load_file_row(tx,results,md);}, 
                 function(tx,err){load_file_error(tx,err,md);});
    next_offset=gALL_DATA[md.table_name].row_count+1;
    return;
      }
 }, function(e) {load_file_tx_err(e,md);},
    function(){window.setTimeout(function(){load_parsed_file(md,next_offset,state,browse);},0)});
}

//  Iterative CSV loader - line-by-line parsing (for large files)
function load_file_chunked(md, offset, browse, state) {
 var starting_offset=(md.header_row)?1:0;
 var commit_size=5000;
 var total_rows=0;
 if (gALL_DATA[md.table_name].raw_lines)
  total_rows = gALL_DATA[md.table_name].row_count - starting_offset;
 if (offset>=(total_rows+1)) {
   gALL_DATA[md.table_name].status='Loaded';
   update_status();
   // Run assigned file task, browse or next task in sequence.
   // File assigned task has precedence over Browse (for drag/dop start task)
   // Sequence has precedence over Browse
   if (md.file_task_id)
    sequence_execute(md.file_task_id);
   if (state) {
    next_task(state);
    return;
   }
   if (browse) {
    go_browse(md.table_name);								  
    return;
   }
  return;
 }
 if ((offset==null)||(offset=='Initialise')) {
  gALL_DATA[md.table_name].failures=0;
  gALL_DATA[md.table_name].status='Initialising';
  update_status();
  load_file_chunked(md, starting_offset, browse, state);
  return;
 }
 gALL_DATA[md.table_name].status="Importing";
 update_status();
 var payload = chunked_csv_reader(md,starting_offset,offset,commit_size);
 var next_offset = Math.min((total_rows+1), offset+commit_size);
 if (!payload)
  load_file_chunked(md, next_offset, browse, state); 
 var the_insert="insert into "+sanitise(md.table_name)+" values "; 
 var the_placeholders= generate_placeholders(md.table_columns.length);
 var batch_size = parseInt((999/md.table_columns.length)-1);  // 999/(column count)
 var batch_index=0;
 var all_placeholders="";
 var all_values=[];
 gDB.transaction(
  function(t) {
    for (var i=0; i<payload.length; i++) { 
     var fields= payload[i];
     batch_index++;
     if (all_placeholders!="")
      all_placeholders+= ','+the_placeholders
     else
       all_placeholders= the_placeholders;
     for (let f=0; f<md.table_columns.length; f++) {
       all_values.push(fields[f]);
      }
     if (batch_index >= batch_size) {
      t.executeSql(the_insert+all_placeholders, all_values, 
                   function(tx, results) { load_file_row(tx, results, md); }, 
                   function(tx, err) { load_file_error(tx, err, md); });
      batch_index=0;
      all_placeholders="";
      all_values=[];
     }
   } // For loop
  // Run residual
  if (batch_index > 0) {
    t.executeSql(the_insert+all_placeholders, all_values, 
                 function(tx, results) { load_file_row(tx, results, md); }, 
                 function(tx, err) { load_file_error(tx, err, md); }  );
      }

  }, function(e) { load_file_tx_err(e, md); }, function() { 
	  window.setTimeout(function() { load_file_chunked(md, next_offset, browse, state); }, 0);  
                                                          });
}

function load_file_row(tx,results,md){
 gALL_DATA[md.table_name].load_value+=results.rowsAffected;
 if ((gALL_DATA[md.table_name].load_value%5000)<results.rowsAffected){
  gALL_DATA[md.table_name].status='Importing';
  update_status();
 }
}

function load_file_error(tx,err,md){
 gALL_DATA[md.table_name].failures++;
}

function load_file_tx_err(e,md){
 gALL_DATA[md.table_name].error_msg=escHTML(e.message);
 gALL_DATA[md.table_name].status='Failed';
 update_status();
}

function cr_table_creation_script(is_temp, table_name, the_columns) {
 var SQL='create ';
 if (is_temp)
  SQL+= 'temp ';
 SQL+= 'table if not exists '+sanitise(table_name)+'(';
 for (let i=0;i<the_columns.length;i++){
  SQL+=sanitise(the_columns[i]);
  SQL+=' TEXT';
  if (i<the_columns.length-1) SQL+= ',';
  }
 SQL+= ')';
 return SQL;
}

function sanitise(str) {
 var res=str.replace(/"/g,'""');
 return '"'+res+'"';
}

function unsanitise(str) {
 var res=str;
 var s=str.match(/^"/);
 if (s) res=res.substring(1,res.length);
 var s=str.match(/"$/);
 if (s) res=res.substring(0,res.length-1);
 res=res.replace(/""/g,'"');
 return res;
}

function generate_placeholders(len) {
 var PLC='(';
 for (let i=0;i<len;i++) {
  PLC+='?';
  if (i<len-1) PLC+= ',';
  }
 PLC+= ')';
 return PLC;
}

function make_columns(row){
 if (!row) return null;
 var unnamed=[];
 if (row) {
  for (var i=0;i<row.length;i++) 
   unnamed.push('F'+(i+1).toString());
  return unnamed;
  }
 return null;
}

// data_parse - Used for full standards CSV parsing (suitable for small files)
function data_parse(table_name, md, callback) {
 var text=gALL_DATA[table_name].raw_data;
 var opts={};
 if (md.separator) opts["separator"]=md.separator;
 if (md.delimiter) opts["delimiter"]=md.delimiter;
 try {
  jQuery.csv.toArrays(text,opts,function(err,data){if(err) $L(err); callback(data);});
 } catch(e) { 
  gALL_DATA[table_name].status='Error';
  gALL_DATA[table_name].error_msg= e.message;
  update_status();
 }
}

function skip_lines(raw_lines, offset) {
 try {
  for (var i=0;i<offset;i++) 
   raw_lines.shift();
 } catch(e) {return null;};
 return raw_lines;
}

function get_columns(first_line, headers, sep, delim) {
 var opts={};
 if (sep) opts["separator"]=sep;
 if (delim) opts["delimiter"]=delim
 var row=jQuery.csv.toArray(first_line,opts);
 if (headers) return row;
 else return make_columns(row);
}


/* ----- End CSV Parsing support functions ----- */




/* ----- Begin File and URL fetch support functions ----- */

function clear_import_lists() {
 $I('filelist_progress').innerHTML='';
 $I('filelist_summary').innerHTML='';
 $I('filelist_results').innerHTML='';
 $I('filelist_results_smallscreen').innerHTML='';
}

function url_progress(msg) {
 let qs=document.querySelectorAll('.urlprogress');
 qsHtml(qs,msg);
}

// URL fetcher
async function url_fetch(preview,state,browse){
 if ((gDOWNLOAD_IN_PROGRESS)&&(!state)) {
  notify("There is a download in progress.");
  return;
 }
 gDOWNLOAD_IN_PROGRESS= false;
 var the_url=$I('urlurl').value;
 if (!the_url) return;
 if ((!preview)&&(!$I('urltablename').value)) {
  notify("Please specify Destination Table");
  return;
 }
 var the_headers={};
 var name1=$I('urlheadername1').value;
 if (name1)
  the_headers[name1]=$I('urlheadervalue1').value;
 var name2=$I('urlheadername2').value;
 if (name2)
  the_headers[name2]=$I('urlheadervalue2').value;
 url_progress(gSPIN);
 gDOWNLOAD_IN_PROGRESS=true;
 var response;
 try {
  response=await fetch(the_url,{headers: the_headers});
     }
 catch(e) {
  url_progress(e);
  gDOWNLOAD_IN_PROGRESS=false;
  return;
         };
 const reader = response.body.getReader();
 const contentLength = +response.headers.get('Content-Length');
 var content_type="";
 for(let entry of response.headers.entries()) {
  if (entry[0].toUpperCase()=='CONTENT-TYPE')
   content_type=entry[1];
 }	
 // read the data
 let receivedLength=0; 
 let chunks=[];
 while(true) {
  const {done, value} = await reader.read();
  if (done) break;
  chunks.push(value);
  receivedLength+=value.length;
  download_progress(receivedLength, contentLength);
 }
 gDOWNLOAD_IN_PROGRESS= false;
 // concatenate chunks into single Uint8Array
 let chunksAll=new Uint8Array(receivedLength);
 let position=0;
 for(let chunk of chunks) {
  chunksAll.set(chunk,position); 
  position+=chunk.length;
  download_progress(position, receivedLength);
 }

 chunked_url_reader(chunksAll, preview, content_type, receivedLength, state, browse);
}

function make_preview(raw_lines) {
 var osilit='';
 var preview='';
 for (var i=0; i<raw_lines.length; i++) {
  if (preview) preview+= '\n';
  preview+='<span style="color:blue; font-weight: bolder; background: lightyellow;">'+
	    parseInt(i+1).toString()+
	    '</span>&nbsp;'+
	    escHTML(raw_lines[i]);
  if (preview.length>4000) break;
     }
 if (preview.length>4000)
  osilit=' <span style="color:green;"> ...<em>more</em>... </span>';
 var s=preview.substr(0,5000);
 return s+osilit;
}

function is_small_file(raw_lines) {
 const full_size=parseInt(gMAX_FILE_SIZE_MB_FOR_FULL_PARSE*1024*1024);
 var sz=0;
 for (var i=0; i<raw_lines.length; i++) {
  sz+=raw_lines[i].length;
  if (sz>full_size) return false;
 }
 return true;
}

function re_combine(raw_lines) {
 var output='';
 for (var i=0; i<raw_lines.length; i++) {
  if (output) output+='\n';
  output+=raw_lines[i];
 }
 return output;
}

function download_progress(sofar,total){
 var mb=sofar/(1024*1024);
 var prog='';
 if (total)
  prog='<progress max="'+total+'" value="'+sofar+'"></progress>';
 msg=prog+'&nbsp;'+mb.toFixed(2)+' Mb';
 url_progress(msg);
}

function prepare_url_load_for_import(raw_lines,content_type,file_size,state,browse) {
 var table_name=$I("urltablename").value;
 var file_separator=$I("urlsep").value;
 var file_custom_separator=$I("urlcustomsep").value;
 var file_delimiter=$I("urldelim").value;
 var file_custom_delim=$I("urlcustomdelim").value;
 var separator=((file_separator=="Custom")?file_custom_separator:file_separator);
 var delimiter=((file_delimiter=="Custom")?file_custom_delim:file_delimiter);
 var file_skip_lines=$I("urlskiplines").value;
 var header_row=(($I("urlheader").checked)?1:0);
 var empty_as_null=(($I('urlasnull').checked)?1:0);
 var prelim_metadata=
   {"table_name":table_name,
    "separator":separator,
    "delimiter":delimiter,
    "skip_lines":file_skip_lines};
 //Reset Metadata
 gALL_DATA[table_name]={};
 gALL_DATA[table_name].status='Splitting';
 gALL_DATA[table_name].row_count=0;
 gALL_DATA[table_name].load_value=0;    
 gALL_DATA[table_name].failures=0;    
 gALL_DATA[table_name].parsed_data=null;
 gALL_DATA[table_name].raw_lines=skip_lines(raw_lines,(file_skip_lines||0));
 gALL_DATA[table_name].raw_data=null;
 update_status();
 if (!is_small_file(gALL_DATA[table_name].raw_lines)) {
  // Using iterative line-by-line parser (large input file)
  gALL_DATA[table_name].row_count=raw_lines.length;
  var first_row=gALL_DATA[table_name].raw_lines[0];
  var table_columns=get_columns(first_row,header_row,separator,delimiter);
  if (!table_columns) {
   notify('Unable to determine columns from dataset. (Check "Skip Lines" is not set too high).');
  return;
  } else {
   gALL_DATA[table_name].table_columns=table_columns;
   prelim_metadata.table_columns=table_columns;
 };
 create_url_table_metadata(table_name,null,null,state,browse);
 } else {
  // Using full ISO csv parser (small input file)
  update_status();
  gALL_DATA[table_name].raw_data=re_combine(gALL_DATA[table_name].raw_lines);
  window.setTimeout(
   function(){data_parse(table_name,
	                prelim_metadata,
	                function(data){
				var cleansed_data;
				if (empty_as_null)
				 cleansed_data=cleanse_record_set(data,empty_as_null);
				else
				 cleansed_data=data;
				prepare_for_import(table_name,
				                   cleansed_data,
				                   content_type,
				                   file_size,
				                   state,
				                   browse);
			              }
                       );
           },
           1);
 }
}

function prepare_for_import(table_name,parsed_data,content_type,file_size,state,browse) {
 gALL_DATA[table_name].parsed_data=parsed_data;
 gALL_DATA[table_name].row_count=parsed_data.length;
 create_url_table_metadata(table_name,content_type,file_size,state,browse);
}

function create_url_table_metadata(table_name,content_type,file_size,state,browse){
 var table_name=$I("urltablename").value;
 var uri=$I("urlurl").value;
 var file_type = content_type;
 //var file_charset = $I("urlcharset").value;  //Future Implementation
 var file_separator = $I("urlsep").value;
 var file_custom_separator = $I("urlcustomsep").value;
 var file_delimiter=$I("urldelim").value;
 var file_custom_delim=$I("urlcustomdelim").value;
 var file_skip_lines=$I("urlskiplines").value;
 var header_row=(($I("urlheader").checked)?1:0);
 var empty_as_null=(($I("urlasnull").checked)?1:0);
 var is_temp=(($I("urltabletemp").checked)?1:0);
 var url_task_id=$I("urltaskid").value;
 var url_max_age=$I("urlmaxage").value;
 var url_header_name1=$I("urlheadername1").value;
 var url_header_value1=$I("urlheadervalue1").value;
 var url_header_name2=$I("urlheadername2").value;
 var url_header_value2=$I("urlheadervalue2").value;
 var last_refresh = null;
 var separator=((file_separator=='Custom')?file_custom_separator:file_separator);
 var delimiter=((file_delimiter=='Custom')?file_custom_delim:file_delimiter);
 var the_columns=null;
 var offset=(parseInt(Math.abs(file_skip_lines))||0);
 //Get header line
 var the_columns=null;
 if (!gALL_DATA[table_name].table_columns) {
  var first_row=gALL_DATA[table_name].parsed_data[0];
  the_columns=((header_row>0)?first_row:make_columns(first_row));
  if (!the_columns) {
   notify('Unable to determine columns from dataset. (Check "Skip Lines" is not set too high).');
   return;
  }
 } else 
  the_columns=gALL_DATA[table_name].table_columns;
 var ALL_COLUMNS=JSON.stringify(the_columns);
 var NO_COLUMNS=JSON.stringify([]);
 var cr_table_sql=null;
 if (the_columns)
  cr_table_sql=cr_table_creation_script(is_temp,table_name,the_columns);
 var table_import_metadata =
   {"table_name": table_name,
    "separator": separator,
    "delimiter": delimiter,
    "skip_lines": file_skip_lines,
    "header_row": header_row,
    "empty_as_null": empty_as_null,
    "table_columns": the_columns,
    "file_task_id": null};
 // Conditionally update last refresh
 var THIS_REFRESH= JSON.stringify(new Date());
 gDB.transaction(
  function(t) {
    // Reconstruct metadata if not being called non-interactively
    if (!state) {
     t.executeSql("delete from VF_TABLES where table_name = ?", [table_name]);
     t.executeSql("insert into VF_TABLES(TABLE_TYPE, TABLE_NAME, FILE_SIZE, URI, "+
                                       "FILE_TYPE, CHARSET, DELIMITER, CUSTOM_DELIMITER, SEPARATOR, CUSTOM_SEPARATOR,"+
                                       "SKIP_FIRST_LINES, HEADER_ROW, EMPTY_AS_NULL, IS_TEMP, URI_CACHE_MAX_AGE, URI_HEADER_NAME1,"+
                                       "URI_HEADER_VALUE1, URI_HEADER_NAME2, URI_HEADER_VALUE2, URI_TASK_ID,"+
                                       "LAST_TABLE_REFRESH, ALL_TABLE_COLUMNS, HIDDEN_TABLE_COLUMNS, DISPLAY_TABLE_COLUMNS) "+
                               "values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
                               ["URL",
                                table_name,
                                file_size,
                                uri,
                                file_type,
                                "UTF-8", //Future Implementation
                                file_delimiter,
                                file_custom_delim,
                                file_separator,
                                file_custom_separator,
                                file_skip_lines,
                                header_row,
                                empty_as_null,                                 
                                is_temp,
                                url_max_age,
                                url_header_name1,
                                url_header_value1,
                                url_header_name2,
                                url_header_value2,
                                url_task_id,
                                THIS_REFRESH,
                                ALL_COLUMNS,
                                NO_COLUMNS,
                                ALL_COLUMNS]);
                }
   else { 
    t.executeSql('update VF_TABLES set last_table_refresh=? where table_name=?',[THIS_REFRESH,table_name]);
   };
  if (cr_table_sql) {
   t.executeSql("drop table if exists "+sanitise(table_name));
   t.executeSql(cr_table_sql);
  };
                 }, urltable_error,function(){start_url_import(table_import_metadata, state, browse);});
}
       
function start_url_import(md,state,browse){
 if (!is_small_file(gALL_DATA[md.table_name].raw_lines)) 
  load_file_chunked(md,'Initialise',browse,state);
 else
  load_parsed_file(md,'Initialise',state,browse); 
}

function urltable_error(e,t) {
 var msg='<span class="error">'+escHTML(e.message)+'</span>';
 $I("urllist_summary").innerHTML=msg;
}

function list_urlimports() {
 $I("urllist_summary").innerHTML='';
 $I("urllist_progress").innerHTML=gSPIN;
 $I("urllist_results").innerHTML='';
 $I("urllist_results_smallscreen").innerHTML='';
 $I("urllist_summary").innerHTML='';
 gDB.transaction(function (t) {
  t.executeSql("select rowid, table_name, uri, last_table_refresh, uri_task_id "+
               "from vf_tables where table_type='URL' order by table_name", [],
   function (tx, r) {
    var shown='';
    if (r.rows.length>gUNPAGINATED_MAX_ROWS)
     shown='(displaying <b>'+gUNPAGINATED_MAX_ROWS+'</b>)';
    $I('urllist_summary').innerHTML='Found <b>'+parseInt(r.rows.length)+'</b> saved URL Import Tables '+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td>Table</td><td>URL</td><td>Last Refresh</td>'+
		    '<td>Task Id</td><td>Edit</td><td>Import + Browse</td><td>Drop</td></tr>';
     $I('urllist_results').innerHTML=msg;
                                     };
    for (var i=0;i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS);i++){
     let row_results='<tr class="rs"><td>'+escHTML(r.rows.item(i).TABLE_NAME)+'</td>'+
	      '<td>'+escHTML(r.rows.item(i).URI)+'</td>'+
	      '<td>'+escHTML(JSON.parse(r.rows.item(i).LAST_TABLE_REFRESH))+'</td>'+ 
	      '<td>'+escHTML(r.rows.item(i).URI_TASK_ID)+'</td>'+
              '<td><button title="Edit" onclick="'+escATTR('handle_urllist(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
              '<td><button title="Run" onclick="'+escATTR('handle_urllist(\'redo\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
	      '<td><button title="Drop" onclick="'+escATTR('handle_urllist(\'drop\','+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
     $I('urllist_results').innerHTML+= row_results;
     let row_smallscreen='<tr class="rs"><td><dl>'+
      '<dt class="hdrg">Table</dt>'+
      '<dd>'+escHTML(r.rows.item(i).TABLE_NAME)+'</dd>'+
      '<dt class="hdrg">URL</dt>'+
      '<dd>'+escHTML(r.rows.item(i).URI)+'</dd>'+
      '<dt class="hdrg">Last Refresh</dt>'+
      '<dd>'+escHTML(JSON.parse(r.rows.item(i).LAST_TABLE_REFRESH))+'</dd>'+
      '<dt class="hdrg">Task Id</dt>'+
      '<dd>'+escHTML(r.rows.item(i).URI_TASK_ID)+'</dd>'+
      '<dt class="hdrg">Action</dt>'+
      '<dd><button title="Edit" onclick="'+escATTR('handle_urllist(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
          '<button title="Run" onclick="'+escATTR('handle_urllist(\'redo\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
          '<button title="Drop" onclick="'+escATTR('handle_urllist(\'drop\','+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
      '</dd></dl></td></tr>';
     $I('urllist_results_smallscreen').innerHTML+= row_smallscreen;
                              }
                    })
				 },$L,urllist_loaded);
}

function urllist_loaded() {
 $I("urllist_progress").innerHTML='';
}

function drop_url_table(rowid) {
 $I("urllist_progress").innerHTML=gSPIN;
 $I("urllist_summary").innerHTML='';
 var table_name="";
 gDB.transaction(
  function(t) {
   t.executeSql("select table_name from vf_tables where rowid=?",[rowid],
    function (tx, r) {table_name=r.rows.item(0).TABLE_NAME;});
     },no_such_table,function(){process_drop_url_table(rowid,table_name);});
}

function no_such_table(e,t) {
 notify("No such table");
}

function process_drop_url_table(rowid,table_name){
 gDB.transaction(
 function(t) {
  t.executeSql('delete from vf_tables where rowid=?',[rowid]);
  t.executeSql('drop table if exists '+sanitise(table_name),[]);
    },$L,list_urlimports);
}

function urllist_save() {
 update_url_table();								
}

function search_url_table_rowid(rowid,and_import,browse) {
 set_visible_pane('urlimport'); //May be called from "Browse"
 var url_md={};
 gDB.transaction(
  function(t) {
   t.executeSql("select t.* from VF_TABLES t where rowid = ?;", [rowid],
    function (tx, r) {
     if (r.rows.length > 0) {
      // Found record
      var i=0;
      var tup=r.rows.item(i); 
      url_md={"table_name": tup.TABLE_NAME,
              "uri": tup.URI,
              "charset": tup.CHARSET,
              "delimiter":  tup.DELIMITER,
              "custom_delimiter": tup.CUSTOM_DELIMITER,
              "separator": tup.SEPARATOR,
              "custom_separator": tup.CUSTOM_SEPARATOR,
              "skip_lines": (tup.SKIP_FIRST_LINES||0),
              "header_row": tup.HEADER_ROW,
              "empty_as_null": tup.EMPTY_AS_NULL,
              "uri_task_id": tup.URI_TASK_ID,
              "uri_max_age": tup.URI_CACHE_MAX_AGE,
              "is_temp": tup.URL_IS_TEMP,
              "uri_header_name1": tup.URI_HEADER_NAME1,
              "uri_header_value1": tup.URI_HEADER_VALUE1,
              "uri_header_name2": tup.URI_HEADER_NAME2,
              "uri_header_value2": tup.URI_HEADER_VALUE2
             };
                 }
                      });
                 },$L,function(){found_url_table(url_md,and_import,browse);});
}
       

function found_url_table(md,and_import,browse){
 $I("urltablename").value=md.table_name;
 $I("urlurl").value=md.uri;
 //$I("urlcharset").value=md.charset; //Future Implementation
 $I("urlsep").value=md.separator;
 $I("urlcustomsep").value=md.custom_separator;
 $I("urldelim").value=md.delimiter;
 $I("urlcustomdelim").value=md.custom_delimiter;
 $I("urlskiplines").value=md.skip_lines;
 $I("urlheader").checked= (md.header_row ?true:false);
 $I("urlasnull").checked=(md.empty_as_null?true:false);
 $I("urltabletemp").checked=(md.is_temp?true:false);
 $I("urltaskid").value=md.uri_task_id;
 $I("urlmaxage").value=md.uri_max_age;
 $I("urlheadername1").value=md.uri_header_name1;
 $I("urlheadervalue1").value=md.uri_header_value1;
 $I("urlheadername2").value=md.uri_header_name2;
 $I("urlheadervalue2").value=md.uri_header_value2;
 if (and_import)
  url_fetch(false,null,browse);
};

function update_url_table(){
 var table_name=$I("urltablename").value;
 if (!table_name){
  notify("Table Name is Required");
  return;
 }
 $I("urllist_save_progress").innerHTML=gSPIN;
 var uri=$I("urlurl").value;
 //var file_charset = $I("urlcharset").value; //Future Implementation
 var file_separator=$I("urlsep").value;
 var file_custom_separator=$I("urlcustomsep").value;
 var file_delimiter=$I("urldelim").value;
 var file_custom_delim=$I("urlcustomdelim").value;
 var file_skip_lines=$I("urlskiplines").value;
 var header_row=(($I("urlheader").checked)?1:0);
 var empty_as_null=(($I("urlasnull").checked)?1:0);
 var is_temp=(($I("urltabletemp").checked)?1:0);
 var uri_task_id=$I("urltaskid").value;
 var uri_max_age=$I("urlmaxage").value;
 var uri_header_name1=$I("urlheadername1").value;
 var uri_header_value1=$I("urlheadervalue1").value;
 var uri_header_name2=$I("urlheadername2").value;
 var uri_header_value2=$I("urlheadervalue2").value;
 var last_refresh=null;
 var separator = (file_separator=="Custom")?file_custom_separator:file_separator;
 var delimiter = (file_delimiter=="Custom")?file_custom_delim:file_delimiter;
 gDB.transaction(
  function(t) {
   // Handle the case where the table_name is changed 
   t.executeSql("insert into VF_TABLES(table_type, table_name, uri, charset, delimiter, custom_delimiter, separator, custom_separator, "+
                                       "skip_first_lines, header_row, empty_as_null, is_temp, uri_task_id, uri_cache_max_age, uri_header_name1, "+
                                       "uri_header_value1, uri_header_name2, uri_header_value2) select ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? "+
               "where not exists (select 1 from vf_tables where table_name = ?)",
	       ['URL',
		table_name,
		uri,
                'UTF-8',
                file_delimiter,
                file_custom_delim,
                file_separator,
                file_custom_separator,
                file_skip_lines,
                header_row,
                empty_as_null,                                 
                is_temp,
                uri_task_id,
                uri_max_age,
                uri_header_name1,
                uri_header_value1,
                uri_header_name2,
                uri_header_value2,
		table_name ]);
     t.executeSql("update VF_TABLES set "+
                  "uri = ?, "+
                  "delimiter = ?, "+
                  "custom_delimiter = ?, "+
                  "separator =  ?, "+
                  "custom_separator = ?, "+
                  "skip_first_lines = ?, "+
                  "header_row = ?, "+
                  "empty_as_null = ?, "+
                  "is_temp = ?, "+
                  "uri_task_id = ?, "+
                  "uri_cache_max_age = ?, "+
                  "uri_header_name1 = ?, "+
                  "uri_header_value1 = ?, "+
                  "uri_header_name2 = ?, "+
                  "uri_header_value2 = ? "+
                  "where table_name = ?",
                               [uri,
                                file_delimiter,
                                file_custom_delim,
                                file_separator,
                                file_custom_separator,
                                file_skip_lines,
                                header_row,
                                empty_as_null,                                 
                                is_temp,
                                uri_task_id,
                                uri_max_age,
                                uri_header_name1,
                                uri_header_value1,
                                uri_header_name2,
                                uri_header_value2,
                                table_name]);
         },$L,function(){url_post_update();});
}

function url_post_update() {								
 tick_fade('urllist_save_progress');
 list_urlimports();
}

function handle_urllist(mode, rowid) {
 if (mode=='drop') {
  drop_url_table(rowid);
  return;
 }
 if (mode=='edit') {
  search_url_table_rowid(rowid,false,false);
  return;
 }
 if (mode=='redo') {
  search_url_table_rowid(rowid,true,true);
  return;
 }
}

function url_table_enter(event) {
 if (event.which===13 || 
     event.keyCode===13 || 
     event.key==="Enter")  {
 var table_name=$I("urltablename").value;
 if (table_name) url_fetch(false,null,true);
 }
}

function file_table_enter(event) {
 if (event.which===13 || 
     event.keyCode===13 || 
     event.key==="Enter")  {
 var table_name=$I("filetablename").value;
 if (table_name) create_file_table_metadata(false,true,null);
 }
}

/* ----- End File and URL fetch support functions ----- */


/* ----- Begin SQL Execute ----- */

function sql_progress(stat) {
 var msg=((stat)?gSPIN:'');
 let qs=document.querySelectorAll('.sql_progress');
 qsHtml(qs,msg);
}

function sql_summary(msg) {
 let qs=document.querySelectorAll('.sql_summary');
 qsHtml(qs,msg);
}

function sql_run_execute(){
 $I("sql_label").value='';
 sql_execute();
}

function sql_execute(offset,as_history,context,state) {
 var sql_statement=$I('sql_input').value.trim();
 if (sql_statement=='') {
  notify('A statement is required');
  return; 
 };

 $I("sql_results").innerHTML='';
 $I("sql_results_smallscreen").innerHTML='';
 sql_summary('');
 $I("sql_navigation").innerHTML='';
 $I("sql_save_progress").innerHTML='';
 $I("sql_csv_button").style.display="none";
 if (state) set_visible_pane('sql');
 $I('sql_csv_button').style.display="none";

 sql_progress(true);

 var page_size=parseInt(get_simple_value('CONFIG_PAGE_SIZE'));
 if (!page_size) page_size=50;

 var vOFFSET=parseInt(offset);
 if (!vOFFSET) vOFFSET=0;

 gDB.transaction(function (t) {
  t.executeSql($I("sql_input").value,[],
    function(tx,r){
     if (!context){
      if (parseInt(r.rows.length)>0){
       if (vOFFSET>r.rows.length) vOFFSET=r.rows.length;
       var vRES1=parseInt(vOFFSET+1);
       var vLIMIT=Math.min(vOFFSET+page_size,r.rows.length);
       sql_summary("Results <b>"+vRES1+"</b> - <b>"+vLIMIT+"</b> of <b>"+r.rows.length+"</b>");
       var vTOTAL_PAGES= Math.ceil(r.rows.length/page_size);
       var vCURRENT_PAGE= Math.floor(vOFFSET/page_size);
       var vROWS_DISPLAYED= parseInt(vLIMIT-vOFFSET);
       if (vROWS_DISPLAYED < r.rows.length)
        sql_results_navigation('sql_navigation','sql_execute',vTOTAL_PAGES,vCURRENT_PAGE,r.rows.length,vOFFSET,page_size);
       else
        $I('sql_navigation').innerHTML='';
       var row='<tr class="hdr1 bold">';
        for (col in r.rows.item(0)) row+='<td>'+escHTML(col)+'</td>';
       row+='</tr>';
       $I("sql_results").innerHTML+=row;
      }
      else {
       if (r.rowsAffected!=null)
        sql_summary('Rows Affected: <b>'+escHTML(r.rowsAffected)+'</b>');
       else
        sql_summary('No records found.');
      }
     for (var i=vOFFSET; i<vLIMIT; i++) {
      var row='<tr class="rs">';
       for (col in r.rows.item(i)) row+='<td>'+escHTML(r.rows.item(i)[col])+'</td>';
      row+= '</tr>';
      $I("sql_results").innerHTML+=row;
      var row_smallscreen='<tr class="rs"><td><dl>';
      for (col in r.rows.item(i)) {
       row_smallscreen+='<dt class="hdrg">'+escHTML(col)+'</dt><dd>'+escHTML(r.rows.item(i)[col])+'</dd>';
       }
      row_smallscreen+='</dl></td></tr>';
      $I("sql_results_smallscreen").innerHTML+= row_smallscreen;
     }
    if (r.rows.length > 0)
     $I("sql_csv_button").style.display = "inline";
        } // if (!context)
   if (context=='csv') 
    make_csv(r.rows,null,'sql_csv_download_progress','SQL_DATA');
                       },sql_error)
                              },null,function(){sql_loaded(state);});
}

function sql_error(t,e) {
 sql_progress(false);
 $I('sql_results_smallscreen').innerHTML+= '<tr><td class="error">Error: '+escHTML(e.message)+'</td></tr>';
 $I('sql_results').innerHTML+= '<tr><td class="error">Error: '+escHTML(e.message)+'</td></tr>';
}

function sql_loaded(state) {
 sql_progress(false);
 next_task(state);
}

function sql_results_navigation(elem,search_function,total_pages,current_page,total_rows,offset,page_size) {
 var vPREV= Math.floor((current_page-1)*page_size);
 if (vPREV < 0) vPREV=0;
 var vNEXT= Math.floor((current_page+1)*page_size);
 if (vNEXT > total_rows) vNEXT= parseInt(total_rows-offset);
 var vLAST= Math.floor((total_pages-1)*page_size);
 if (vLAST == 0) vLAST=0;
 var vHTML='';

 if (current_page > 0) {
  vHTML+= '<button onclick="'+search_function+'(0);" title="First Page">'+
                 '<i class="fa fa-angle-double-left"></i></button>'+
          '<button onclick="'+search_function+'('+vPREV+');" title="Previous Page">'+
                 '<i class="fa fa-angle-left"></i></button>';
 }

 if (total_pages < 1000) {
  vHTML+= '<select id="sql_select" onchange="sql_offset();">';
  for (var i=0; i<total_pages; i++) {
   if (i == current_page)
    vHTML+= '<option value="'+parseInt(i*page_size)+'" selected="selected">Page</option>';
   else
   vHTML+= '<option value="'+parseInt(i*page_size)+'">'+parseInt(i+1)+'</option>';
  }
  vHTML+= '</select>';
 }

 if (current_page < (total_pages-1)) {
  vHTML+= '<button onclick="'+search_function+'('+vNEXT+');" title="Next Page">'+
                 '<i class="fa fa-angle-right"></i></button>'+
          '<button onclick="'+search_function+'('+vLAST+');" title="Last Page">'+
                 '<i class="fa fa-angle-double-right"></i></button>';
 }

 $I(elem).innerHTML= vHTML;
}

function sql_offset() {
 sql_execute($I("sql_select").value);
}

function save_sql() {
 var qry=$I("sql_input").value;
 var label=$I("sql_label").value;
 var task_id=$I("sql_task_id").value;

 if (!qry) {
  notify('Please enter an SQL statement to save');
  return;
 }
 if (!label) {
  notify('Please enter a Description for this statement');
  return;
 }

 $I('sql_save_progress').innerHTML=gSPIN;
 var now = new Date();
 var save_date = parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
   function(t) {
    t.executeSql("delete from vf_sql where label = ?", [label]);
    t.executeSql("insert into vf_sql(label, date_saved, task_id, statement) values (?,?,?,?)", [label, save_date, task_id, qry]);
               }, null, sql_saved);
}

function sql_saved() {
 tick_fade('sql_save_progress');
 list_saved_sql();
}
  
function list_saved_sql() {
 $I("sql_results").innerHTML='';
 $I("sql_results_smallscreen").innerHTML='';
 sql_summary('');
 $I("sql_navigation").innerHTML='';
 $I('sql_csv_button').style.display="none";
 sql_progress(true);
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, date_saved, statement, task_id from vf_sql order by date(date_saved) desc, label", [],
    function (tx, r) {
     var shown="";
     if (r.rows.length > gUNPAGINATED_MAX_ROWS)
      shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
     sql_summary("Found <b>"+parseInt(r.rows.length)+"</b> saved SQL statements "+shown);
     if (parseInt(r.rows.length)>0) {
      let msg='<tr class="hdr1 bold"><td>Description</td>'+
               '<td>Date Saved</td><td>SQL statement</td><td>Task Id</td>'+
		'<td>Edit</td><td>Run</td><td>Drop</td></tr>';
     $I('sql_results').innerHTML=msg;
                                      };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
      let row_results='<tr class="rs"><td><a class="blk" href="javascript: '+
                          'handle_saved_sql(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run statement">'+
                          escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                          '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).STATEMENT)+'</td>'+
                          '<td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                          '<td><button title="Edit" onclick="'+escATTR('handle_saved_sql(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                          '<td><button title="Run" onclick="'+escATTR('handle_saved_sql(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                          '<td><button title="Drop" onclick="'+escATTR('delete_saved_sql('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
      $I('sql_results').innerHTML+= row_results;
      let row_smallscreen='<tr class="rs"><td><dl>'+
       '<dt class="hdrg">Description</dt>'+
       '<dd><a class="blk" href="javascript:'+
            'handle_saved_sql(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run statement">'+
              escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
       '<dt class="hdrg">Statement</dt>'+
       '<dd>'+escHTML(r.rows.item(i).STATEMENT)+'</dd>'+
       '<dt class="hdrg">Date Saved</dt>'+
       '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
       '<dt class="hdrg">Task Id</dt>'+
       '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
       '<dt class="hdrg">Action</dt>'+
       '<dd><button title="Edit" onclick="'+escATTR('handle_saved_sql(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
            '<button title="Run" onclick="'+escATTR('handle_saved_sql(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
            '<button title="Drop" onclick="'+escATTR('delete_saved_sql('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
       '</dd></dl></td></tr>';
      $I('sql_results_smallscreen').innerHTML+= row_smallscreen;
                              }
                    })
                             }, null, sql_loaded );
}

function delete_saved_sql(rowid) {
 $I('sql_save_progress').innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_sql where rowid = ?", [rowid]);
               }, null, list_saved_sql);
}

function handle_saved_sql(mode, rowid, state) {
 set_visible_pane('sql');
 gDB.transaction(function (t) {
  t.executeSql("select label, statement, task_id from vf_sql where rowid = ?", [rowid],
   function (tx, r) {
    $I('sql_input').value=r.rows.item(0).STATEMENT;
    $I('sql_label').value=r.rows.item(0).LABEL;
    $I('sql_task_id').value=r.rows.item(0).TASK_ID;
                  })
                              }, null, function() { 
		                        if (mode=='execute') 
		                         sql_execute(null,null,null,state); 
		                        //if (mode=='edit')
		                        // set_visible_pane('sql');
		                                  } );
}

function reset_sql() {
 $I('sql_results').innerHTML='';
 $I('sql_results_smallscreen').innerHTML='';
 sql_summary('');
 $I('sql_navigation').innerHTML='';
 $I('sql_save_progress').innerHTML='';
 $I('sql_input').value='';
 $I('sql_label').value='';
 $I('sql_task_id').value='';
 $I('sql_csv_button').style.display="none";
 sql_progress(false);
};

/* ----- End SQL Execute ----- */


/* ----- Begin Sequence support functions ----- */

function clear_sequence_form() {
 $I('sequence_results').innerHTML='';
 $I('sequence_results_smallscreen').innerHTML='';
 $I('sequence_summary').innerHTML='';
 $I('sequence_navigation').innerHTML='';
 $I('sequence_input').value='';
 $I('sequence_description').value='';
 $I('sequence_task_list').value=''; 
 $I('sequence_save_progress').innerHTML='';
 sequence_progress(false);
};

function validate_sequence_list(list) {
 if (!list)
  return false;
 var arr=list.split(',');
  for (let i=0; i<arr.length; i++) {
   if (isNaN(arr[i]))
    return false;
   }
 return true;
}

function save_sequence() {
 var seq= $I("sequence_input").value;
 var label= $I("sequence_description").value;
 var task_list= $I("sequence_task_list").value;
 if (!seq) {
  notify('Please enter a numeric sequence number');
  return;
 }
 if (!label) {
  notify('Please enter a Description for this sequence');
  return;
 }
 if (!validate_sequence_list(task_list)) {
  notify("Please check task list id's is a comma separated list of numeric Id's");
  return;
 }
 $I('sequence_save_progress').innerHTML=gSPIN;
 var now = new Date();
 var save_date = parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_sequence where task_id = ?", [seq]);
   t.executeSql("insert into vf_sequence(label, date_saved, task_id, component_task_ids) values (?,?,?,?)", 
	        [label, save_date, seq, task_list]);
               }, null, sequence_saved);
}

function sequence_saved() {
 tick_fade('sequence_save_progress');
 list_saved_sequences();
}
  
function list_saved_sequences() {
 $I('sequence_results').innerHTML='';
 $I('sequence_results_smallscreen').innerHTML='';
 $I('sequence_summary').innerHTML='';
 $I('sequence_navigation').innerHTML='';
 sequence_progress(true);
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, date_saved, task_id, component_task_ids from vf_sequence "+
               "order by date(date_saved) desc, label asc", [],
   function (tx, r) {
    var shown="";
    if (r.rows.length > gUNPAGINATED_MAX_ROWS)
     shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
    $I('sequence_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved Sequences "+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td>Description</td>'+
             "<td>Date Saved</td><td>Task Id</td><td>Component Task Id's</td><td>Edit</td><td>Run</td><td>Drop</td></tr>";
     $I('sequence_results').innerHTML=msg;
                                    };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
      let row_results='<tr class="rs"><td><a class="blk" href="javascript: '+
                       'handle_sequence(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run sequence">'+
                        escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                       '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                       '<td>'+escHTML(r.rows.item(i).COMPONENT_TASK_IDS)+'</td>'+
                       '<td><button title="Edit" onclick="'+escATTR('handle_sequence(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                       '<td><button title="Run" onclick="'+escATTR('handle_sequence(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                       '<td><button title="Drop" onclick="'+escATTR('delete_sequence('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
      $I('sequence_results').innerHTML+= row_results;
      let row_smallscreen='<tr class="rs"><td><dl>'+
       '<dt class="hdrg">Description</dt>'+
       '<dd><a class="blk" href="javascript: '+
            'handle_sequence(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run sequence">'+
             escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
       '<dt class="hdrg">Date Saved</dt>'+
       '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
       '<dt class="hdrg">Sequence</dt>'+
       '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
       '<dt class="hdrg">Component Task Id\'s</dt>'+
       '<dd>'+escHTML(r.rows.item(i).COMPONENT_TAKS_IDS)+'</dd>'+
       '<dt class="hdrg">Action</dt>'+
       '<dd><button title="Edit" onclick="'+escATTR('handle_sequence(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
           '<button title="Run" onclick="'+escATTR('handle_sequence(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
           '<button title="Drop" onclick="'+escATTR('delete_sequence('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
       '</dd></dl></td></tr>';
        $I('sequence_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
                              }, null, sequence_loaded);
  
}

function delete_sequence(rowid) {
 $I('sequence_save_progress').innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_sequence where rowid = ?", [rowid]);
               }, null, list_saved_sequences);
}

function handle_sequence(action, rowid, state) {
 var the_task_id;
 gDB.transaction(function (t) {
  t.executeSql("select label, task_id, component_task_ids from vf_sequence where rowid = ?", [rowid],
   function (tx, r) {
    the_task_id = r.rows.item(0).TASK_ID;
    $I('sequence_input').value=r.rows.item(0).TASK_ID;
    $I('sequence_description').value=r.rows.item(0).LABEL;
    $I('sequence_task_list').value=r.rows.item(0).COMPONENT_TASK_IDS;
                  })
                              }, null, function() { 
				      if (action=='execute') 
				       sequence_execute(the_task_id,null,null,state); 
				      if (action=='edit') 
				       set_visible_pane('sequence');
			                           } );
}

function sequence_execute(task_id,a,b,state) {
 expand_sequence(task_id);
};

function sequence_progress(stat) {
 $I('sequence_progress').innerHTML=((stat)?gSPIN:'');
}

function sequence_loaded(state) {
 sequence_progress(false);
 next_task(state);
}

function expand_sequence(task_id) {
 expand_sequence_list([task_id],0);
}

function expand_sequence_list(list, offset) {
 let the_offset= offset;
 let the_list= list;
 if (!offset) the_offset=0;
 if (!list) sequence_expansion_error();
 if (the_offset+1 > the_list.length) {
  process_task_list(the_list);
  return;
 };
 var the_task= the_list[the_offset];
 gDB.transaction(function (t) {
  t.executeSql("select component_task_ids from vf_sequence where task_id = ?", [the_task],
   function (tx, r) {
    if (r.rows.length == 0) {
     expand_sequence_list(the_list,the_offset+1);
     return;
    };
    let seq_tasks= r.rows.item(0).COMPONENT_TASK_IDS.split(',');
    let args = [the_offset, 1].concat(seq_tasks);
    Array.prototype.splice.apply(the_list, args);
    if (the_list.length > parseInt(get_simple_value('CONFIG_SEQUENCE_LIMIT'))) {  
     sequence_expansion_error();
     return;
    };
    expand_sequence_list(the_list, the_offset);
                })
                            }, null, null );
}

function process_task_list(list) {
 var state={};
 state.task_list= list;
 state.offset=0;
 run_task_sequence(state); 
};

function sequence_expansion_error() {
 alert("Sequence expansion resulted in more than "+
       get_simple_value('CONFIG_SEQUENCE_LIMIT')+" tasks. "+
       "Please check for possible infinite loops. "+
       "Or increase the Maximum Sequence Expansion limit under Help Config settings.");
}

function next_task(state) {
 if (state) {
  state.db_offset++;
  run_db_task(state);
 }
}

/* ----- End Sequence support functions ----- */

/* ----- Begin Prompt support functions ----- */

function clear_prompt_form() {
 $I('prompt_results').innerHTML='';
 $I('prompt_results_smallscreen').innerHTML='';
 $I('prompt_summary').innerHTML='';
 $I('prompt_navigation').innerHTML='';
 $I('prompt_text').value='';
 $I('prompt_parameter_name').value='';
 $I('prompt_description').value='';
 $I('prompt_task_id').value=''; 
 $I('prompt_save_progress').innerHTML='';
 prompt_progress(false);
};

function save_prompt() {
 var prompt_text=$I('prompt_text').value;
 var prompt_parameter=$I('prompt_parameter_name').value;
 var label=$I('prompt_description').value;
 var task_id=$I('prompt_task_id').value;
 if (!prompt_text) {
  notify('Please enter Prompt Text');
  return;
 }
 if (!prompt_parameter) {
  notify('Please enter the Query String Parameter');
  return;
 }
 if (!label) {
  alert('Please enter a Description for this Prompt');
  return;
 }
 $I('prompt_save_progress').innerHTML=gSPIN;
 var now = new Date();
 var save_date = parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_prompt_input where label = ?", [label]);
   t.executeSql("insert into vf_prompt_input(label, prompt_text, query_string_name, task_id, date_saved) "+
                "values (?,?,?,?,?)", [label, prompt_text, prompt_parameter, task_id, save_date]);
                }, null, prompt_saved);
}

function prompt_saved() {
 tick_fade('prompt_save_progress');
 list_saved_prompts();
}
  
function list_saved_prompts() {
 $I('prompt_results').innerHTML='';
 $I('prompt_results_smallscreen').innerHTML='';
 $I('prompt_summary').innerHTML='';
 $I('prompt_navigation').innerHTML='';
 prompt_progress(true);
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, prompt_text, query_string_name, task_id, date_saved from vf_prompt_input "+
                " order by date(date_saved) desc, label asc", [],
   function (tx, r) {
    var shown="";
    if (r.rows.length > gUNPAGINATED_MAX_ROWS)
     shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
    $I('prompt_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved Prompt Inputs "+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td>Description</td>'+
             "<td>Date Saved</td><td>Task Id</td><td>Prompt Text</td><td>Query String Parameter Name</td>"+
	     "<td>Edit</td><td>Run</td><td>Drop</td></tr>";
     $I('prompt_results').innerHTML=msg;
                                      };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
     let row_results='<tr class="rs"><td><a class="blk" href="javascript: '+
                      'handle_prompt(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Prompt">'+
                      escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                      '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).PROMPT_TEXT)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).QUERY_STRING_NAME)+'</td>'+
                      '<td><button title="Edit" onclick="'+escATTR('handle_prompt(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                      '<td><button title="Run" onclick="'+escATTR('handle_prompt(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                      '<td><button title="Drop" onclick="'+escATTR('delete_prompt('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
     $I('prompt_results').innerHTML+= row_results;
     let row_smallscreen='<tr class="rs"><td><dl>'+
      '<dt class="hdrg">Description</dt>'+
      '<dd><a class="blk" href="javascript: '+
              'handle_prompt(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Prompt">'+
	       escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
      '<dt class="hdrg">Text</dt>'+
      '<dd>'+escHTML(r.rows.item(i).PROMPT_TEXT)+'</dd>'+
      '<dt class="hdrg">Parameter</dt>'+
      '<dd>'+escHTML(r.rows.item(i).QUERY_STRING_NAME)+'</dd>'+
      '<dt class="hdrg">Date Saved</dt>'+
      '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
      '<dt class="hdrg">Task Id</dt>'+
      '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
      '<dt class="hdrg">Action</dt>'+
      '<dd><button title="Edit" onclick="'+escATTR('handle_prompt(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
           '<button title="Run" onclick="'+escATTR('handle_prompt(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
           '<button title="Drop" onclick="'+escATTR('delete_prompt('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
      '</dd></dl></td></tr>';
       $I('prompt_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
                              }, null, prompt_list_loaded );
}

function prompt_list_loaded(state) {
 prompt_progress(false);
}

function delete_prompt(rowid) {
 $I('prompt_save_progress').innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_prompt_input where rowid = ?", [rowid]);
               }, null, list_saved_prompts);
}

function handle_prompt(action, rowid, state) {
 var the_prompt_text;
 var the_prompt_query_string_name;
 gDB.transaction(function (t) {
  t.executeSql("select label, task_id, prompt_text, query_string_name from vf_prompt_input where rowid = ?", [rowid],
   function (tx, r) {
    the_prompt_text=r.rows.item(0).PROMPT_TEXT;
    the_prompt_query_string_name=r.rows.item(0).QUERY_STRING_NAME;
    $I('prompt_text').value=the_prompt_text;
    $I('prompt_description').value=r.rows.item(0).LABEL;
    $I('prompt_parameter_name').value=the_prompt_query_string_name;
    $I('prompt_task_id').value=r.rows.item(0).TASK_ID;
                  })
                              }, null, function() { 
		                  if (action=='execute') 
				    prompt_prefetch(the_prompt_text,the_prompt_query_string_name,null,null,state);
		                  if (action=='edit') 
		                    set_visible_pane('prompt');
		                                   } );
}

function prompt_prefetch(prompt_text,param_name,a,b,state) {
 var the_param_value;
 gDB.transaction(function (t) {
  t.executeSql('select value from VF_QUERY_STRING where name = ? limit 1', [param_name],
   function (tx, r) {
    if (r.rows.length == 0)
     the_param_value='';
    else
     the_param_value= r.rows.item(0).VALUE;
                    })
                              }, null, function() { prompt_prompt(prompt_text,param_name,the_param_value,null,null,state); } );
}

function prompt_prompt(prompt_text, param_name, param_value, a, b, state) {
 var new_val= prompt(prompt_text, param_value);
 if (new_val!=null) {
  gDB.transaction(function (t) {
   t.executeSql('delete from VF_QUERY_STRING where name = ?', [param_name]);
   t.executeSql('insert into VF_QUERY_STRING(name, value) values(?,?)', [param_name, new_val]);
                                }, null, function() { prompt_complete(state); return; } );
  }
 else
  next_task(state);
}

function prompt_complete(state) {
 prompt_progress(false);
 next_task(state);
}

function prompt_progress(stat) {
 $I('prompt_progress').innerHTML=((stat)?gSPIN:'');
}

/* ----- End Prompt support functions ----- */

/* ----- Begin Run Menu support functions ----- */

function clear_menu_form() {
 $I('menu_results').innerHTML='';
 $I('menu_results_smallscreen').innerHTML='';
 $I('menu_summary').innerHTML='';
 $I('menu_navigation').innerHTML='';
 $I('menu_label').value='';
 $I('menu_title').value='';
 $I('menu_relative_order').value='';
 $I('menu_task_id').value=''; 
 $I('menu_save_progress').innerHTML='';
 menu_progress(false);
}

function save_menu() {
 var menu_label=$I('menu_label').value;
 var menu_title=$I('menu_title').value;
 var menu_task_id=$I('menu_task_id').value;
 var menu_relative_order=$I('menu_relative_order').value;
 if (!menu_label) {
  notify('Please enter a Label for this Menu Item');
  return;
 }
 if (!menu_task_id) {
  notify('Please enter a Task Id for this Menu Item');
  return;
 }
 $I('menu_save_progress').innerHTML=gSPIN;
 var now = new Date();
 var save_date=parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_run_menu where label = ?", [menu_label]);
   t.executeSql("insert into vf_run_menu(label, title, task_id, relative_order, date_saved) values (?,?,?,?,?)", 
                [menu_label, menu_title, menu_task_id, menu_relative_order, save_date]);
               }, null, function() { sync_menu(); menu_item_saved(); } );
}

function menu_item_saved() {
 tick_fade('menu_save_progress');
 list_saved_menu_items();
}
  
function list_saved_menu_items() {
 $I('menu_results').innerHTML='';
 $I('menu_results_smallscreen').innerHTML='';
 $I('menu_summary').innerHTML='';
 $I('menu_navigation').innerHTML='';
 menu_progress(true);
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, title, task_id, relative_order, date_saved from vf_run_menu order by relative_order asc", [],
   function (tx, r) {
    var shown="";
    if (r.rows.length > gUNPAGINATED_MAX_ROWS)
     shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
    $I('menu_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved Menu Items "+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td>Label</td>'+
              "<td>Date Saved</td><td>Task Id</td><td>Title</td><td>Relative Order</td>"+
	      "<td>Edit</td><td>Run</td><td>Drop</td></tr>";
     $I('menu_results').innerHTML=msg;
                                      };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
      let row_results='<tr class="rs"><td><a class="blk" href="'+escATTR('javascript:'+
                       'handle_menu(\'execute\','+r.rows.item(i).rowid+');')+'" title="Run Task">'+
                       escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                       '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                       '<td>'+escHTML(r.rows.item(i).TITLE)+'</td>'+
                       '<td>'+escHTML(r.rows.item(i).RELATIVE_ORDER)+'</td>'+
                       '<td><button title="Edit" onclick="'+escATTR('handle_menu(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                       '<td><button title="Run" onclick="'+escATTR('handle_menu(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                       '<td><button title="Drop" onclick="'+escATTR('delete_menu('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
      $I('menu_results').innerHTML+= row_results;
      let row_smallscreen='<tr class="rs"><td><dl>'+
       '<dt class="hdrg">Description</dt>'+
       '<dd><a class="blk" href="'+escATTR('javascript:'+
             'handle_menu(\'execute\','+r.rows.item(i).rowid+');')+'" title="Run Task">'+
              escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
       '<dt class="hdrg">Date Saved</dt>'+
       '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
       '<dt class="hdrg">Task Id</dt>'+
       '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
       '<dt class="hdrg">Title</dt>'+
       '<dd>'+escHTML(r.rows.item(i).TITLE)+'</dd>'+
       '<dt class="hdrg">Relative Order</dt>'+
       '<dd>'+escHTML(r.rows.item(i).RELATIVE_ORDER)+'</dd>'+
       '<dt class="hdrg">Action</dt>'+
       '<dd><button title="Edit" onclick="'+escATTR('handle_menu(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
           '<button title="Run" onclick="'+escATTR('handle_menu(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
           '<button title="Drop" onclick="'+escATTR('delete_menu('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
       '</dd></dl></td></tr>';
       $I('menu_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
                              }, null, menu_list_loaded );
 }

function menu_list_loaded(state) {
 menu_progress(false);
}

function delete_menu(rowid) {
 $I('menu_save_progress').innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_run_menu where rowid = ?", [rowid]);
               }, null, 
                  function() { sync_menu(); list_saved_menu_items(); });
}

function handle_menu(action, rowid, state) {
 var the_menu_label;
 var the_menu_title;
 gDB.transaction(function (t) {
  t.executeSql("select label, title, task_id, relative_order from vf_run_menu where rowid = ?", [rowid],
   function (tx, r) {
    the_menu_label=r.rows.item(0).LABEL;
    the_menu_task_id=r.rows.item(0).TASK_ID;
    $I('menu_label').value=the_menu_label;
    $I('menu_title').value=r.rows.item(0).TITLE;
    $I('menu_task_id').value=the_menu_task_id;
    $I('menu_relative_order').value=r.rows.item(0).RELATIVE_ORDER;
                   })
                              }, null, function() {
		                  if (action=='execute') 
			           run_menu_task(the_menu_task_id,null,null,state); 
		                  if (action=='edit') 
		                   set_visible_pane('run_menu');
		    
		                                  } );
 }

function run_menu_task(task_id,param_name,a,b,state) {
 sequence_execute(task_id);
 // Don't callback any state
}

function menu_progress(stat) {
 $I('menu_progress').innerHTML=((stat)?gSPIN:'');
}

function sync_menu_items(flow) {
 var menu_html='';
 var menu_entries='';
 $I("menu_dropdown").innerHTML='<a><em>No Menu Items Defined</em></a>';
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, title, task_id, relative_order, date_saved from vf_run_menu order by relative_order asc", [],
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     menu_entries+= '<a style="color:blue;" href="'+escATTR('javascript:sequence_execute(\''+r.rows.item(i).TASK_ID+'\');')+'" title="'+
                     escATTR(r.rows.item(i).TITLE)+'">'+escHTML(r.rows.item(i).LABEL)+'</a>';
                                          }
     if (r.rows.length > 0)
      $I('menu_dropdown').innerHTML=menu_entries;
                      }) }, null, function() { post_menu_sync(flow); });
}

function post_menu_sync(flow) {
 if (flow==1) startupPost2(flow);
 if (flow==2) startupPost2(flow);
}
 
function sync_menu() {
 // Simple run menu sync - no flow
 window.setTimeout(function() { sync_menu_items(); }, 1);
}

/* ----- End Run Menu support functions ----- */


/* ----- Begin Custom Function support functions ----- */

function build_cf_select() {
 var cf_function_opts="";
 for (var i=0; i<VF_CUSTOM_FUNCTIONS.length; i++)
  cf_function_opts+= '<option value="'+escATTR(VF_CUSTOM_FUNCTIONS[i].id.toString())+'">'+
                      escHTML(VF_CUSTOM_FUNCTIONS[i].library+':'+VF_CUSTOM_FUNCTIONS[i].name)+'</option>';
 $I('cf_function').innerHTML=cf_function_opts;
}

function custom_function_part1(rowid, action, label, state) {
 $I('cf_part2').style.display='none';
 var datalist_options="";
 gDB.transaction(function (t) {
  t.executeSql("select name from VF_DB_TABLES order by name asc", null,
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     if (r.rows.item(i)["name"]) {
      var opt= '<option value="'+escATTR(r.rows.item(i)["name"])+'"></option>';
      datalist_options+= opt;
     }
               }   });
                              }, null, function () 
			                { custom_function_part1a(rowid, action, label, state, datalist_options); } );
}

function custom_function_part1a(rowid, action, label, state, datalist_options) {
 $I('cf_table_list').innerHTML= datalist_options;
 /*
 var cf_function_opts="";
 // Conditionally populate select list
 if (!$I('cf_function').length) {
  for (var i=0; i<VF_CUSTOM_FUNCTIONS.length; i++)
   cf_function_opts+= '<option value="'+escATTR(VF_CUSTOM_FUNCTIONS[i].id.toString())+'">'+
                       escHTML(VF_CUSTOM_FUNCTIONS[i].library+':'+VF_CUSTOM_FUNCTIONS[i].name)+'</option>';
  $I('cf_function').innerHTML=cf_function_opts;
 }
 */
 if ((action == 'edit') || (action == 'execute'))
  custom_function_next(rowid, action, label, state);
}

function custom_function_next(rowid, action, label, state) {
 var the_table=$I("cf_table").value;
 var the_function_offset=gCF_IDX[$I('cf_function').value];
 if (!the_table)
  return;
 custom_function_next_get_table_columns(the_table, rowid, label, action, state);
}

function custom_function_next_get_table_columns(table_name, rowid, label, action, state) {
 var table_columns=[];
 var has_data=true;
 gDB.transaction(function (t) {
  t.executeSql("select * from "+sanitise(table_name)+" limit 1", null,
   function (tx, r) {
    if (r.rows.length == 0) {
     notify("Table "+table_name+" appears to have no rows.  Unable to continue");
     has_data=false;
     return;
    }
    else
     for (col in r.rows.item(0)) 
      table_columns.push(col);
                  });
                               }, null, function () { if ((has_data)||(action=='edit')||(action=='execute')) 
                                                       custom_function_part2(table_columns, rowid, action, label, state);
			                            } );
}

function custom_function_part2(table_columns, rowid, action, label, state) {
 build_data_list('cf_table_column_list',table_columns);
 //build_data_list('cf_query_string_list',query_string_params);
 var o=gCF_IDX[$I("cf_function").value];
 var fnc= VF_CUSTOM_FUNCTIONS[o];
 $I("cf_part2_help").innerHTML =
  escHTML(fnc.library+':'+fnc.name+' ('+fnc.id+') - '+fnc.help);
 var params=fnc.parameters;
 var input_html="";
 for (var p=0; p<params.length; p++) {
  var param_name= escHTML(params[p].name);
  var required=((params[p].optional)?'':'class="required"');
  var param_value="";
  if (params[p].default)
   param_value=escATTR(params[p].default);
  input_html+= '<p><span title="'+escATTR(params[p].help)+'" '+required+'>'+param_name+'</span> '+
               '<select id="cf_param_type_'+p.toString()+'" onchange="custom_function_param_type_change('+p.toString()+');">'+
               '<option value="Literal Constant">Literal Constant</option><option value="Column Value">Column Value</option>'+
               '<option value="Query String">Query String Param</option></select> '+
               '<input id="cf_param_value_'+p.toString()+'" style="width: 120px;" list="" value="'+param_value+'" type="search"/></p>';
 }
 $I("cf_part2_inputs").innerHTML=input_html;
 $I('cf_part2').style.display="inline";
 if ((action=='execute')||(action=='edit')) {
  // Non-interactive invocation
  post_params_populate(action, rowid, label, state);  
 }
 else {
  // Being run interactive - partial form reset
  $I('cf_result_table').value='';
  $I('cf_is_temp').checked=false;
  $I('cf_task_id').value='';
  $I('cf_description').value='';
  $I("cf_results").innerHTML='';
  $I("cf_results_smallscreen").innerHTML='';
  $I("cf_summary").innerHTML='';
  $I("cf_save_progress").innerHTML='';
  cf_progress(null,null,true);
 }
}

function custom_function_param_type_change(o) {
 var elem_id='cf_param_type_'+o;
 var val=$I(elem_id).value;
 var inp_id='cf_param_value_'+o;
 var inp = $I(inp_id); 
 inp.setAttribute('list','');
 if (val == 'Column Value')
  inp.setAttribute('list','cf_table_column_list');
 if (val == 'Query String')
  inp.setAttribute('list','query_string_list');
 if (val == 'Literal Constant')
  inp.setAttribute('list','');
};

function build_data_list(elem_id, arr) {
 var dl='';
 if (!arr) {
  $I(elem_id).innerHTML='';
  return;
 }
 for (var i=0; i<arr.length; i++)
  dl+='<option>'+escHTML(arr[i])+'</option>';
 $I(elem_id).innerHTML= dl;
}

function process_cf_function(action, query_strings, state) {
 if (action == 'Initialise') {
  cf_progress(null,null,false);
  sessionStorage.clear();
  cf_preprocess1(action, query_strings, state);
  return;
 }
 var o=$I('cf_function').value;
 if (!(o in gCF_IDX)) {
  // Unable to find function by id, run next task if applicable
  next_task(state);
 }
 // Check for custom handler
 var custom_handler_offset=null;
 if (VF_CUSTOM_FUNCTIONS[gCF_IDX[o]].type=='custom')
  custom_handler_offset=gCF_IDX[o];
 if (action == 'Run') {
  var the_table=$I('cf_table').value;
  gDB.transaction(function (t) {
   t.executeSql("select t.ROWID, t.* from "+sanitise(the_table)+" t order by rowid", null,
    function (tx, r) {
     if (custom_handler_offset != null)
      collect_result_set_and_call_custom_handler(r, query_strings, state, custom_handler_offset);
     else
      cf_process_result_set(r, 0, r.rows.length, query_strings, state);
     return;
                       });
                               }, null, null );
  return;
 }
 // Else, unknown action 
 $L('cf-function: Unknown action');
}

function cf_progress(sofar, total, finished, result_total) {
 var blurb='';
 if ((sofar)&&(total)) {
  if (sofar<total)
   blurb+=' <progress value="'+escATTR(sofar.toString())+'" max="'+escATTR(total.toString())+'"></progress> ';
  blurb+= '<span style="color:green;">'+escHTML(sofar.toString())+' Rows.</span>';
  if (result_total) 
   blurb+= '<span style="color:blue;">('+escHTML(result_total)+' Output Rows.)</span>';
 }
 else if (!finished)
  blurb+=gSPIN;
 let qs=document.querySelectorAll('.cf_status');
 qsHtml(qs,blurb);
}

function cf_process_result_set(r, offset, total_rows, query_strings, state) {
 if (!r) {
  notify('No result set');
  return;
  }
 if (!offset)
  offset=0;
 cf_progress(offset, total_rows, false);
 if (offset >= r.rows.length) {
  cf_progress(offset, total_rows, true);
  // Completed.
  // Run next state
  next_task(state);
  return;
 }
 var the_table=$I('cf_table').value;
 var the_function_offset=gCF_IDX[$I('cf_function').value];
 var cf=VF_CUSTOM_FUNCTIONS[the_function_offset];
 var p_type={};
 var p_value={};
 for (p=0; p<cf.parameters.length; p++) {
  let ps=p.toString();
  p_type[ps]=$I('cf_param_type_'+ps).value;
  p_value[ps]=$I('cf_param_value_'+ps).value;
 };
 var batch_size=150;
 var batch_count=0;
 var batch_results=[];
 for (var i=offset; i < r.rows.length; i++) {
  var the_result={};
  the_result.src_table=the_table;
  the_result.grouping_result=null;
  var params=[];
  for (p=0; p<cf.parameters.length; p++) {
   let ps=p.toString();
   let typ=p_type[ps];
   let qs=p_value[ps];
   if (typ == 'Column Value')
    params.push(r.rows.item(i)[qs]);
   if (typ == 'Query String')
    params.push(query_strings[qs]);
   if (typ == 'Literal Constant')
    params.push(qs); 
  };
 the_result.src_rowid=r.rows.item(i).rowid;
 // Run it
 var output=false;
 var status=true;
 var error=null;
 try {
  output=cf.func(params);
     }
  catch(e) {
   status=false;
   error=e.message;
           }
  the_result.result= output;
  the_result.status= status;
  the_result.err_message= error;
  batch_results.push(the_result);
  batch_count++;
  if (batch_count >= batch_size) {
   insert_cf_result_rows(r, batch_results, offset, total_rows, query_strings, state);
   return;
  }
 }
 // Insert residual
 if (batch_results.length > 0) {
  insert_cf_result_rows(r, batch_results, offset, total_rows, query_strings, state);
  return;
 }
}

function cf_preprocess1(action, query_strings, state) {
 var query_strings={};
 gDB.transaction(function (t) {
  t.executeSql("select name, value from VF_QUERY_STRING", null,
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++)
     query_strings[r.rows.item(i).NAME]=r.rows.item(i).VALUE;  //Assumes non array Query Strings for CF functions.
                 });
                              }, null, function () { cf_preprocess2(action, query_strings, state); } );
}

function cf_preprocess2(action, query_strings, state) {
 var result_table= $I('cf_result_table').value;
 var temp='';
 if ($I('cf_is_temp').checked)
  temp='temp ';
 gDB.transaction(function (t) {
  t.executeSql("drop table if exists "+sanitise(result_table),null,null);
  t.executeSql("create "+temp+" table if not exists "+sanitise(result_table)+
               "(SRC_TABLE TEXT, SRC_ROWID ROWID, GROUPING_RESULT TEXT, RESULT_STATUS TEXT, RESULT TEXT, ERR_MESSAGE TEXT)",null);
                               }, null, function () { cf_preprocess3(action, query_strings, state); } );
}

function cf_preprocess3(action, query_strings, state) {
 process_cf_function('Run', query_strings, state);
}

function insert_cf_result_rows(r, batch_results, offset, total_rows, query_strings, state) {
 var result_table= $I('cf_result_table').value;
 var all_params=[];
 var placeholders='(?,?,?,?,?,?)';
 var all_placeholders="";
 for (var i=0; i<batch_results.length; i++) {
  let the_row=batch_results[i];
  if (all_placeholders)
   all_placeholders+=",";
  all_placeholders+=placeholders;
  all_params.push(the_row.src_table, the_row.src_rowid, the_row.grouping_result, 
                  (the_row.status?'true':'false'), the_row.result, the_row.err_message);
 };
 var next_offset=offset+Math.min(batch_results.length,150);
 gDB.transaction(function (t) {
   t.executeSql("insert into "+sanitise(result_table)+
                "(SRC_TABLE, SRC_ROWID, GROUPING_RESULT, RESULT_STATUS, RESULT, ERR_MESSAGE) values "+
                all_placeholders,all_params);
                            }, cf_insert_error, function () 
                                                 { cf_process_result_set(r, next_offset, total_rows, query_strings, state); } );
}

function collect_result_set_and_call_custom_handler(r, query_strings, state, the_function_offset) {
 var result_table= $I('cf_result_table').value;
 var all_input=[];
 var the_table=$I('cf_table').value;
 var cf=VF_CUSTOM_FUNCTIONS[the_function_offset];
 var p_type={};
 var p_value={};
 for (p=0; p<cf.parameters.length; p++) {
  let ps=p.toString();
  p_type[ps]=$I('cf_param_type_'+ps).value;
  p_value[ps]=$I('cf_param_value_'+ps).value;
 };
 for (var i=0; i < r.rows.length; i++) {
  var the_result={};
  the_result.src_table=the_table;
  var params=[];
  for (p=0; p<cf.parameters.length; p++) {
   let ps=p.toString();
   let typ=p_type[ps];
   let qs=p_value[ps];
   if (typ == 'Column Value')
    params.push(r.rows.item(i)[qs]);
   if (typ == 'Query String Param')
    params.push(query_strings[qs]);
   if (typ == 'Literal Constant')
    params.push(qs); 
   };
  the_result.params=params;
  the_result.src_rowid=r.rows.item(i).rowid;
  all_input.push(the_result);
 };
 cf.func(result_table, all_input, state);
 return;
}

function cf_execute(state) {
 $I('cf_save_progress').innerHTML='';
 process_cf_function('Initialise',null,state);
}

function cf_insert_error(a,b) {
 $L('Custom Function Error; ...');
 $L(a);
 $L(b);
};

function cf_reset(hard) {
 if (hard)
  $I('cf_table').value='';
 $I('cf_result_table').value='';
 $I('cf_is_temp').checked=false;
 $I('cf_task_id').value='';
 $I('cf_description').value='';
 $I('cf_part2').style.display='none';
 $I("cf_results").innerHTML='';
 $I("cf_results_smallscreen").innerHTML='';
 $I("cf_summary").innerHTML='';
 $I("cf_save_progress").innerHTML='';
 cf_progress(null,null,true);
}

function save_cf() {
 var cf_table=$I('cf_table').value;
 var o=gCF_IDX[$I('cf_function').value];
 var fnc= VF_CUSTOM_FUNCTIONS[o];
 var result_table= $I('cf_result_table').value;
 var is_temp=($I('cf_is_temp').checked?1:0);
 var task_id= $I('cf_task_id').value;
 var label= $I('cf_description').value;
 if (!label) {
  notify('Description is Required');
  return;
 }
 if (!cf_table) {
  notify('Source Input Table is Required');
  return;
 }
 if (!result_table) {
  notify('Result Output Table is Required');
  return;
 }
 var params=fnc.parameters;
 var all_param_placeholders='';
 var all_param_values=[];
 for (var p=0; p<params.length; p++) {
  if (all_param_placeholders)
   all_param_placeholders+= ',(?,?,?,?)'
  else
   all_param_placeholders= '(?,?,?,?)';
  all_param_values.push(label);
  all_param_values.push(p);
  all_param_values.push($I('cf_param_type_'+p.toString()).value);
  all_param_values.push($I('cf_param_value_'+p.toString()).value);
 }
 var now = new Date();
 var save_date = parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_custom_function where label = ?", [label]);
   t.executeSql("delete from vf_custom_function_parameter where label = ?", [label]);
   t.executeSql("insert into vf_custom_function(label, input_source_table, function_id, result_output_table, is_temp, task_id, date_saved) "+
                "values (?,?,?,?,?,?,?)", [label, cf_table, VF_CUSTOM_FUNCTIONS[o].id, result_table, is_temp, task_id, save_date]);
   t.executeSql("insert into vf_custom_function_parameter(label, parameter_index, parameter_type, parameter_value) values "+
                 all_param_placeholders, all_param_values);
                }, null, cf_saved);
}

function cf_saved() {
 tick_fade('cf_save_progress');
 list_cf_functions();
 }
  
function list_cf_functions(clicker) {
 if (clicker)
  $I('cf_save_progress').innerHTML='';
 let qs=document.querySelectorAll('.cf_status');
 qsHtml(qs,'');
 $I("cf_results").innerHTML='';
 $I("cf_results_smallscreen").innerHTML='';
 $I("cf_navigation").innerHTML='';
 $I("cf_summary").innerHTML=gSPIN;
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, input_source_table, function_id, result_output_table, is_temp, task_id, "+
                " date_saved from vf_custom_function order by date(date_saved) desc, label asc", [],
   function (tx, r) {
    var shown="";
    if (r.rows.length > gUNPAGINATED_MAX_ROWS)
     shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
    $I('cf_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved Custom Functions "+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td>Description</td>'+
		    "<td>Date Saved</td><td>Task Id</td><td>Input Source Table</td><td>Library</td><td>Function</td><td>Id</td>"+
	      "<td>Result Output Table</td><td>Edit</td><td>Run</td><td>Drop</td></tr>";
     $I('cf_results').innerHTML=msg;
                                     };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
      let row_results='<tr class="rs"><td><a class="blk" href="javascript: '+
                                'handle_cf(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Function">'+
                                 escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                                '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                                '<td>'+escHTML(r.rows.item(i).INPUT_SOURCE_TABLE)+'</td>'+
				'<td>'+escHTML(VF_CUSTOM_FUNCTIONS[gCF_IDX[r.rows.item(i).FUNCTION_ID]].library)+'</td>'+
				'<td>'+escHTML(VF_CUSTOM_FUNCTIONS[gCF_IDX[r.rows.item(i).FUNCTION_ID]].name)+'</td>'+
				'<td>'+escHTML(r.rows.item(i).FUNCTION_ID)+'</td>'+
                                '<td>'+escHTML(r.rows.item(i).RESULT_OUTPUT_TABLE)+'</td>'+
                                '<td><button title="Edit" onclick="'+escATTR('handle_cf(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                                '<td><button title="Run" onclick="'+escATTR('handle_cf(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                                '<td><button title="Drop" onclick="'+escATTR('delete_cf('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
      $I('cf_results').innerHTML+= row_results;
      let row_smallscreen='<tr class="rs"><td><dl>'+
      '<dt class="hdrg">Description</dt>'+
      '<dd><a class="blk" href="javascript: '+
            'handle_cf(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Function">'+
            escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
      '<dt class="hdrg">Date Saved</dt>'+
      '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
      '<dt class="hdrg">Task Id</dt>'+
      '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
      '<dt class="hdrg">Input Source Table</dt>'+
      '<dd>'+escHTML(r.rows.item(i).INPUT_SOURCE_TABLE)+'</dd>'+
      '<dt class="hdrg">Library</dt>'+
      '<dd>'+escHTML(VF_CUSTOM_FUNCTIONS[gCF_IDX[r.rows.item(i).FUNCTION_ID]].library)+'</dd>'+
      '<dt class="hdrg">Name</dt>'+
      '<dd>'+escHTML(VF_CUSTOM_FUNCTIONS[gCF_IDX[r.rows.item(i).FUNCTION_ID]].name)+'</dd>'+
      '<dt class="hdrg">Id</dt>'+
      '<dd>'+escHTML(r.rows.item(i).FUNCTION_ID)+'</dd>'+
      '<dt class="hdrg">Result Output Table</dt>'+
      '<dd>'+escHTML(r.rows.item(i).RESULT_OUTPUT_TABLE)+'</dd>'+
      '<dt class="hdrg">Action</dt>'+
      '<dd><button title="Edit" onclick="'+escATTR('handle_cf(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
           '<button title="Run" onclick="'+escATTR('handle_cf(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
           '<button title="Drop" onclick="'+escATTR('delete_cf('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
      '</dd></dl></td></tr>';
        $I('cf_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
                              }, null, cf_list_loaded );
}

function cf_list_loaded(state) {
 null;
}

function delete_cf(rowid) {
 $I("cf_save_progress").innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_custom_function_parameter where label in "+
                "(select label from vf_custom_function where rowid = ?)", [rowid]);
   t.executeSql("delete from vf_custom_function where rowid = ?", [rowid]);
                }, null, function() { list_cf_functions(1); });
}

function handle_cf(action, rowid, state) {
 //if (state) 
  set_visible_pane('custom_function');
 $I('cf_save_progress').innerHTML='';
 var the_label="";
 gDB.transaction(function (t) {
  t.executeSql("select label, input_source_table, function_id, result_output_table, is_temp, task_id "+
               " from vf_custom_function where rowid = ?", [rowid],
   function (tx, r) {
    $I('cf_table').value=r.rows.item(0).INPUT_SOURCE_TABLE;
    //$I("cf_function").selectedIndex=r.rows.item(0).FUNCTION_ID;
    $I("cf_function").value=r.rows.item(0).FUNCTION_ID;
    $I('cf_result_table').value=r.rows.item(0).RESULT_OUTPUT_TABLE;
    $I('cf_is_temp').checked= (r.rows.item(0).IS_TEMP == 1);
    $I('cf_task_id').value=r.rows.item(0).TASK_ID;
    $I('cf_description').value=r.rows.item(0).LABEL;
    the_label=r.rows.item(0).LABEL
                 })
                             }, null, function() { handle_cf_params(action, rowid, the_label, state); } );
}

function handle_cf_params(action, rowid, label, state) {
 custom_function_part1(rowid, action, label, state);
}

function post_params_populate(action, rowid, label, state) {
 gDB.transaction(function (t) {
  t.executeSql("select parameter_index, parameter_type, parameter_value from "+
               " vf_custom_function_parameter where label = ?",[label],
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     $I('cf_param_type_'+r.rows.item(i).PARAMETER_INDEX.toString()).value=r.rows.item(i).PARAMETER_TYPE;
     $I('cf_param_value_'+r.rows.item(i).PARAMETER_INDEX.toString()).value=r.rows.item(i).PARAMETER_VALUE;
     try { custom_function_param_type_change(r.rows.item(i).PARAMETER_INDEX.toString()); }
      catch(e) {};
                                        } 
                    });
                             }, null, function() { handle_cf_noninteractive_run(action, rowid, label, state); } );
}

function handle_cf_noninteractive_run(action, rowid, label, state) {
 if (action == 'execute')
  cf_execute(state);
}

/* ----- End Custom Function support functions ----- */

/* ----- Begin Page Dynamic Icon ----- */

function update_favicon(tasks_remaining) {
 var favicon=$I("ico");
 if (!tasks_remaining)
  tasks_remaining=0;
  try {
   tasks_remaining=parseInt(tasks_remaining);
   const canvas = document.createElement("canvas");
   canvas.height=64;
   canvas.width=64;
   const ctx=canvas.getContext("2d");
   var fill="yellow";
   var n=tasks_remaining;
   if (tasks_remaining < 1) {
    fill="lightgreen";
    n="";
   }
   ctx.beginPath();
   ctx.rect(0,0,64,64);
   ctx.fillStyle = fill;
   ctx.fill();
   ctx.font="42px arial"; 
   ctx.fillStyle="blue";
   ctx.fillText(n, 10, 48);
   if (n==0) {
    ctx.beginPath();
    ctx.rect(0,0,64,64);
    ctx.strokeStyle='blue';
    ctx.lineWidth=4;
    ctx.stroke();
   }
   favicon.href=canvas.toDataURL();
  } catch(e) {};
}

/* ----- End Page Dynamic Icon ----- */

/* ----- Begin Device Attributes ----- */

function reset_device_attributes() {
 localStorage.removeItem('CONFIG_DEVICE_ATTRIBUTES_TASK_ID');
 $I('device_attributes_task_id').value='';
 tick_fade('device_attributes_status');
}

function set_device_attributes() {
 var task_id=$I('device_attributes_task_id').value;
 if (!task_id) {
  notify('A Task Id is required');
  return false;
 }
 set_simple_value("CONFIG_DEVICE_ATTRIBUTES_TASK_ID",'device_attributes_task_id');
 tick_fade('device_attributes_status');
 return true;
}

function run_device_attributes() {
 if (set_device_attributes()) 
  sequence_execute($I('device_attributes_task_id').value);
}

function handle_device_attributes(action, state) {
 gDB.transaction(function (t) {
  t.executeSql("delete from VF_DEVICE_ATTRIBUTES where CATEGORY in ('GEOLOCATION_COORDS')", [],null);
					 }, $L, function() { device_attributes_fetch(action, state); });
}

function device_attributes_fetch(action, state) {
 var options = {
  enableHighAccuracy: true,
  timeout: 5000,
  maximumAge: 0
 };
 navigator.geolocation.getCurrentPosition(
  function(pos) { device_attributes_fetched(pos, action, state) },
  function(err) { device_attributes_failure(err, action, state) },
  options);
}

function device_attributes_failure(err, action, state) {
 try { $L(err.code+': '+err.message); } catch(e){};
 next_task(state);
}

function device_attributes_fetched(pos, action, state) {
 var now = new Date();
 var save_date=now.toString();
 var lat, lng, alt;
 gDB.transaction(
  function(t) {
   for (key in pos.coords) {
    if (key.toLowerCase()=='longitude') lng=pos.coords[key];
    if (key.toLowerCase()=='latitude') lat=pos.coords[key];
    if (key.toLowerCase()=='altitude') alt=pos.coords[key];
    t.executeSql("insert into VF_DEVICE_ATTRIBUTES(category,name,value,date_saved) values (?,?,?,?)", 
                 ['GEOLOCATION_COORDS',key,pos.coords[key],save_date],null);
    }
   if ((lat)&&(lng)) {
    var pnt='POINT('+lng.toString()+' '+lat.toString()+')';
    t.executeSql("insert into VF_DEVICE_ATTRIBUTES(category,name,value,date_saved) values (?,?,?,?)", 
                 ['GEOLOCATION_COORDS','POINT2D',pnt,save_date],null);
   }
   if ((lat)&&(lng)&&(alt)) {
    var pnt3d='POINT('+lng.toString()+' '+lat.toString()+' '+alt.toString()+')';
    t.executeSql("insert into VF_DEVICE_ATTRIBUTES(category,name,value,date_saved) values (?,?,?,?)", 
                 ['GEOLOCATION_COORDS','POINT3D',pnt3d,save_date],null);
   }
					 }, $L, function() { device_attributes_process(action, state); });
}

function device_attributes_process(action, state) {
 next_task(state);
}

/* ----- End Device Attributes ----- */

/* ----- Begin Query String ----- */

function import_query_string(flow, state) {
 var query_string_params=[];
 var url = new URL(window.location);
 gDB.transaction(
  function(t) {
    t.executeSql("delete from VF_QUERY_STRING",null,null);
    for (let p of url.searchParams) {
      var pname=p[0];
      var pvalue=p[1];
      t.executeSql("insert into VF_QUERY_STRING(name, value) values (?,?)",[pname,pvalue],null);
      query_string_params.push(pname);
    }
					 }, $L, function() { 
                                                          build_data_list('query_string_list',query_string_params);
						          if ((flow==1)||(flow==2)) startupPageLoad(flow);
					                            });
}

/* ----- End Query String ----- */


/* ----- Begin Page Load ----- */

function set_pageload() {
 set_simple_value('CONFIG_PAGELOAD_TASK_TYPE','pageload_task_type');
 set_simple_value('CONFIG_PAGELOAD_TASK_VALUE','pageload_task_value');
 tick_fade('pageload_status');
}

function reset_pageload() {
 localStorage.removeItem('CONFIG_PAGELOAD_TASK_TYPE');
 localStorage.removeItem('CONFIG_PAGELOAD_TASK_VALUE');
 $I('pageload_task_type').selectedIndex=0;
 $I('pageload_task_value').value='';
 $I("pageload_status").innerHTML='';
 set_pageload();
}

function get_pageload_task_id() {
 if (($I('pageload_task_type').value)=='Literal Constant')
  return $I('pageload_task_value').value;
 // Otherwise assume Query String Param
 var url = new URL(window.location);
 for (let p of url.searchParams) {
      var pn=p[0], pv=p[1];
      if (pn.toLowerCase()==$I('pageload_task_value').value.toLowerCase())
       return pv;
 }
 return null;
}

function pageload_task_type_change() {
 var val=$I('pageload_task_type').value;
 var inp=$I('pageload_task_value'); 
 inp.setAttribute('list','');
 if (val=='Query String')
  inp.setAttribute('list','query_string_list');
};

function run_pageload(set) {
 if (set) set_pageload();
 var task_id=get_pageload_task_id();
 if (task_id) sequence_execute(task_id);
}

/* ----- End Page Load ----- */



/* ----- Begin Browse Table support functions ----- */

function browse_part1(object_name, term, context) {
 browse_reset(object_name);
 var datalist_options="";
 gDB.transaction(function (t) {
  t.executeSql("select name from (select name from VF_DB_OBJECTS union select name from sqlite_temp_master) order by name asc", null,
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     if (r.rows.item(i)["name"]) {
      var opt= '<option value="'+escATTR(r.rows.item(i)["name"])+'"></option>';
      datalist_options+= opt;
     }
               }   });
                              }, null, function () { browse_part2(object_name, term, datalist_options, context); } );
}

function browse_part2(object_name, term, datalist_options, context) {
 $I('browse_table_list').innerHTML=datalist_options;
 if (object_name) {
  $I('browse_table').value=object_name;
  if (term)
   $I('browse_search_input').value=term;
  browse_execute(context);
 }
}

function browse_execute(context) {
 var object_name=$I('browse_table').value;
 if (!object_name) {
  $L('No Table specified');
  return;
 }
 var column_list=[];
 gDB.transaction(function (t) {
  t.executeSql("select * from "+sanitise(object_name)+" limit 1", null,
   function (tx, r) {
    if (r.rows.length >= 1) {
     for (col in r.rows.item(0))
      column_list.push(col);
                            };
			    }) }, browse_table_error, 
			          function () { browse_part4(object_name, column_list, context); return; } );
}

function browse_table_error(e,t) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I("browse_summary").innerHTML=msg;
 $I('browse_progress').innerHTML='';
 $I('browse_results').innerHTML='';
 $I('browse_results_smallscreen').innerHTML='';
 $I('browse_navigation').innerHTML='';
 $I('browse_csv_button').style.display='none';
}

function browse_part4(object_name, column_list, context) {
 // Pull in any metadata
 var display_column_list=column_list;
 var hidden_columns=[];
 if (gBROWSE_META[object_name]) {
  // Remove any hidden columns
  if (gBROWSE_META[object_name]["HIDDEN_COLUMNS"]) {
   display_column_list=display_column_list.filter(function(el)
                                   {return gBROWSE_META[object_name]["HIDDEN_COLUMNS"].indexOf(el)<0;});
   hidden_columns=gBROWSE_META[object_name]["HIDDEN_COLUMNS"];
  } 
  //Add in any additional columns
  if (gBROWSE_META[object_name]["ADDITIONAL_COLUMNS"])
   display_column_list=gBROWSE_META[object_name]["ADDITIONAL_COLUMNS"].concat(display_column_list);
 }
 //Special case to remove display of rowwid;
 if (column_list.length >=1) {
  browse_part5(object_name, column_list, display_column_list, hidden_columns, context);
  return;
  }
  // No Data Found
  $I('browse_summary').innerHTML='No Data Found.';
  $I('browse_progress').innerHTML='';
  $I('browse_results').innerHTML='';
  $I('browse_results_smallscreen').innerHTML='';
  $I('browse_navigation').innerHTML='';
  $I('browse_csv_button').style.display='none';
}

function browse_part5(object_name, column_list, display_column_list, hidden_columns, context) {
 var TERM= $I('browse_search_input').value;
 var QRY="select t.rowid, t.* from "+sanitise(object_name)+" t"; 
 hidden_columns.push('rowid');
 var PARAMS=[];
 var WHERE="";
 if (TERM) {
  var TERMS= tokenise_search_string(TERM);
  for (var t=0; t<TERMS.length; t++) {
   if (WHERE != "")
     WHERE+= ' and ';
   var ROW="(";
   for (var c=0; c<column_list.length; c++) {
     if (ROW != "(")
       ROW+= ' or ';
     ROW+= '('+sanitise(column_list[c])+' like ?)';
     PARAMS.push(TERMS[t]);
    }
   ROW+=')';
   if (ROW != '()')
    WHERE+= ROW;
  }
 }
 if (WHERE)
  QRY+= ' where '+WHERE;
 browse_table_count(object_name, TERM, QRY, PARAMS, context, display_column_list, hidden_columns);
}

function browse_table_count(the_table, term, qry, params, context, display_column_list, hidden_columns) {
 $I('browse_progress').innerHTML=gSPIN;
 $I('browse_results').innerHTML='';
 $I('browse_results_smallscreen').innerHTML='';
 $I('browse_summary').innerHTML='';
 $I('browse_navigation').innerHTML='';
 $I('browse_csv_button').style.display='none';
 var total_rows=null;
 gDB.transaction(function (t) {
  t.executeSql('select count(*) as total_rows from ('+qry+')', params,
   function (tx, r) {
       total_rows=r.rows.item(0).total_rows;
                       },$L)
                            },$L, function()
       {
        browse_table_execute(the_table, term, qry, params, context, display_column_list, hidden_columns, total_rows);
       });
}

function browse_table_execute(the_table, term, qry, params, context, display_column_list, hidden_columns, total_rows) {
 $I('browse_progress').innerHTML=gSPIN;
 $I('browse_results').innerHTML='';
 $I('browse_results_smallscreen').innerHTML='';
 $I('browse_summary').innerHTML='';
 $I('browse_navigation').innerHTML='';
 $I('browse_csv_button').style.display='none';
 var order_by=""
 var t=JSON.stringify(the_table);
 var sort_field=localStorage["BROWSE_"+t+"_SORT_FIELD"];
 if (sort_field) {
  var direction=localStorage["BROWSE_"+t+"_SORT_DIR"];
  if (direction) 
   order_by=' order by '+sanitise(sort_field)+' '+direction;
  else
   order_by=' order by '+sanitise(sort_field)+' ';
  }
 qry+= order_by;
 var page_size=parseInt(get_simple_value('CONFIG_PAGE_SIZE'));
 if (!page_size)
  page_size=50;
 var hidden_csv_columns=[];
 if (!context) {
  var vOFFSET=parseInt(localStorage["BROWSE_"+t+"_OFFSET"]);
  if (!vOFFSET) vOFFSET=0;
  if (parseInt(total_rows)>0) {
   if (vOFFSET > total_rows) vOFFSET=total_rows;
   var vRES1 = parseInt(vOFFSET+1);
   var vLIMIT= Math.min(vOFFSET+page_size,total_rows);
   $I('browse_summary').innerHTML= "Results <b>"+vRES1.toString()+"</b> - <b>"+vLIMIT.toString()+"</b> of <b>"+total_rows.toString()+"</b>";
   var vTOTAL_PAGES=Math.ceil(total_rows/page_size);
   var vCURRENT_PAGE=Math.floor(vOFFSET/page_size);
   var vROWS_DISPLAYED=parseInt(vLIMIT-vOFFSET);
   if (vROWS_DISPLAYED < total_rows)
     browse_results_navigation('browse_navigation','table_offset',vTOTAL_PAGES,vCURRENT_PAGE,total_rows,vOFFSET,page_size);
    else
     $I('browse_navigation').innerHTML='';
  }
 }

 if ((!isNaN(vOFFSET))&&(!isNaN(page_size)))
  qry= 'select * from ('+qry+') LIMIT '+page_size+' OFFSET '+vOFFSET;

 gDB.transaction(function (t) {
  t.executeSql(qry, params,
   function (tx, r) {
    if (!context) {
     if (total_rows>0) {
      var the_cols={};
      if (display_column_list.length >= 1) 
       for (var i=0; i<display_column_list.length; i++)
        the_cols[display_column_list[i]]=display_column_list[i];
      else {
      for (col in r.rows.item(0))
       the_cols.push(col);	  
      };
      var row='<tr class="hdr1">';
      for (col in the_cols) {
       if (sort_field == col) {
        var new_dir= get_new_sort_dir(direction);
        var icon = get_sort_icon(direction);
        row+= "<td><span class=\"nobr\"><a href=\"javascript: table_sort('"+escHTML(col)+"','"+new_dir+"');\">"+escHTML(col)+" "+icon+"</a></span></td>";
        }
       else {
        var new_dir= "asc"
        var icon = get_sort_icon("unsorted");
        row+= "<td><span class=\"nobr\"><a href=\"javascript: table_sort('"+escHTML(col)+"','"+new_dir+"');\">"+escHTML(col)+" "+icon+"</a></span></td>";
        }
      }
      row+= "</tr>";
      $I("browse_results").innerHTML+= row;
                     }
    else 
     $I("browse_summary").innerHTML="No records found.";

    for (var i=0; i<r.rows.length; i++) {
     var row='<tr class="rs">';
     for (col in the_cols) {
      if ((gBROWSE_META[the_table]) && (gBROWSE_META[the_table].MARKUP) && (gBROWSE_META[the_table].MARKUP[col]))
       row+= '<td>'+gBROWSE_META[the_table].MARKUP[col](r.rows.item(i))+'</td>';
      else
       row+= '<td>'+escHTML(r.rows.item(i)[col])+'</td>';
      }
     row+= '</tr>';
     $I('browse_results').innerHTML+= row;

     // Small screen
     var row_smallscreen='<tr class="rs"><td><dl>';
     for (col in the_cols) {
      var header="";
      if (i == 0) {
       // First row, show sorting options
       if (sort_field == col) {
        var new_dir= get_new_sort_dir(direction);
        var icon = get_sort_icon(direction);
        header="<dt class=\"hdrg\"><a class=\"hdr1\" href=\"javascript: table_sort('"+
 	        escHTML(col)+"','"+new_dir+"');\">"+escHTML(col)+" "+icon+"</a></dt>";
       }
       else {
        var new_dir="asc"
        var icon=get_sort_icon("unsorted");
        header= "<dt class=\"hdrg\"><a class=\"hdr1\" href=\"javascript: table_sort('"+
 		     col+"','"+new_dir+"');\">"+escHTML(col)+" "+icon+"</a></dt>";
       }
      } else
        // Subsequent rows
        header=escHTML(col);
      row_smallscreen+= '<dt class="hdrg">'+header+'</dt>';
      if ((gBROWSE_META[the_table]) && (gBROWSE_META[the_table].MARKUP) && (gBROWSE_META[the_table].MARKUP[col]))
       row_smallscreen+= '<dd>'+gBROWSE_META[the_table].MARKUP[col](r.rows.item(i))+'</dd>';
      else
       row_smallscreen+= '<dd>'+escHTML(r.rows.item(i)[col])+'</dd>';
     }
     row_smallscreen+= "</dl></td></tr>";
     $I("browse_results_smallscreen").innerHTML+= row_smallscreen;
    }

   if (r.rows.length > 0) {
     var but=$I('browse_csv_button');
     but.style.display='inline';
     but.onclick= function(){go_browse(the_table,term,'csv');};
    }

   }  // if (!context)

   if (context=='csv') 
    make_csv(r.rows,hidden_columns,'browse_csv_download_progress',the_table);
    
                      },$L)
                            },$L,browse_table_loaded);
}


function browse_table_loaded() {
 $I('browse_progress').innerHTML='';
}

function table_sort(col,dir) {
 var the_table=$I("browse_table").value;
 var t=JSON.stringify(the_table);
 localStorage["BROWSE_"+t+"_SORT_FIELD"]=col;
 localStorage["BROWSE_"+t+"_SORT_DIR"]=dir;
 localStorage["BROWSE_"+t+"_OFFSET"]=0;
 browse_execute();
}

function table_offset(offset) {
 var the_table=$I('browse_table').value;
 var t=JSON.stringify(the_table);
 var the_offset;
 if ((offset)||(offset==0))
  localStorage["BROWSE_"+t+'_OFFSET']=offset;
 else
  try {
   localStorage["BROWSE_"+t+'_OFFSET']=$I('table_nav_select').value;
      } catch(e) {};
 browse_execute();
}

function browse_results_navigation(elem,search_function,total_pages,current_page,total_rows,offset,page_size) {
  var vPREV= Math.floor((current_page-1)*page_size);
  if (vPREV < 0) vPREV=0;
  var vNEXT= Math.floor((current_page+1)*page_size);
  if (vNEXT > total_rows) vNEXT= parseInt(total_rows-offset);
  var vLAST= Math.floor((total_pages-1)*page_size);
  if (vLAST == 0) vLAST=0;
  var vHTML="";
  if (current_page > 0) {
   vHTML+= "<button onclick=\""+search_function+"(0);\" title=\"First Page\">"+
                  "<i class=\"fa fa-angle-double-left\"></i></button>";
   vHTML+= "<button onclick=\""+search_function+"("+vPREV+");\" title=\"Previous Page\">"+
                  "<i class=\"fa fa-angle-left\"></i></button>";
   }

  if (total_pages <= 1000) {
   vHTML+= "<select id=\"table_nav_select\" onchange=\"table_offset();\">"
   for (var i=0; i<total_pages; i++) {
    if (i == current_page)
     vHTML+= "<option value=\""+parseInt(i*page_size)+"\" selected=\"selected\">Page</option>";
    else
    vHTML+= "<option value=\""+parseInt(i*page_size)+"\">"+parseInt(i+1)+"</option>";
   }
   vHTML+= "</select>";
  }

  if (current_page < (total_pages-1)) {
   vHTML+= "<button onclick=\""+search_function+"("+vNEXT+");\" title=\"Next Page\">"+
                  "<i class=\"fa fa-angle-right\"></i></button>";
   vHTML+= "<button onclick=\""+search_function+"("+vLAST+");\" title=\"Last Page\">"+
                  "<i class=\"fa fa-angle-double-right\"></i></button>";
   }

  $I(elem).innerHTML=vHTML;
}

function browse_reset(table_name) {
 $I('browse_table').value='';
 $I('browse_search_input').value='';
 $I('browse_progress').innerHTML='';
 $I('browse_results').innerHTML='';
 $I('browse_results_smallscreen').innerHTML='';
 $I('browse_summary').innerHTML='';
 $I('browse_navigation').innerHTML='';
 $I('browse_csv_button').style.display='none';
 if (table_name) {
  var t=JSON.stringify(table_name);
  localStorage.removeItem("BROWSE_"+t+'_OFFSET');
  localStorage.removeItem("BROWSE_"+t+"_SORT_FIELD");
  localStorage.removeItem("BROWSE_"+t+"_SORT_DIR");
 }
}

function browse_run(event) {
 if (event.which===13 || 
     event.keyCode===13 || 
     event.key==="Enter")  {
  var table_name=$I("browse_table").value;
  if (table_name) {
   var t=JSON.stringify(table_name);
   localStorage.removeItem("BROWSE_"+t+'_OFFSET');
   localStorage.removeItem("BROWSE_"+t+"_SORT_FIELD");
   localStorage.removeItem("BROWSE_"+t+"_SORT_DIR");
  }
 browse_execute();
 }
}

/* ----- End Browse Table support functions ----- */

/* ----- Begin Config support functions ----- */

function set_config() {
 set_simple_value('CONFIG_DB_NAME','db_name');
 set_simple_value('CONFIG_DB_SIZE','db_size');
 set_simple_value('CONFIG_SEQUENCE_LIMIT','sequence_limit');
 localStorage['CONFIG_SHOW_STATUS']=(($I('show_status_page').checked)?1:0);
 set_simple_value('CONFIG_PAGE_SIZE','page_size');
 set_simple_value('CONFIG_FIELD_TRUNCATE','field_size');
 set_simple_value("CONFIG_DEVICE_ATTRIBUTES_TASK_ID",'device_attributes_task_id');
 set_simple_value('CONFIG_PAGELOAD_TASK_TYPE','pageload_task_type');
 set_simple_value('CONFIG_PAGELOAD_TASK_VALUE','pageload_task_value');
 set_simple_value('CONFIG_MAP_BASE_URL','map_base_tile_url');
 set_simple_value('CONFIG_MAP_ATTRIBUTION','map_base_tile_attribution');
 tick_fade('config_status');
}

function reset_config(all) {
 if (all) {
  localStorage.removeItem('CONFIG_DB_NAME');
  localStorage.removeItem('CONFIG_DB_SIZE');
  localStorage.removeItem('CONFIG_SEQUENCE_LIMIT');
  localStorage.removeItem('CONFIG_SHOW_STATUS');
  localStorage.removeItem('CONFIG_PAGE_SIZE');
  localStorage.removeItem('CONFIG_FIELD_TRUNCATE');
  localStorage.removeItem('CONFIG_DEVICE_ATTRIBUTES_TASK_ID');
  localStorage.removeItem('CONFIG_PAGELOAD_TASK_TYPE');
  localStorage.removeItem('CONFIG_PAGELOAD_TASK_VALUE');
  localStorage.removeItem('CONFIG_MAP_BASE_URL');
  localStorage.removeItem('CONFIG_MAP_ATTRIBUTION');
  config_defaults();
 };
 $I("config_status").innerHTML='';
 get_config();
}

function config_defaults() {
  // DB NAME fixed in this version.
  localStorage['CONFIG_DB_NAME']='vf';
  //if (!localStorage['CONFIG_DB_NAME'])
  // localStorage['CONFIG_DB_NAME']='vf';
  if (!localStorage['CONFIG_DB_SIZE'])
   localStorage['CONFIG_DB_SIZE']='200';
  if (!localStorage['CONFIG_SEQUENCE_LIMIT'])
   localStorage['CONFIG_SEQUENCE_LIMIT']='50';
  if (!localStorage['CONFIG_SHOW_STATUS'])
   localStorage['CONFIG_SHOW_STATUS']='1';
  if (!localStorage['CONFIG_PAGE_SIZE'])
   localStorage['CONFIG_PAGE_SIZE']='20';
  if (!localStorage['CONFIG_FIELD_TRUNCATE'])
   localStorage['CONFIG_FIELD_TRUNCATE']='5000';
  if (!localStorage['CONFIG_DEVICE_ATTRIBUTES_TASK_ID'])
   localStorage['CONFIG_DEVICE_ATTRIBUTES_TASK_ID']='';
  if (!localStorage['CONFIG_PAGELOAD_TASK_TYPE'])
   localStorage['CONFIG_PAGELOAD_TASK_TYPE']='Literal Constant';
  if (!localStorage['CONFIG_PAGELOAD_TASK_VALUE'])
   localStorage['CONFIG_PAGELOAD_TASK_VALUE']='';
  if (!localStorage['CONFIG_MAP_BASE_URL']) {
   localStorage['CONFIG_MAP_BASE_URL']=gSAMPLE_TILE_LAYERS[0].url;
   localStorage['CONFIG_MAP_ATTRIBUTION']=gSAMPLE_TILE_LAYERS[0].attrib;
  }
}

function get_config() {
 load_simple_value('db_name','CONFIG_DB_NAME');
 load_simple_value('db_size','CONFIG_DB_SIZE');
 load_simple_value('sequence_limit','CONFIG_SEQUENCE_LIMIT');
 $I('show_status_page').checked=((localStorage['CONFIG_SHOW_STATUS'])>0?true:false);
 load_simple_value('page_size','CONFIG_PAGE_SIZE');
 load_simple_value('field_size','CONFIG_FIELD_TRUNCATE');
 load_simple_value('device_attributes_task_id','CONFIG_DEVICE_ATTRIBUTES_TASK_ID');
 load_simple_value('pageload_task_type','CONFIG_PAGELOAD_TASK_TYPE');
 load_simple_value('pageload_task_value','CONFIG_PAGELOAD_TASK_VALUE');
 load_simple_value('map_base_tile_url','CONFIG_MAP_BASE_URL');
 load_simple_value('map_base_tile_attribution','CONFIG_MAP_ATTRIBUTION');
}

function get_simple_value(id) {
 if (!id) return null;
 return (localStorage[id]||null);
 }

function set_simple_value(id, elem_id) {
 localStorage[id]= $I(elem_id).value;
}

function load_simple_value(elem_id, id) {
 var val=get_simple_value(id);
 if (val != null)
  $I(elem_id).value= val;
}

function populate_config_sample_map_tiles() {
 var opts='';
 for (var i=0; i<gSAMPLE_TILE_LAYERS.length; i++) {
  opts+='<option value="'+escATTR(i.toString())+'">'+
         escHTML(gSAMPLE_TILE_LAYERS[i].title)+'</option>';
  }
 var s=$I('map_base_sample_layers');
 s.innerHTML=opts;
} 

function set_sample_base_layer(el) {
 var i=el.value;
 var t=$I('map_base_tile_url');
 t.value=gSAMPLE_TILE_LAYERS[i].url;
 var a=$I('map_base_tile_attribution');
 a.value=gSAMPLE_TILE_LAYERS[i].attrib;
 tick_fade('map_base_tile_url_status');
 tick_fade('map_base_tile_attribution_status');
}

/* ----- End Config support functions ----- */


/* ----- Begin CSV Output support functions ----- */

function toCSVfield(x) {
 if (!x)
  return '';
 try {
 if ((x.indexOf(',')>=0)||(x.indexOf('"')>=0))
  return '"'+x.replace(/\"/g,'""')+'"'
 else
  return x;
     } catch(e) {return x;};
}

function stepped_csv_construction(result_set, hidden_columns, offset, progress_id, table_name, csv_data) {
 if (!hidden_columns)
  hidden_columns = [];
 var chunk_size=100;
 if (offset < result_set.length) {
  var upper_bound= Math.min(result_set.length, offset+chunk_size);
  for (var i=offset; i<upper_bound; i++) {
   var row_data = result_set.item(i);
   var row="";
   var have_field=false;
   for (var j in row_data) {
    if (hidden_columns.indexOf(j) < 0) {
     if (!have_field) {
       row=toCSVfield(result_set.item(i)[j]);
       have_field=true;
      }
     else
      row+= ','+toCSVfield(result_set.item(i)[j]);
     }
    }
   csv_data+= row+'\r\n';
  }
 }
 else {
  $I(progress_id).innerHTML='';
  download_file(csv_data, table_name+'.csv', 'text/csv');
  return;
 }
 $I(progress_id).innerHTML= 
   '<progress  value="'+offset+'" max="'+result_set.length+'"></progress>'+
   '<span style="color:green;font-size:xx-small;">'+offset+'</span>'; 
 window.setTimeout(function() { 
  stepped_csv_construction(result_set, hidden_columns, upper_bound, progress_id, table_name,csv_data); }, 0);
}

function make_csv(result_set, hidden_columns, progress_id, table_name) {
 if (!hidden_columns)
  hidden_columns = [];
 var data="";
 var row="";
 for (var col in result_set.item(0)) {
  if (hidden_columns.indexOf(col)<0) {
   if (!row)
    row=toCSVfield(col);
   else
    row+=','+toCSVfield(col);
   }
 }
 data=row+'\r\n'; 
 stepped_csv_construction(result_set, hidden_columns, 0, progress_id, table_name, data);
}

/* ----- End CSV Output support functions ----- */


/* ----- Begin Table Visualization ----- */

function table_viz_object_list() {
 var datalist_options="";
 $I('table_viz_column_list').innerHTML='';
 gDB.transaction(function (t) {
  t.executeSql("select name from (select name from VF_DB_OBJECTS union select name from sqlite_temp_master) order by name asc", null,
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     if (r.rows.item(i)["name"]) {
      var opt= '<option value="'+escATTR(r.rows.item(i)["name"])+'"></option>';
      datalist_options+= opt;
     }
               }   });
                              }, $L, function () { table_viz_object_list2(datalist_options); } );
}

function table_viz_object_list2(datalist_options) {
 $I('table_viz_object_name_list').innerHTML=datalist_options;
}

function table_viz_populate_column_list(callback) {
 var object_name=$I('table_viz_object_name').value;
 if (!object_name) return;
 var datalist_options="";
 gDB.transaction(function (t) {
  t.executeSql("select * from "+sanitise(object_name)+" limit 1", null,
   function (tx, r) {
    if (r.rows.length >= 1) {
    for (col in r.rows.item(0)) {
      var opt= '<option value="'+escATTR(col)+'"></option>';
      datalist_options+=opt;
      }
                            };
			    }) }, $L, 
			          function () { table_viz_populate_column_list2(datalist_options, callback); } );
			
}

function table_viz_populate_column_list2(datalist_options, callback) {
 $I('table_viz_column_list').innerHTML=datalist_options;
 if (callback) callback();
}

//Note, this is not be used
function table_viz_object_error(e,t) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I("table_viz_summary").innerHTML=msg;
}

function clear_table_viz_form() {
 $I('table_viz_object_name').value='';
 //$I('table_viz_display_theme').value='';
 $I('table_viz_title_type').selectedIndex=0;
 $I('table_viz_title_value').value='';
 $I('table_viz_description').value='';
 $I('table_viz_task_id').value='';
 $I('table_viz_links_target').value='';
 $I('table_viz_drilldown_column').value='';
 $I('table_viz_drilldown_label').value='Drilldown';
 $I('table_viz_drilldown_metadata').checked=false;
 $I('table_viz_column_list').innerHTML='';
 $I('table_viz_progress').innerHTML='';
 $I('table_viz_summary').innerHTML='';
 $I('table_viz_results_smallscreen').innerHTML='';
 $I('table_viz_results').innerHTML='';
 $I('table_viz_save_progress').innerHTML='';
 table_viz_object_list();
}

function save_table_viz() {
 var table_viz_object_name=$I('table_viz_object_name').value;
 var table_viz_display_theme=null; //var table_viz_display_theme=$I('table_viz_display_theme').value;
 var table_viz_title_type=$I('table_viz_title_type').value;
 var table_viz_title_value=$I('table_viz_title_value').value;
 var table_viz_description=$I('table_viz_description').value;
 var table_viz_task_id=$I('table_viz_task_id').value;
 var table_viz_links_target=$I('table_viz_links_target').value;
 var table_viz_drilldown_column=$I('table_viz_drilldown_column').value;
 var table_viz_drilldown_label=$I('table_viz_drilldown_label').value;
 var table_viz_drilldown_metadata=(($I('table_viz_drilldown_metadata').checked)?1:0);
 if (!table_viz_object_name) {
  alert('Please enter a Table or View');
  return;
  }
 if (!table_viz_description) {
  alert('Please enter a Description');
  return;
  }
 $I('table_viz_save_progress').innerHTML=gSPIN;
 var now = new Date();
 var save_date = parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_table_visualization where label = ?", [table_viz_description]);
   t.executeSql("insert into vf_table_visualization(label, object_name, display_theme, title_type, title_value, "+
                "task_id, links_target, drilldown_column, drilldown_label, drilldown_append_metadata, date_saved) "+
		"values(?,?,?,?,?,?,?,?,?,?,?)",
                [table_viz_description, table_viz_object_name, table_viz_display_theme, table_viz_title_type,
		 table_viz_title_value, table_viz_task_id, table_viz_links_target, table_viz_drilldown_column,
		 table_viz_drilldown_label, table_viz_drilldown_metadata, save_date]);
                }, $L, table_viz_saved);
}

function table_viz_saved() {
 tick_fade('table_viz_save_progress');
 list_table_viz();
}
  
function list_table_viz() {
 $I('table_viz_progress').innerHTML=gSPIN;
 $I('table_viz_summary').innerHTML='';
 $I('table_viz_results_smallscreen').innerHTML='';
 $I('table_viz_results').innerHTML='';
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, object_name, title_value, task_id, date_saved from vf_table_visualization"+
                " order by date(date_saved) desc, label asc", [],
   function (tx, r) {
    var shown="";
    if (r.rows.length > gUNPAGINATED_MAX_ROWS)
     shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
    $I('table_viz_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved Table Visualizations "+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td>Description</td>'+
             '<td>Date Saved</td><td>Task Id</td><td>Object Name</td><td>Visualization Title</td>'+
	     '<td>Edit</td><td>Run</td><td>Drop</td></tr>';
     $I('table_viz_results').innerHTML=msg;
                                      };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
     let row_results='<tr class="rs"><td><a class="blk" href="javascript: '+
                      'handle_table_viz(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Table Visualization">'+
                      escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                      '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).OBJECT_NAME)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).TITLE_VALUE)+'</td>'+
                      '<td><button title="Edit" onclick="'+escATTR('handle_table_viz(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                      '<td><button title="Run" onclick="'+escATTR('handle_table_viz(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                      '<td><button title="Drop" onclick="'+escATTR('delete_table_viz('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
     $I('table_viz_results').innerHTML+= row_results;
     let row_smallscreen='<tr class="rs"><td><dl>'+
       '<dt class="hdrg">Description</dt>'+
       '<dd><a class="blk" href="javascript: '+
        'handle_table_viz(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Table Visualization">'+
	  escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
       '<dt class="hdrg">Object</dt>'+
       '<dd>'+escHTML(r.rows.item(i).OBJECT_NAME)+'</dd>'+
       '<dt class="hdrg">Title</dt>'+
       '<dd>'+escHTML(r.rows.item(i).TITLE_VALUE)+'</dd>'+
       '<dt class="hdrg">Date Saved</dt>'+
       '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
       '<dt class="hdrg">Task Id</dt>'+
       '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
       '<dt class="hdrg">Action</dt>'+
       '<dd>'+'<button title="Edit" onclick="'+escATTR('handle_table_viz(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
              '<button title="Run" onclick="'+escATTR('handle_table_viz(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
              '<button title="Drop" onclick="'+escATTR('delete_table_viz('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></div></div>'+
       '</dd></td></tr>';
       $I('table_viz_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
                              }, null, table_viz_list_loaded );
}

function table_viz_list_loaded(state) {
 $I('table_viz_progress').innerHTML='';
}

function delete_table_viz(rowid) {
 $I("table_viz_save_progress").innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_table_visualization where rowid = ?", [rowid]);
               }, null, list_table_viz);
}

function handle_table_viz(action, rowid) {
 var the_row;
 gDB.transaction(function (t) {
  t.executeSql("select * from vf_table_visualization where rowid = ?", [rowid],
   function (tx, r) {
    the_row=r.rows.item(0);
    $I('table_viz_object_name').value=r.rows.item(0).OBJECT_NAME;
    //$I('table_viz_display_theme').value=r.rows.item(0).DISPLAY_THEME;
    $I('table_viz_title_type').value=r.rows.item(0).TITLE_TYPE;
    $I('table_viz_title_value').value=r.rows.item(0).TITLE_VALUE;
    $I('table_viz_description').value=r.rows.item(0).LABEL;
    $I('table_viz_task_id').value=r.rows.item(0).TASK_ID;
    $I('table_viz_links_target').value=r.rows.item(0).LINKS_TARGET;
    $I('table_viz_drilldown_column').value=r.rows.item(0).DRILLDOWN_COLUMN;
    $I('table_viz_drilldown_label').value=r.rows.item(0).DRILLDOWN_LABEL;
    $I('table_viz_drilldown_metadata').checked=((r.rows.item(0).DRILLDOWN_APPEND_METADATA>=1)?true:false);
                  })
                              }, $L, function() { 
						table_viz_populate_column_list();
			                        if (action=='execute') run_table_visualization(rowid, the_row); 
			                        if (action=='edit') set_visible_pane('table_viz_setup');
						         });
}

/* ----- Table Runtime Visualization ----- */

function run_table_visualization(rowid,md) {
 $I('table_viz_render_title').innerHTML='';
 table_viz_render_execute(md);
}

function table_viz_render_execute(md, context) {
 var object_name;
 if ((md)&&(md["OBJECT_NAME"])) {
   object_name=md['OBJECT_NAME'];
   localStorage['TABLE_VIZ_OBJECT']=JSON.stringify(object_name);
   localStorage['TABLE_VIZ_METADATA']=JSON.stringify(md);
   var o=JSON.stringify(object_name);
   localStorage.removeItem('TABLE_VIZ_'+o+'_SORT_FIELD');
   localStorage.removeItem('TABLE_VIZ_'+o+'_SORT_DIR');
   localStorage.removeItem('TABLE_VIZ_'+o+'_OFFSET');
 }
 else {
  try { object_name=JSON.parse(localStorage['TABLE_VIZ_OBJECT']); } catch(e) {};
 }
 if (!object_name) return;
 set_visible_pane('table_viz_render');
 var column_list=[];
 gDB.transaction(function (t) {
  t.executeSql('select * from '+sanitise(object_name)+' limit 1', null,
   function (tx, r) {
    if (r.rows.length >= 1) {
     for (col in r.rows.item(0))
      column_list.push(col);
                            };
			    }) }, table_viz_render_table_error, 
			          function () { table_viz_render_next1(object_name, column_list, context); } );
}

function table_viz_render_table_error(e,t) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I("table_viz_render_summary").innerHTML=msg;
}

function table_viz_render_next1(object_name, column_list, context) {
 if (column_list.length >=1) {
  table_viz_render_next2(object_name, column_list, context);
  return;
  }
  $I('table_viz_render_summary').innerHTML='No Data Found.';
}

function table_viz_render_next2(object_name, column_list, context) {
 var TERM= $I('table_viz_render_search_input').value;
 var QRY = "select t.* from "+sanitise(object_name)+" t "; 
 var PARAMS=[];
 var WHERE="";
 if (TERM) {
  var TERMS= tokenise_search_string(TERM);
  for (var t=0; t<TERMS.length; t++) {
   if (WHERE != '')
     WHERE+= ' and ';
   var ROW="(";
   for (var c=0; c<column_list.length; c++) {
     if (ROW != "(")
       ROW+= ' or ';
     ROW+= '('+sanitise(column_list[c])+' like ?)';
     PARAMS.push(TERMS[t]);
    }
   ROW+=')';
   if (ROW != '()')
    WHERE+= ROW;
  }
 }
 if (WHERE)
  QRY+= ' where '+WHERE;
 table_viz_render_count(object_name, QRY, PARAMS, context);
}

function table_viz_render_count(object_name, qry, params, context) {
 $I('table_viz_render_progress').innerHTML=gSPIN;
 $I('table_viz_render_results').innerHTML='';
 $I('table_viz_render_results_smallscreen').innerHTML='';
 $I('table_viz_render_summary').innerHTML='';
 $I('table_viz_render_navigation').innerHTML='';
 $I('table_viz_render_csv_button').style.display='none';
 var total_rows=null;
 gDB.transaction(function (t) {
  t.executeSql('select count(*) as total_rows from ('+qry+')', params,
   function (tx, r) {
       total_rows=r.rows.item(0).total_rows;
                       },$L)
                            },$L, function()
       {
        table_viz_render_run_query(object_name, qry, params, context, total_rows);
       });
}

function table_viz_render_run_query(object_name, qry, params, context, total_rows) {
 if (!object_name) {
  try { object_name=JSON.parse(localStorage['TABLE_VIZ_OBJECT']); } catch(e){};
 }
 $I('table_viz_render_progress').innerHTML=gSPIN;
 $I('table_viz_render_results').innerHTML='';
 $I('table_viz_render_results_smallscreen').innerHTML='';
 $I('table_viz_render_summary').innerHTML='';
 $I('table_viz_render_navigation').innerHTML='';
 $I('table_viz_render_csv_button').style.display='none';
 var order_by='';
 var sort_field=localStorage['TABLE_VIZ_'+JSON.stringify(object_name)+'_SORT_FIELD'];
 if (sort_field) {
  var direction=localStorage['TABLE_VIZ_'+JSON.stringify(object_name)+'_SORT_DIR'];
  if (direction) 
   order_by=' order by '+sanitise(sort_field)+' '+direction;
  else
   order_by=' order by '+sanitise(sort_field)+' ';
  }
 qry+= order_by;
 var page_size=parseInt(get_simple_value('CONFIG_PAGE_SIZE'));
 if (!page_size)
  page_size=50;
 var hidden_columns=[];
 var csv_hidden_columns=[];
 var md;
 var drilldown=null;
 var links_target=null;
 var anchor=null;
 var append_metadata=false;
 try {
  md=JSON.parse(localStorage['TABLE_VIZ_METADATA']); 
  if (md['LINKS_TARGET'])
   links_target=md['LINKS_TARGET'];
   if (md['TITLE_TYPE']=='Column Value') {
    hidden_columns.push(md['TITLE_VALUE']);
    csv_hidden_columns.push(md['TITLE_VALUE']);
   }
   else {
    var t=$I('table_viz_render_title');
    t.innerHTML=escHTML(md['TITLE_VALUE']);
   }
  if (md['DRILLDOWN_COLUMN'])
   csv_hidden_columns.push(md['DRILLDOWN_COLUMN']);
   drilldown=md['DRILLDOWN_COLUMN'];
   anchor=md['DRILLDOWN_LABEL'];
   if (!anchor) anchor='Drilldown';
   append_metadata=(md['DRILLDOWN_APPEND_METADATA']>0);
   } catch(e) {};

  var vOFFSET=parseInt(localStorage['TABLE_VIZ_'+t+'_OFFSET']);
  if (!vOFFSET) vOFFSET=0;
  var vSORT_FIELD=localStorage['TABLE_VIZ_'+t+'_SORT_FIELD'];
  var vSORT_DIR=localStorage['TABLE_VIZ_'+t+'_SORT_DIR'];
  //var vSORT_FIELD="rowid";
  //var vSORT_DIR="asc";

  var t=JSON.stringify(object_name);
  if (!context) {
   var vOFFSET=parseInt(localStorage["TABLE_VIZ_"+t+"_OFFSET"]);
   if (!vOFFSET) vOFFSET=0;
   if (parseInt(total_rows)>0) {
    if (vOFFSET > total_rows) vOFFSET=total_rows;
    var vRES1 = parseInt(vOFFSET+1);
    var vLIMIT= Math.min(vOFFSET+page_size,total_rows);
    $I('table_viz_render_summary').innerHTML= "Results <b>"+vRES1.toString()+"</b> - <b>"+vLIMIT.toString()+"</b> of <b>"+total_rows.toString()+"</b>";
    var vTOTAL_PAGES=Math.ceil(total_rows/page_size);
    var vCURRENT_PAGE=Math.floor(vOFFSET/page_size);
    var vROWS_DISPLAYED=parseInt(vLIMIT-vOFFSET);
    if (vROWS_DISPLAYED < total_rows)
     table_viz_render_results_navigation('table_viz_render_navigation','table_viz_render_table_offset',
                                      vTOTAL_PAGES,vCURRENT_PAGE,total_rows,vOFFSET,page_size);
    else
     $I('table_viz_render_navigation').innerHTML='';
   }
  }

 if ((!isNaN(vOFFSET))&&(!isNaN(page_size)))
  qry= 'select * from ('+qry+') LIMIT '+page_size+' OFFSET '+vOFFSET;

 gDB.transaction(function (t) {
  t.executeSql(qry, params,
   function (tx, r) {
    if (!context) {
     try {
      if (md['TITLE_TYPE']== 'Column Value') {
       var t=$I('table_viz_render_title');
       t.innerHTML=escHTML(r.rows.item(0)[md['TITLE_VALUE']]);
      }
     } catch(e) {};
     if (total_rows>0) {
      var row='<tr class="hdr1">';
      for (col in r.rows.item(0)) {
       if (hidden_columns.indexOf(col)<0) {
        if (sort_field == col) {
         var new_dir= get_new_sort_dir(direction);
         var icon = get_sort_icon(direction);
         row+= "<td><span class=\"nobr\"><a href=\"javascript: table_viz_render_table_sort('"+escHTML(col)+"','"+new_dir+"');\">"+escHTML(col)+" "+icon+"</a></span></td>";
	} else {
         var new_dir= "asc"
         var icon = get_sort_icon("unsorted");
         row+= "<td><span class=\"nobr\"><a href=\"javascript: table_viz_render_table_sort('"+escHTML(col)+"','"+new_dir+"');\">"+escHTML(col)+" "+icon+"</a></span></td>";
         }
       }
      }
     row+= '</tr>';
     $I('table_viz_render_results').innerHTML+= row;
                                     }
    else 
     $I('table_viz_render_summary').innerHTML='No records found.';

    for (var i=0; i<r.rows.length; i++) {

     var row='<tr class="rs">';
     for (col in r.rows.item(i)) {
      if (hidden_columns.indexOf(col)<0) {
       if (col==drilldown)
        row+= '<td>'+drilldownURL(r.rows.item(i)[col],append_metadata,links_target,anchor)+'</td>';
       else
        row+= '<td>'+escHTML(r.rows.item(i)[col],links_target)+'</td>';
      }
     }
     row+= '</tr>';
     $I('table_viz_render_results').innerHTML+= row;


     // Small screen
     var row_smallscreen='<tr class="rs"><td>';
     for (col in r.rows.item(i)) {
      if (hidden_columns.indexOf(col)<0) {
       var header='';
       if (i == 0) {
        // First row, show sorting options
        if (sort_field == col) {
         var new_dir= get_new_sort_dir(direction);
         var icon = get_sort_icon(direction);
         header="<a class=\"hdr1\" href=\"javascript: table_viz_render_table_sort('"+escHTML(col)+
	          "','"+new_dir+"');\">"+escHTML(col)+' '+icon+'</a>';
        }
        else {
         var new_dir='asc';
         var icon =get_sort_icon('unsorted');
         header= "<a class=\"hdr1\" href=\"javascript: table_viz_render_table_sort('"+escHTML(col)+
	           "','"+new_dir+"');\">"+col+' '+icon+'</a>';
        }
       }
       else
        // Subsequent rows
        header=escHTML(col); 
       row_smallscreen+= '<dt class="hdrg">'+header+'</dt><dd>';  
       if (col==drilldown)
        row_smallscreen+=drilldownURL(r.rows.item(i)[col],append_metadata,links_target,anchor);
       else
        row_smallscreen+=escHTML(r.rows.item(i)[col],links_target);
       row_smallscreen+= '</dd>';
       }
      }
      row_smallscreen+= '</td></tr>';
      $I("table_viz_render_results_smallscreen").innerHTML+= row_smallscreen;
                               }

   if (r.rows.length > 0) {
     var but=$I('table_viz_render_csv_button');
     but.style.display='inline';
     but.onclick= function(){ table_viz_render_execute(null,'csv'); }
    }

   }  // if (!context)

   if (context=='csv') 
    make_csv(r.rows,csv_hidden_columns,'table_viz_render_csv_download_progress',object_name);

                       },$L)
                            },$L,table_viz_render_table_loaded);
}


function table_viz_render_table_loaded() {
 $I('table_viz_render_progress').innerHTML='';
}

function table_viz_render_table_sort(col,dir) {
 var the_object=JSON.parse(localStorage['TABLE_VIZ_OBJECT']);
 var o=JSON.stringify(the_object);
 localStorage["TABLE_VIZ_"+o+"_SORT_FIELD"]=col;
 localStorage["TABLE_VIZ_"+o+"_SORT_DIR"]=dir;
 localStorage["TABLE_VIZ_"+o+"_OFFSET"]=0;
 table_viz_render_execute();
}

function table_viz_render_table_offset(offset) {
 var the_object=JSON.parse(localStorage['TABLE_VIZ_OBJECT']);
 var o=JSON.stringify(the_object);
 var the_offset;
 if ((offset)||(offset==0))
  localStorage['TABLE_VIZ_'+o+'_OFFSET']=offset;
 else
  try {
   localStorage['TABLE_VIZ_'+o+'_OFFSET']=$I('table_viz_render_table_nav_select').value;
      } catch(e) {};
 table_viz_render_execute();
}

function table_viz_render_results_navigation(elem,search_function,total_pages,current_page,total_rows,offset,page_size) {
  var vPREV= Math.floor((current_page-1)*page_size);
  if (vPREV < 0) vPREV=0;
  var vNEXT= Math.floor((current_page+1)*page_size);
  if (vNEXT > total_rows) vNEXT= parseInt(total_rows-offset);
  var vLAST= Math.floor((total_pages-1)*page_size);
  if (vLAST == 0) vLAST=0;
  var vHTML="";
  if (current_page > 0) {
   vHTML+= '<button onclick="'+search_function+'(0);" title="First Page">'+
                  '<i class="fa fa-angle-double-left"></i></button>';
   vHTML+= '<button onclick="'+search_function+'('+vPREV+');" title="Previous Page">'+
                  '<i class="fa fa-angle-left"></i></button>';
   }

  if (total_pages <= 1000) {
   vHTML+= '<select id="table_viz_render_table_nav_select" onchange="table_viz_render_table_offset();">';
   for (var i=0; i<total_pages; i++) {
    if (i == current_page)
     vHTML+= '<option value="'+parseInt(i*page_size)+'" selected="selected">Page</option>';
    else
    vHTML+= '<option value="'+parseInt(i*page_size)+'">'+parseInt(i+1)+'</option>';
   }
   vHTML+= '</select>';
  }

  if (current_page < (total_pages-1)) {
   vHTML+= '<button onclick="'+search_function+'('+vNEXT+');" title="Next Page">'+
                  '<i class="fa fa-angle-right"></i></button>';
   vHTML+= '<button onclick="'+search_function+'('+vLAST+');" title="Last Page">'+
                  '<i class="fa fa-angle-double-right"></i></button>';
   }
  $I(elem).innerHTML=vHTML;
}

function table_viz_render_reset(object_name) {
 $I('table_viz_render_search_input').value='';
 $I('table_viz_render_progress').innerHTML='';
 $I('table_viz_render_results').innerHTML='';
 $I('table_viz_render_results_smallscreen').innerHTML='';
 $I('table_viz_render_summary').innerHTML='';
 $I('table_viz_render_navigation').innerHTML='';
 $I('table_viz_render_csv_button').style.display='none';
 if (object_name) {
  var o=JSON.stringify(object_name);
  localStorage.removeItem("TABLE_VIZ_"+o+'_OFFSET');
  localStorage.removeItem("TABLE_VIZ_"+o+"_SORT_FIELD");
  localStorage.removeItem("TABLE_VIZ_"+o+"_SORT_DIR");
 }
}

function table_viz_render_run(event) {
 if (event.which===13 || 
     event.keyCode===13 || 
     event.key==="Enter")  {
  var object_name=JSON.parse(localStorage['TABLE_VIZ_OBJECT']);
  if (object_name) {
   var o=JSON.stringify(object_name);
   localStorage.removeItem('TABLE_VIZ_'+o+'_OFFSET');
   localStorage.removeItem('TABLE_VIZ_'+o+'_SORT_FIELD');
   localStorage.removeItem('TABLE_VIZ_'+o+'_SORT_DIR');
  }
 table_viz_render_execute();
 }
}

/* ----- End Table Visualization ----- */

/* ----- Begin Chart Visualization ----- */

function chart_viz_object_list() {
 var datalist_options="";
 gDB.transaction(function (t) {
  t.executeSql("select name from (select name from VF_DB_OBJECTS union select name from sqlite_temp_master) order by name asc", null,
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     if (r.rows.item(i)["name"]) {
      var opt= '<option value="'+escATTR(r.rows.item(i)["name"])+'"></option>';
      datalist_options+= opt;
     }
               }   });
                              }, $L, function () { chart_viz_object_list2(datalist_options); } );
}

function chart_viz_object_list2(datalist_options) {
 $I('chart_viz_object_name_list').innerHTML=datalist_options;
}

function chart_viz_populate_column_list(callback) {
 var object_name=$I('chart_viz_object_name').value;
 if (!object_name) return;
 var datalist_options="";
 var numbs=[];
 var numeric_datalist_options="";
 gDB.transaction(function (t) {
  t.executeSql("select * from "+sanitise(object_name)+" limit 50", null,
   function (tx, r) {
    if (r.rows.length >= 1) {
    for (col in r.rows.item(0)) {
      var opt= '<option value="'+escATTR(col)+'"></option>';
      datalist_options+=opt;
      numbs[col]=false;
      }
    // Sample first 50 rows for numbers
    for (var i=0; i<Math.min(r.rows.length,50); i++) {
     if (!numbs[col]) {
      for (col in r.rows.item(i)) {
       if (!r.rows.item(i)) continue;
       if (!isNaN(r.rows.item(i)[col])) numbs[col]=true;
      }
     }
    }
    for (num in numbs)
     if(numbs[num])
      numeric_datalist_options+= '<option value="'+escATTR(num)+'"></option>';	
                            };
			    }) }, $L, 
			          function () { chart_viz_populate_column_list2(datalist_options, numeric_datalist_options, callback); } );
			
}

function chart_viz_populate_column_list2(datalist_options, numeric_options, callback) {
 $I('chart_viz_column_list').innerHTML=datalist_options;
 $I('chart_viz_numeric_column_list').innerHTML=numeric_options;
 if (callback) callback();
}

//Unsure if this gets called
function chart_viz_object_error(e,t) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I("chart_viz_summary").innerHTML=msg;
}

function clear_chart_viz_form() {
 $I('chart_viz_object_name').value='';
 $I('chart_viz_background_color').value='#FFFFFF';
 $I('chart_viz_display_theme').selectedIndex=0;  
 $I('chart_viz_title_type').selectedIndex=0; 
 $I('chart_viz_title_value').value='';
 $I('chart_viz_description').value='';
 $I('chart_viz_task_id').value='';
 $I('chart_viz_links_target').value='';
 $I('chart_viz_drilldown_metadata').checked=false;
 $I('chart_viz_x_axis_column').value='';
 $I('chart_viz_x_axis_order_by_column').value='';
 $I('chart_viz_x_axis_order_by_direction').selectedIndex=0;
 $I('chart_viz_stacked').checked=false;
 $I('chart_viz_series1_type').selectedIndex=0;
 $I('chart_viz_series1_axis_orient').selectedIndex=0;
 $I('chart_viz_series1_y_axis_column').value='';
 $I('chart_viz_series1_drilldown_column').value='';
 $I('chart_viz_series1_color').value='#FF0000';
 $I('chart_viz_series2_type').selectedIndex=0;
 $I('chart_viz_series2_axis_orient').selectedIndex=0;
 $I('chart_viz_series2_y_axis_column').value='';
 $I('chart_viz_series2_drilldown_column').value='';
 $I('chart_viz_series2_color').value='#00FF00';
 $I('chart_viz_series3_type').selectedIndex=0;
 $I('chart_viz_series3_axis_orient').selectedIndex=0;
 $I('chart_viz_series3_y_axis_column').value='';
 $I('chart_viz_series3_drilldown_column').value='';
 $I('chart_viz_series3_color').value='#0000FF';
 $I('chart_viz_series4_type').selectedIndex=0;
 $I('chart_viz_series4_axis_orient').selectedIndex=0;
 $I('chart_viz_series4_y_axis_column').value='';
 $I('chart_viz_series4_drilldown_column').value='';
 $I('chart_viz_series4_color').value='#000000';

 $I('chart_viz_column_list').innerHTML='';
 $I('chart_viz_numeric_column_list').innerHTML='';
 $I('chart_viz_progress').innerHTML='';
 $I('chart_viz_summary').innerHTML='';
 $I('chart_viz_results_smallscreen').innerHTML='';
 $I('chart_viz_results').innerHTML='';
 $I('chart_viz_save_progress').innerHTML='';
 chart_viz_object_list();
}

function save_chart_viz() {
 var chart_viz_object_name=$I('chart_viz_object_name').value;
 var chart_viz_background_color=$I('chart_viz_background_color').value;
 var chart_viz_display_theme=$I('chart_viz_display_theme').value;
 var chart_viz_title_type=$I('chart_viz_title_type').value;
 var chart_viz_title_value=$I('chart_viz_title_value').value;
 var chart_viz_description=$I('chart_viz_description').value;
 var chart_viz_task_id=$I('chart_viz_task_id').value;
 var chart_viz_links_target=$I('chart_viz_links_target').value;
 var chart_viz_drilldown_metadata=(($I('chart_viz_drilldown_metadata').checked)?1:0);
 var chart_viz_x_axis_column=$I('chart_viz_x_axis_column').value;
 var chart_viz_x_axis_order_by_column=$I('chart_viz_x_axis_order_by_column').value;
 var chart_viz_x_axis_order_by_direction=(($I('chart_viz_x_axis_order_by_direction').value)=='desc'?'desc':'asc');
 var chart_viz_stacked=(($I('chart_viz_stacked').checked)?1:0);
 var chart_viz_series1_type=$I('chart_viz_series1_type').value;
 var chart_viz_series1_axis_orient=$I('chart_viz_series1_axis_orient').value;
 var chart_viz_series1_y_axis_column=$I('chart_viz_series1_y_axis_column').value;
 var chart_viz_series1_drilldown_column=$I('chart_viz_series1_drilldown_column').value;
 var chart_viz_series1_color=$I('chart_viz_series1_color').value;
 var chart_viz_series2_type=$I('chart_viz_series2_type').value;
 var chart_viz_series2_axis_orient=$I('chart_viz_series2_axis_orient').value;
 var chart_viz_series2_y_axis_column=$I('chart_viz_series2_y_axis_column').value;
 var chart_viz_series2_drilldown_column=$I('chart_viz_series2_drilldown_column').value;
 var chart_viz_series2_color=$I('chart_viz_series2_color').value;
 var chart_viz_series3_type=$I('chart_viz_series3_type').value;
 var chart_viz_series3_axis_orient=$I('chart_viz_series3_axis_orient').value;
 var chart_viz_series3_y_axis_column=$I('chart_viz_series3_y_axis_column').value;
 var chart_viz_series3_drilldown_column=$I('chart_viz_series3_drilldown_column').value;
 var chart_viz_series3_color=$I('chart_viz_series3_color').value;
 var chart_viz_series4_type=$I('chart_viz_series4_type').value;
 var chart_viz_series4_axis_orient=$I('chart_viz_series4_axis_orient').value;
 var chart_viz_series4_y_axis_column=$I('chart_viz_series4_y_axis_column').value;
 var chart_viz_series4_drilldown_column=$I('chart_viz_series4_drilldown_column').value;
 var chart_viz_series4_color=$I('chart_viz_series4_color').value;

 $I('chart_viz_column_list').innerHTML='';
 $I('chart_viz_numeric_column_list').innerHTML='';
 $I('chart_viz_progress').innerHTML='';

 if (!chart_viz_object_name) {
  notify('Please enter a Table or View');
  return;
  }
 if (!chart_viz_description) {
  notify('Please enter a Description');
  return;
  }
 if (!chart_viz_x_axis_column) {
  notify('Please enter an X-Axis Column');
  return;
  }
 if ((!chart_viz_series1_y_axis_column)&&(!chart_viz_series2_y_axis_column)&&
     (!chart_viz_series3_y_axis_column)&&(!chart_viz_series4_y_axis_column)) {
  notify('Please enter as least one Y-Axis Column');
  return;
 }

 $I('chart_viz_save_progress').innerHTML=gSPIN;
 var now = new Date();
 var save_date = parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_chart_visualization where label = ?", [chart_viz_description]);
   t.executeSql("insert into vf_chart_visualization(label, object_name, background_color, display_theme, title_type, title_value, "+
                "task_id, links_target, drilldown_append_metadata,  "+
		"x_axis_column, x_axis_order_by_column, x_axis_order_by_direction, stacked, "+
		"series1_type, series1_axis_orient, series1_y_axis_column, series1_drilldown_column, series1_color, "+
		"series2_type, series2_axis_orient, series2_y_axis_column, series2_drilldown_column, series2_color, "+
		"series3_type, series3_axis_orient, series3_y_axis_column, series3_drilldown_column, series3_color, "+
		"series4_type, series4_axis_orient, series4_y_axis_column, series4_drilldown_column, series4_color, "+
		"date_saved) "+
		"values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
                [chart_viz_description, chart_viz_object_name, chart_viz_background_color, chart_viz_display_theme, 
		 chart_viz_title_type, chart_viz_title_value, 
		 chart_viz_task_id, chart_viz_links_target, chart_viz_drilldown_metadata, 
		 chart_viz_x_axis_column, chart_viz_x_axis_order_by_column, chart_viz_x_axis_order_by_direction, chart_viz_stacked,
		 chart_viz_series1_type, chart_viz_series1_axis_orient, chart_viz_series1_y_axis_column, 
		  chart_viz_series1_drilldown_column, chart_viz_series1_color,
		 chart_viz_series2_type, chart_viz_series2_axis_orient, chart_viz_series2_y_axis_column, 
		  chart_viz_series2_drilldown_column, chart_viz_series2_color,
		 chart_viz_series3_type, chart_viz_series3_axis_orient, chart_viz_series3_y_axis_column, 
		  chart_viz_series3_drilldown_column, chart_viz_series3_color,
		 chart_viz_series4_type, chart_viz_series4_axis_orient, chart_viz_series4_y_axis_column, 
		  chart_viz_series4_drilldown_column, chart_viz_series4_color,
		 save_date]);
                }, $L, chart_viz_saved);
}

function chart_viz_saved() {
 tick_fade('chart_viz_save_progress');
 list_chart_viz();
}
  
function list_chart_viz() {
 $I('chart_viz_progress').innerHTML=gSPIN;
 $I('chart_viz_summary').innerHTML='';
 $I('chart_viz_results_smallscreen').innerHTML='';
 $I('chart_viz_results').innerHTML='';
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, object_name, title_value, task_id, date_saved from vf_chart_visualization"+
                " order by date(date_saved) desc, label asc", [],
   function (tx, r) {
    var shown="";
    if (r.rows.length > gUNPAGINATED_MAX_ROWS)
     shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
    $I('chart_viz_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved Chart Visualizations "+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td>Description</td>'+
             "<td>Date Saved</td><td>Task Id</td><td>Object Name</td><td>Visualization Title</td>"+
	     "<td>Edit</td><td>Run</td><td>Drop</td></tr>";
     $I('chart_viz_results').innerHTML=msg;
                                      };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
     let row_results='<tr class="rs"><td><a class="blk" href="javascript: '+
                      'handle_chart_viz(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Chart Visualization">'+
                      escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                      '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).OBJECT_NAME)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).TITLE_VALUE)+'</td>'+
                      '<td><button title="Edit" onclick="'+escATTR('handle_chart_viz(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                      '<td><button title="Run" onclick="'+escATTR('handle_chart_viz(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                      '<td><button title="Drop" onclick="'+escATTR('delete_chart_viz('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
     $I('chart_viz_results').innerHTML+= row_results;
     let row_smallscreen='<tr class="rs"><td><dl>'+
      '<dt class="hdrg">Description</dt>'+
      '<dd><a class="blk hdr1" href="javascript: '+
        'handle_chart_viz(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Chart Visualization">'+
         escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
      '<dt class="hdrg">Object</dt>'+
      '<dd>'+escHTML(r.rows.item(i).OBJECT_NAME)+'</dd>'+
      '<dt class="hdrg">Title</dt>'+
      '<dd>'+escHTML(r.rows.item(i).TITLE_VALUE)+'</dd>'+
      '<dt class="hdrg">Date Saved</dt>'+
      '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
      '<dt class="hdrg">Task Id</dt>'+
      '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
      '<dt class="hdrg">Action</dt>'+
      '<dd><button title="Edit" onclick="'+escATTR('handle_chart_viz(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
           '<button title="Run" onclick="'+escATTR('handle_chart_viz(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
           '<button title="Drop" onclick="'+escATTR('delete_chart_viz('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
      '</dd></dl></td></tr>';
      $I('chart_viz_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
                              }, null, chart_viz_list_loaded );
}

function chart_viz_list_loaded(state) {
 $I('chart_viz_progress').innerHTML='';
 chart_viz_populate_column_list();
}

function delete_chart_viz(rowid) {
 $I("chart_viz_save_progress").innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_chart_visualization where rowid = ?", [rowid]);
               }, null, list_chart_viz);
}

function handle_chart_viz(action, rowid, state) {
 var md=null;
 gDB.transaction(function (t) {
  t.executeSql("select * from vf_chart_visualization where rowid = ?", [rowid],
   function (tx, r) {
    md=r.rows.item(0);
    $I('chart_viz_object_name').value=r.rows.item(0).OBJECT_NAME;
    $I('chart_viz_background_color').value=r.rows.item(0).BACKGROUND_COLOR;
    $I('chart_viz_display_theme').value=r.rows.item(0).DISPLAY_THEME;
    $I('chart_viz_title_type').value=r.rows.item(0).TITLE_TYPE;
    $I('chart_viz_title_value').value=r.rows.item(0).TITLE_VALUE;
    $I('chart_viz_description').value=r.rows.item(0).LABEL;
    $I('chart_viz_task_id').value=r.rows.item(0).TASK_ID;
    $I('chart_viz_links_target').value=r.rows.item(0).LINKS_TARGET;
    $I('chart_viz_drilldown_metadata').checked=((r.rows.item(0).DRILLDOWN_APPEND_METADATA>=1)?true:false);
    $I('chart_viz_x_axis_column').value=r.rows.item(0).X_AXIS_COLUMN;
    $I('chart_viz_x_axis_order_by_column').value=r.rows.item(0).X_AXIS_ORDER_BY_COLUMN;
    $I('chart_viz_x_axis_order_by_direction').value=((r.rows.item(0).X_AXIS_ORDER_BY_DIRECTION=='desc')?'desc':'asc');
    $I('chart_viz_stacked').checked=((r.rows.item(0).STACKED>=1)?true:false);
    $I('chart_viz_series1_type').value=r.rows.item(0).SERIES1_TYPE;
    $I('chart_viz_series1_axis_orient').value=r.rows.item(0).SERIES1_AXIS_ORIENT;
    $I('chart_viz_series1_y_axis_column').value=r.rows.item(0).SERIES1_Y_AXIS_COLUMN;
    $I('chart_viz_series1_drilldown_column').value=r.rows.item(0).SERIES1_DRILLDOWN_COLUMN;
    $I('chart_viz_series1_color').value=r.rows.item(0).SERIES1_COLOR;
    $I('chart_viz_series2_type').value=r.rows.item(0).SERIES2_TYPE;
    $I('chart_viz_series2_axis_orient').value=r.rows.item(0).SERIES2_AXIS_ORIENT;
    $I('chart_viz_series2_y_axis_column').value=r.rows.item(0).SERIES2_Y_AXIS_COLUMN;
    $I('chart_viz_series2_drilldown_column').value=r.rows.item(0).SERIES2_DRILLDOWN_COLUMN;
    $I('chart_viz_series2_color').value=r.rows.item(0).SERIES2_COLOR;
    $I('chart_viz_series3_type').value=r.rows.item(0).SERIES3_TYPE;
    $I('chart_viz_series3_axis_orient').value=r.rows.item(0).SERIES3_AXIS_ORIENT;
    $I('chart_viz_series3_y_axis_column').value=r.rows.item(0).SERIES3_Y_AXIS_COLUMN;
    $I('chart_viz_series3_drilldown_column').value=r.rows.item(0).SERIES3_DRILLDOWN_COLUMN;
    $I('chart_viz_series3_color').value=r.rows.item(0).SERIES3_COLOR;
    $I('chart_viz_series4_type').value=r.rows.item(0).SERIES4_TYPE;
    $I('chart_viz_series4_axis_orient').value=r.rows.item(0).SERIES4_AXIS_ORIENT;
    $I('chart_viz_series4_y_axis_column').value=r.rows.item(0).SERIES4_Y_AXIS_COLUMN;
    $I('chart_viz_series4_drilldown_column').value=r.rows.item(0).SERIES4_DRILLDOWN_COLUMN;
    $I('chart_viz_series4_color').value=r.rows.item(0).SERIES4_COLOR;
                  })
                              }, $L, function() { 
						chart_viz_populate_column_list();
			                        if (action=='execute') 
					         run_chart_visualization(rowid,md); 
			                        if (action=='edit') 
					         set_visible_pane('chart_viz_setup');
			                                 } );
}


/* ----- Actual Chart Visualization routines ----- */

function run_chart_visualization(rowid,md) {
 set_visible_pane('chart_viz_render');
 chart_viz_render_prepare(rowid, md);
}

function chart_viz_render_table_error(e,t) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I("chart_viz_render_progress").innerHTML=msg;
}

function chart_viz_render_prepare(rowid, md) {
 var object_name=$I('chart_viz_object_name').value;
 var order_by=$I('chart_viz_x_axis_order_by_column').value;
 var order_by_dir=(($I('chart_viz_x_axis_order_by_direction').value=='desc')?'desc':'asc');
 var QRY = "select t.* from "+sanitise(object_name)+" t "; 
 var ORDER_BY="";
 if (order_by) {
  ORDER_BY=" order by "+sanitise(order_by);
  if (order_by_dir)
   ORDER_BY+=" "+order_by_dir;
 }
 QRY+= ORDER_BY;
 chart_viz_render_run_query(object_name, QRY, rowid, md);
}

function chart_viz_render_run_query(object_name, qry, rowid, md) {
 if (!object_name) {
  try { object_name=$I('chart_viz_object_name').value; } catch(e) {};
 }
 destroy_chart();
 $I('chart_viz_render_progress').innerHTML=gSPIN_2X;
 var md;
 var drilldown=null;
 var links_target=null;
 var anchor=null;
 var append_metadata=false;
 var chart_data={};
 chart_data['type']='bar';
 var datasets=[];
 var labels=[];
 var labels_column=$I('chart_viz_x_axis_column').value;
 var series1_column=$I('chart_viz_series1_y_axis_column').value;
 var series1_drilldown_column=$I('chart_viz_series1_drilldown_column').value;
 var series1_type=$I('chart_viz_series1_type').value.toLowerCase();
 var series1_color=$I('chart_viz_series1_color').value;
 var series1_axis_orient=$I('chart_viz_series1_axis_orient').value.toLowerCase();
 var series1_dataset;
 var pie_color_array;
 var pie_backgroundColor=[];
 var pie_borderColor=[];
 var series1_drilldown=[];
 if (series1_type !== 'pie')
  series1_dataset={ type: series1_type, label: series1_column, borderColor: hexToRGBA(series1_color,1), 
                    backgroundColor: hexToRGBA(series1_color,0.2), borderWidth: 2, yAxisID: series1_axis_orient};
 else {
  series1_dataset={type: series1_type, label: series1_column, borderWidth: 2};
  try {
   var color_string=$I('chart_viz_display_theme').value;
   if (color_string)
    pie_color_array=jQuery.csv.toArray(color_string);
   else
    pie_color_array=['#FF8080','#FFFF80','#80FF80','#00FF80','#80FFFF','#0080FF','#FF80C0','#FF80FF'];
      } catch(e){ pie_color_array=['#FF8080','#FFFF80','#80FF80','#00FF80','#80FFFF','#0080FF','#FF80C0','#FF80FF']; };
  }
  var series1_data=[];
  var series2_column=$I('chart_viz_series2_y_axis_column').value;
  var series2_type=$I('chart_viz_series2_type').value.toLowerCase();
  var series2_drilldown_column=$I('chart_viz_series2_drilldown_column').value;
  var series2_color=$I('chart_viz_series2_color').value;
  var series2_axis_orient=$I('chart_viz_series2_axis_orient').value.toLowerCase();
  var series2_dataset={type: series2_type, label: series2_column, borderColor: hexToRGBA(series2_color,1), 
                       backgroundColor: hexToRGBA(series2_color,0.2), borderWidth: 2, yAxisID: series2_axis_orient};
  var series2_data=[];
  var series3_column=$I('chart_viz_series3_y_axis_column').value;
  var series3_type=$I('chart_viz_series3_type').value.toLowerCase();
  var series3_drilldown_column=$I('chart_viz_series3_drilldown_column').value;
  var series3_color=$I('chart_viz_series3_color').value;
  var series3_axis_orient=$I('chart_viz_series3_axis_orient').value.toLowerCase();
  var series3_dataset={type: series3_type, label: series3_column, borderColor: hexToRGBA(series3_color,1), 
                       backgroundColor: hexToRGBA(series3_color,0.2), borderWidth: 2, yAxisID: series3_axis_orient};
  var series3_data=[];
  var series4_column=$I('chart_viz_series4_y_axis_column').value;
  var series4_type=$I('chart_viz_series4_type').value.toLowerCase();
  var series4_drilldown_column=$I('chart_viz_series4_drilldown_column').value;
  var series4_color=$I('chart_viz_series4_color').value;
  var series4_axis_orient=$I('chart_viz_series4_axis_orient').value.toLowerCase();
  var series4_dataset={type: series4_type, label: series4_column, borderColor: hexToRGBA(series4_color,1), 
                       backgroundColor: hexToRGBA(series4_color,0.2), borderWidth: 2, yAxisID: series4_axis_orient};
  var series4_data=[];
  var options={};
  options['responsive']=true;
  options['maintainAspectRatio']=false;
  var links_target=$I('chart_viz_links_target').value;
  var append_metadata=(($I('chart_viz_drilldown_metadata').checked)?true:false);
  var axis_right=false;
  var axis_left=false;
  if (series1_type != 'pie') {
   axis_left= ((series1_axis_orient=='left')||
               (series2_axis_orient=='left')||
               (series3_axis_orient=='left')||
               (series4_axis_orient=='left'));
   axis_right= ((series1_axis_orient=='right')||
               (series2_axis_orient=='right')||
               (series3_axis_orient=='right')||
               (series4_axis_orient=='right'));
   options['onClick']= function(event, array) {
                        try {
                         var a=window.gTHE_CHART.getElementAtEvent(event);
                         var drilldown=window.gTHE_CHART.config.data.datasets[a[0]._datasetIndex].data[a[0]._index].drilldown;
                         drilldownClick(drilldown, append_metadata, links_target);
			    } catch(e) {};
	              }
   }
  else
   options['onClick']= function(event, array) {
                        try {
                         var a=window.gTHE_CHART.getElementAtEvent(event);
                         var drilldown=window.gTHE_CHART.config.data.datasets[a[0]._datasetIndex].drilldown[a[0]._index];
                         drilldownClick(drilldown, append_metadata, links_target);
			    } catch(e) {};
	              }
  var title_type=$I('chart_viz_title_type').value;
  var title_value=$I('chart_viz_title_value').value;
  if (title_type!='Column Value')
   options['title']={display:true,fontFamily:'Arial',fontSize:16,text:title_value};
  var axis=[];
  var is_stacked=($I('chart_viz_stacked').checked?true:false);
  if (axis_left)
   axis.push({id:'left',position:'left',stacked:is_stacked});
  if (axis_right)
   axis.push({id:'right',position:'right',stacked:is_stacked});
  if (axis.length>0)
  options['scales']={xAxes:[{stacked:is_stacked}],yAxes: axis};
  var background_color=$I('chart_viz_background_color').value;
  gDB.transaction(function (t) {
   t.executeSql(qry, [],
    function (tx, r) {
     if (parseInt(r.rows.length)>gMAX_CHART_ROWS) {
      chart_fallback_fade();	  
      var fallback_md={};
      fallback_md['OBJECT_NAME']=object_name;
      fallback_md['TITLE_TYPE']=title_type;
      fallback_md['TITLE_VALUE']=title_value;
      fallback_md['LINKS_TARGET']=$I('map_viz_links_target').value;
      fallback_md['DRILLDOWN_COLUMN']=
       (series1_drilldown_column||series2_drilldown_column||series3_drilldown_column||series4_drilldown_column);
      fallback_md['DRILLDOWN_LABEL']='Drilldown';
      fallback_md['DRILLDOWN_APPEND_METADATA']=(append_metadata?1:0);
      run_table_visualization(null, fallback_md);
      return;
     }
     if (parseInt(r.rows.length)>0) {
      try {
       if (title_type=='Column Value') {
        options['title']={display:true,text:r.rows.item(0)[title_value]};
       }
     } catch(e) {};
    for (var i=0; i<r.rows.length; i++) {
     labels.push(r.rows.item(i)[labels_column]);
     if (series1_type == 'pie') {
      var val=r.rows.item(i)[series1_column];
      if (!val)
       val=0;
      if (i>gMAX_PIE_HEADER_ROWS)
       options['legend']={display: false};
      pie_backgroundColor.push(hexToRGBA(pie_color_array[(i%pie_color_array.length)],0.5));
      pie_borderColor.push(hexToRGBA(pie_color_array[(i%pie_color_array.length)],1));
      series1_data.push(val);
      series1_drilldown.push(r.rows.item(i)[series1_drilldown_column]);
     } else {
      if (series1_column)
       series1_data.push({y:r.rows.item(i)[series1_column], drilldown:r.rows.item(i)[series1_drilldown_column]});
      if (series2_column)
       series2_data.push({y:r.rows.item(i)[series2_column], drilldown:r.rows.item(i)[series2_drilldown_column]});
      if (series3_column)
       series3_data.push({y:r.rows.item(i)[series3_column], drilldown:r.rows.item(i)[series3_drilldown_column]});
      if (series4_column)
       series4_data.push({y:r.rows.item(i)[series4_column], drilldown:r.rows.item(i)[series4_drilldown_column]});
     }
    }
   }
                       },null,load_chart_tx_err)
                            }, load_chart_tx_err, 
	                       function() {
                                if (series1_type == 'pie') {
                                 //Pie Chart
				 var dataset=[];
                                 series1_dataset['data']=series1_data;
                                 series1_dataset['drilldown']=series1_drilldown;  
                                 series1_dataset['borderColor']=pie_borderColor;
                                 series1_dataset['backgroundColor']=pie_backgroundColor;
				 dataset.push(series1_dataset);
				 chart_data['data']={};
				 chart_data['data']['labels']=labels;
				 chart_data['data']['datasets']=dataset;
				 chart_data['options']=options;
                                 chart_data['type']='pie';
                                } else {
                                 //Line,Bar Chart
                                 series1_dataset['data']=series1_data;
                                 series2_dataset['data']=series2_data;
                                 series3_dataset['data']=series3_data;
                                 series4_dataset['data']=series4_data;
				 var datasets=[];
				 if (series1_column)
				  datasets.push(series1_dataset);
				 if (series2_column)
				  datasets.push(series2_dataset);
				 if (series3_column)
				  datasets.push(series3_dataset);
				 if (series4_column)
				  datasets.push(series4_dataset);
				 chart_data['data']={};
				 chart_data['data']['labels']=labels;
				 chart_data['data']['datasets']=datasets;
				 chart_data['options']=options;
                                }
				draw_chart(chart_data, background_color, object_name);
			});
}


function load_chart_tx_err(e) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I('chart_viz_render_progress').innerHTML=msg;
 update_status();
 //No map button yet displayed, need to return user to a workable pane
 window.setTimeout(function(){set_visible_pane('home');},2000);
}

function draw_chart(chart_data, background_color, object_name) {

	  
 $I('chart_viz_render_progress').innerHTML='';
 var ctx=document.getElementById('chart_viz_the_canvas').getContext('2d');
 if (!background_color)
  background_color='white';
 Chart.plugins.register({
   beforeDraw: function(c) {
       var ctx = c.chart.ctx;
       ctx.fillStyle = background_color;
       ctx.fillRect(0, 0, c.chart.width, c.chart.height);
    }
  });
 gTHE_CHART=new Chart(ctx, chart_data);
 gTHE_CHART_OBJECT_NAME=object_name;
}

function download_chart(){
  if (!gTHE_CHART)
   return;
  var link = document.createElement('a');
  var fname;
  if (!gTHE_CHART_OBJECT_NAME)
   fname='chart.png';
  else
   fname=gTHE_CHART_OBJECT_NAME+'.png';
  link.download=fname;
  link.href = document.getElementById('chart_viz_the_canvas').toDataURL("image/png").replace("image/png", "image/octet-stream");
  link.click();
}

function destroy_chart() {
 try { gTHE_CHART.destroy(); } catch(e) {}
 gTHE_CHART=null;
 gTHE_CHART_OBJECT_NAME=null;
 gTHE_CHART_POINT_RADIUS=3;  //Chartjs default;
}

function toggle_points() {
 try {
  if (gTHE_CHART_POINT_RADIUS==3)
   gTHE_CHART_POINT_RADIUS=8;
  else if (gTHE_CHART_POINT_RADIUS==8)
   gTHE_CHART_POINT_RADIUS=0;
  else
   gTHE_CHART_POINT_RADIUS=3;
  var d=gTHE_CHART.data.datasets;
  for (var i=0; i<d.length; i++) {
   gTHE_CHART.data.datasets[i].pointRadius=gTHE_CHART_POINT_RADIUS;
   gTHE_CHART.data.datasets[i].pointHoverRadius=gTHE_CHART_POINT_RADIUS+1;
   }
  gTHE_CHART.update();
    } catch(e) {};
}

function chart_fallback_fade() {
 $I('chart_fallback_dialog_info').innerHTML=gMAX_CHART_ROWS;
 $I('chart_fallback_dialog').show();
 window.setTimeout(function() { $I('chart_fallback_dialog').close(); }, 4000);
};	  

/* ----- End Chart Visualization ----- */

/* ----- Begin Map Visualization ----- */

function map_viz_object_list() {
 var datalist_options="";
 $I('map_viz_column_list').innerHTML='';
 $I('map_viz_geom_column_list').innerHTML='';
 gDB.transaction(function (t) {
  t.executeSql("select name from (select name from VF_DB_OBJECTS union select name from sqlite_temp_master) order by name asc", null,
   function (tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     if (r.rows.item(i)["name"]) {
      var opt= '<option value="'+escATTR(r.rows.item(i)["name"])+'"></option>';
      datalist_options+= opt;
     }
               }   });
                              }, $L, function () { map_viz_object_list2(datalist_options); } );
}

function map_viz_object_list2(datalist_options) {
 $I('map_viz_object_name_list').innerHTML=datalist_options;
}

function map_viz_populate_column_list(callback) {
 var object_name=$I('map_viz_object_name').value;
 if (!object_name) return;
 var datalist_options="";
 var geoms=[];
 var geom_datalist_options="";
 gDB.transaction(function (t) {
  t.executeSql("select * from "+sanitise(object_name)+" limit 50", null,
   function (tx, r) {
    if (r.rows.length >= 1) {
    for (col in r.rows.item(0)) {
      var opt= '<option value="'+escATTR(col)+'"></option>';
      datalist_options+=opt;
      geoms[col]=false;
      }
    // Sample upto first 50 rows for valid geoms
    for (var i=0; i<Math.min(r.rows.length,50); i++) {
     for (col in r.rows.item(i)) {
      if (!geoms[col]) {
       try { let geom=parse(r.rows.item(i)[col]);
             if (geom.type) geoms[col]=col;
           } catch(e) {};
      }
     }
    }
    for (geom in geoms)
     if(geoms[geom])
      geom_datalist_options+= '<option value="'+escATTR(geom)+'"></option>';	
                            };
			    }) }, $L, 
			          function () { map_viz_populate_column_list2(datalist_options, geom_datalist_options, callback); } );
			
}

function map_viz_populate_column_list2(datalist_options, geom_options, callback) {
 $I('map_viz_column_list').innerHTML=datalist_options;
 $I('map_viz_geom_column_list').innerHTML=geom_options;
 if (callback) callback();
}

//May not be invoked
function map_viz_object_error(e,t) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I("map_viz_summary").innerHTML=msg;
}

function clear_map_viz_form() {
 $I('map_viz_object_name').value='';
 //$I('map_viz_display_theme').value='';
 $I('map_viz_title_type').selectedIndex=0; 
 $I('map_viz_title_value').value='';
 $I('map_viz_description').value='';
 $I('map_viz_task_id').value='';
 $I('map_viz_links_target').value='';
 $I('map_viz_geometry_columns').value='';
 $I('map_viz_tooltip_type').selectedIndex=0;
 $I('map_viz_tooltip_value').value='';
 $I('map_viz_style1_option').selectedIndex=0;
 $I('map_viz_style1_mode').selectedIndex=0;
 $I('map_viz_style1_type').selectedIndex=0;
 $I('map_viz_style1_value').value='';
 $I('map_viz_style2_option').selectedIndex=0;
 $I('map_viz_style2_mode').selectedIndex=0;
 $I('map_viz_style2_type').selectedIndex=0;
 $I('map_viz_style2_value').value='';
 $I('map_viz_style3_option').selectedIndex=0;
 $I('map_viz_style3_mode').selectedIndex=0;
 $I('map_viz_style3_type').selectedIndex=0;
 $I('map_viz_style3_value').value='';
 $I('map_viz_style4_option').selectedIndex=0;
 $I('map_viz_style4_mode').selectedIndex=0;
 $I('map_viz_style4_type').selectedIndex=0;
 $I('map_viz_style4_value').value='';
 $I('map_viz_style5_option').selectedIndex=0;
 $I('map_viz_style5_mode').selectedIndex=0;
 $I('map_viz_style5_type').selectedIndex=0;
 $I('map_viz_style5_value').value='';
 $I('map_viz_style6_option').selectedIndex=0;
 $I('map_viz_style6_mode').selectedIndex=0;
 $I('map_viz_style6_type').selectedIndex=0;
 $I('map_viz_style6_value').value='';
 $I('map_viz_drilldown_column').value='';
 $I('map_viz_drilldown_label').value='';
 $I('map_viz_drilldown_append_metadata').checked=false;

 $I('map_viz_column_list').innerHTML='';
 $I('map_viz_geom_column_list').innerHTML='';
 $I('map_viz_progress').innerHTML='';
 $I('map_viz_summary').innerHTML='';
 $I('map_viz_results_smallscreen').innerHTML='';
 $I('map_viz_results').innerHTML='';
 $I('map_viz_save_progress').innerHTML='';
 map_viz_object_list();
}

function save_map_viz() {
 var map_viz_object_name=$I('map_viz_object_name').value;
 //var map_viz_display_theme=$I('map_viz_display_theme').value;
 var map_viz_title_type=$I('map_viz_title_type').value;
 var map_viz_title_value=$I('map_viz_title_value').value;
 var map_viz_description=$I('map_viz_description').value;
 var map_viz_task_id=$I('map_viz_task_id').value;
 var map_viz_links_target=$I('map_viz_links_target').value;
 var map_viz_geometry_columns=$I('map_viz_geometry_columns').value;
 var map_viz_tooltip_type=$I('map_viz_tooltip_type').value;
 var map_viz_tooltip_value=$I('map_viz_tooltip_value').value;
 var map_viz_style1_option=$I('map_viz_style1_option').value;
 var map_viz_style1_mode=$I('map_viz_style1_mode').value;
 var map_viz_style1_type=$I('map_viz_style1_type').value;
 var map_viz_style1_value=$I('map_viz_style1_value').value;
 var map_viz_style2_option=$I('map_viz_style2_option').value;
 var map_viz_style2_mode=$I('map_viz_style2_mode').value;
 var map_viz_style2_type=$I('map_viz_style2_type').value;
 var map_viz_style2_value=$I('map_viz_style2_value').value;
 var map_viz_style3_option=$I('map_viz_style3_option').value;
 var map_viz_style3_mode=$I('map_viz_style3_mode').value;
 var map_viz_style3_type=$I('map_viz_style3_type').value;
 var map_viz_style3_value=$I('map_viz_style3_value').value;
 var map_viz_style4_option=$I('map_viz_style4_option').value;
 var map_viz_style4_mode=$I('map_viz_style4_mode').value;
 var map_viz_style4_type=$I('map_viz_style4_type').value;
 var map_viz_style4_value=$I('map_viz_style4_value').value;
 var map_viz_style5_option=$I('map_viz_style5_option').value;
 var map_viz_style5_mode=$I('map_viz_style5_mode').value;
 var map_viz_style5_type=$I('map_viz_style5_type').value;
 var map_viz_style5_value=$I('map_viz_style5_value').value;
 var map_viz_style6_option=$I('map_viz_style6_option').value;
 var map_viz_style6_mode=$I('map_viz_style6_mode').value;
 var map_viz_style6_type=$I('map_viz_style6_type').value;
 var map_viz_style6_value=$I('map_viz_style6_value').value;
 var map_viz_drilldown_column=$I('map_viz_drilldown_column').value;
 var map_viz_drilldown_label=$I('map_viz_drilldown_label').value;
 var map_viz_drilldown_append_metadata=(($I('map_viz_drilldown_append_metadata').checked)?1:0);

 $I('map_viz_column_list').innerHTML='';
 $I('map_viz_geom_column_list').innerHTML='';
 $I('map_viz_progress').innerHTML='';

 if (!map_viz_object_name) {
  notify('Please enter a Table or View');
  return;
  }
 if (!map_viz_description) {
  notify('Please enter a Description');
  return;
  }
 if (!map_viz_geometry_columns) {
  notify('Geometry Column is required.');
  return;
 }
 $I('map_viz_save_progress').innerHTML=gSPIN;
 var now = new Date();
 var save_date = parseInt(now.getFullYear())+"-"+parseInt(now.getMonth()+1)+"-"+parseInt(now.getDate());
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_map_visualization where label = ?", [map_viz_description]);
   t.executeSql("insert into vf_map_visualization(label, object_name,  title_type, title_value, "+
                "task_id, links_target, geometry_columns, tooltip_type, tooltip_value, "+
		"style1_option, style1_mode, style1_type, style1_value, "+
		"style2_option, style2_mode, style2_type, style2_value, "+
		"style3_option, style3_mode, style3_type, style3_value, "+
		"style4_option, style4_mode, style4_type, style4_value, "+
		"style5_option, style5_mode, style5_type, style5_value, "+
		"style6_option, style6_mode, style6_type, style6_value, "+
		"drilldown_column, drilldown_label, drilldown_append_metadata, "+
		"date_saved) "+
		"values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
                [map_viz_description, map_viz_object_name, map_viz_title_type, map_viz_title_value, 
		 map_viz_task_id, map_viz_links_target, map_viz_geometry_columns, map_viz_tooltip_type, map_viz_tooltip_value,
		 map_viz_style1_option, map_viz_style1_mode, map_viz_style1_type, map_viz_style1_value,
		 map_viz_style2_option, map_viz_style2_mode, map_viz_style2_type, map_viz_style2_value,
		 map_viz_style3_option, map_viz_style3_mode, map_viz_style3_type, map_viz_style3_value,
		 map_viz_style4_option, map_viz_style4_mode, map_viz_style4_type, map_viz_style4_value,
		 map_viz_style5_option, map_viz_style5_mode, map_viz_style5_type, map_viz_style5_value,
		 map_viz_style6_option, map_viz_style6_mode, map_viz_style6_type, map_viz_style6_value,
		 map_viz_drilldown_column, map_viz_drilldown_label, map_viz_drilldown_append_metadata,
		 save_date]);
                }, $L, map_viz_saved);
}

function map_viz_saved() {
 tick_fade('map_viz_save_progress');
 list_map_viz();
}
  
function list_map_viz() {
 $I('map_viz_progress').innerHTML=gSPIN;
 $I('map_viz_summary').innerHTML='';
 $I('map_viz_results_smallscreen').innerHTML='';
 $I('map_viz_results').innerHTML='';
 gDB.transaction(function (t) {
  t.executeSql("select rowid, label, object_name, title_value, task_id, date_saved from vf_map_visualization"+
                " order by date(date_saved) desc, label asc", [],
   function (tx, r) {
    var shown="";
    if (r.rows.length > gUNPAGINATED_MAX_ROWS)
     shown="(displaying <b>"+gUNPAGINATED_MAX_ROWS+"</b>)";
    $I('map_viz_summary').innerHTML="Found <b>"+parseInt(r.rows.length)+"</b> saved Map Visualizations "+shown;
    if (parseInt(r.rows.length)>0) {
     let msg='<tr class="hdr1 bold"><td style="width: 30%">Description</td>'+
             "<td>Date Saved</td><td>Task Id</td><td>Object Name</td><td>Visualization Title</td>"+
	     "<td>Edit</td><td>Run</td><td>Drop</td></tr>";
     $I('map_viz_results').innerHTML=msg;
                                      };
     for (var i=0; i<Math.min(r.rows.length,gUNPAGINATED_MAX_ROWS); i++) {
     let row_results='<tr class="rs"><td><a class="blk" href="javascript: '+
                      'handle_map_viz(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Map Visualization">'+
                      escHTML(r.rows.item(i).LABEL)+'</a></td>'+
                      '<td>'+escHTML(r.rows.item(i).DATE_SAVED)+'</td><td>'+escHTML(r.rows.item(i).TASK_ID)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).OBJECT_NAME)+'</td>'+
                      '<td>'+escHTML(r.rows.item(i).TITLE_VALUE)+'</td>'+
                      '<td><button title="Edit" onclick="'+escATTR('handle_map_viz(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button></td>'+
                      '<td><button title="Run" onclick="'+escATTR('handle_map_viz(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button></td>'+
                      '<td><button title="Drop" onclick="'+escATTR('delete_map_viz('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button></td></tr>';
     $I('map_viz_results').innerHTML+= row_results;
     let row_smallscreen='<tr class="rs"><td><dl>'+
      '<dt class="hrdg">Description</dt>'+
      '<dd><a class="blk" href="javascript: '+
        'handle_map_viz(\'execute\','+escHTML(r.rows.item(i).rowid)+');" title="Run Map Visualization">'+
         escHTML(r.rows.item(i).LABEL)+'</a></dd>'+
      '<dt class="hdrg">Object</dt>'+
      '<dd>'+escHTML(r.rows.item(i).OBJECT_NAME)+'</dd>'+
      '<dt class="hdrg">Title</dt>'+
      '<dd>'+escHTML(r.rows.item(i).TITLE_VALUE)+'</dd>'+
      '<dt class="hrdg">Date Saved</dt>'+
      '<dd>'+escHTML(r.rows.item(i).DATE_SAVED)+'</dd>'+
      '<dt class="hdrg">Task Id</dt>'+
      '<dd>'+escHTML(r.rows.item(i).TASK_ID)+'</dd>'+
      '<dt class="hdrg">Action</dt>'+
      '<dd><button title="Edit" onclick="'+escATTR('handle_map_viz(\'edit\','+qescape(r.rows.item(i).rowid)+');')+'">'+gEDIT+'</button>'+
           '<button title="Run" onclick="'+escATTR('handle_map_viz(\'execute\','+qescape(r.rows.item(i).rowid)+');')+'">'+gRUN+'</button>'+
           '<button title="Drop" onclick="'+escATTR('delete_map_viz('+qescape(r.rows.item(i).rowid)+');')+'">'+gDROP+'</button>'+
      '</dd></dl></td></tr>';
       $I('map_viz_results_smallscreen').innerHTML+= row_smallscreen;
                               }
                     })
                              }, null, map_viz_list_loaded );
}

function map_viz_list_loaded(state) {
 $I('map_viz_progress').innerHTML='';
 map_viz_populate_column_list();
}

function delete_map_viz(rowid) {
 $I("map_viz_save_progress").innerHTML='';
 gDB.transaction(
  function(t) {
   t.executeSql("delete from vf_map_visualization where rowid = ?", [rowid]);
               }, null, list_map_viz);
}

function handle_map_viz(action, rowid, state) {
 gDB.transaction(function (t) {
  t.executeSql("select * from vf_map_visualization where rowid = ?", [rowid],
   function (tx, r) {
    $I('map_viz_object_name').value=r.rows.item(0).OBJECT_NAME;
    //$I('map_viz_display_theme').value=r.rows.item(0).DISPLAY_THEME;
    $I('map_viz_title_type').value=r.rows.item(0).TITLE_TYPE;
    $I('map_viz_title_value').value=r.rows.item(0).TITLE_VALUE;
    $I('map_viz_description').value=r.rows.item(0).LABEL;
    $I('map_viz_task_id').value=r.rows.item(0).TASK_ID;
    $I('map_viz_links_target').value=r.rows.item(0).LINKS_TARGET;
    $I('map_viz_geometry_columns').value=r.rows.item(0).GEOMETRY_COLUMNS;
    $I('map_viz_tooltip_type').value=r.rows.item(0).TOOLTIP_TYPE;
    $I('map_viz_tooltip_value').value=r.rows.item(0).TOOLTIP_VALUE;
    $I('map_viz_style1_option').value=r.rows.item(0).STYLE1_OPTION;
    $I('map_viz_style1_mode').value=r.rows.item(0).STYLE1_MODE;
    $I('map_viz_style1_type').value=r.rows.item(0).STYLE1_TYPE;
    $I('map_viz_style1_value').value=r.rows.item(0).STYLE1_VALUE;
    $I('map_viz_style2_option').value=r.rows.item(0).STYLE2_OPTION;
    $I('map_viz_style2_mode').value=r.rows.item(0).STYLE2_MODE;
    $I('map_viz_style2_type').value=r.rows.item(0).STYLE2_TYPE;
    $I('map_viz_style2_value').value=r.rows.item(0).STYLE2_VALUE;
    $I('map_viz_style3_option').value=r.rows.item(0).STYLE3_OPTION;
    $I('map_viz_style3_mode').value=r.rows.item(0).STYLE3_MODE;
    $I('map_viz_style3_type').value=r.rows.item(0).STYLE3_TYPE;
    $I('map_viz_style3_value').value=r.rows.item(0).STYLE3_VALUE;
    $I('map_viz_style4_option').value=r.rows.item(0).STYLE4_OPTION;
    $I('map_viz_style4_mode').value=r.rows.item(0).STYLE4_MODE;
    $I('map_viz_style4_type').value=r.rows.item(0).STYLE4_TYPE;
    $I('map_viz_style4_value').value=r.rows.item(0).STYLE4_VALUE;
    $I('map_viz_style5_option').value=r.rows.item(0).STYLE5_OPTION;
    $I('map_viz_style5_mode').value=r.rows.item(0).STYLE5_MODE;
    $I('map_viz_style5_type').value=r.rows.item(0).STYLE5_TYPE;
    $I('map_viz_style5_value').value=r.rows.item(0).STYLE5_VALUE;
    $I('map_viz_style6_option').value=r.rows.item(0).STYLE6_OPTION;
    $I('map_viz_style6_mode').value=r.rows.item(0).STYLE6_MODE;
    $I('map_viz_style6_type').value=r.rows.item(0).STYLE6_TYPE;
    $I('map_viz_style6_value').value=r.rows.item(0).STYLE6_VALUE;
    $I('map_viz_drilldown_column').value=r.rows.item(0).DRILLDOWN_COLUMN;
    $I('map_viz_drilldown_label').value=r.rows.item(0).DRILLDOWN_LABEL;
    $I('map_viz_drilldown_append_metadata').checked=((r.rows.item(0).DRILLDOWN_APPEND_METADATA>=1)?true:false);
                  })
                              }, $L, function() { 
						    map_viz_populate_column_list();
				                    if (action=='execute') 
					             run_map_visualization(rowid, state); 
				                    if (action=='edit') 
					             set_visible_pane('map_viz_setup');
			                                 } );
}

function run_map_visualization(rowid, state) {
 destroy_map();
 $I('map_title').innerHTML='';
 set_visible_pane('map_container');
 $I('map_render_progress').innerHTML=gSPIN_2X;
 var the_object=$I('map_viz_object_name').value;
 gDB.transaction(function (t) {
  t.executeSql("select * from "+sanitise(the_object), [],
   function (tx, r) { render_map(r,state); },null,null);
  },load_map_tx_err,null);
}

function load_map_tx_err(e) {
 var msg= '<span class="error">'+escHTML(e.message)+'</span>';
 $I('map_render_progress').innerHTML=msg;
 update_status();
 //No map button yet displayed, need to return user to a workable pane
 window.setTimeout(function(){set_visible_pane('home');},2000);
}

function render_map(dataset, state) {

 if ((dataset)&&(dataset.rows)&&(dataset.rows.length>gMAX_MAP_ROWS)) {
  map_fallback_fade();	  
  var fallback_md={};
  fallback_md['OBJECT_NAME']=$I('map_viz_object_name').value;
  fallback_md['TITLE_TYPE']=$I('map_viz_title_type').value;
  fallback_md['TITLE_VALUE']=$I('map_viz_title_value').value;
  fallback_md['LINKS_TARGET']=$I('map_viz_links_target').value;
  fallback_md['DRILLDOWN_COLUMN']=$I('map_viz_drilldown_column').value;
  fallback_md['DRILLDOWN_LABEL']=$I('map_viz_drilldown_label').value;
  fallback_md['DRILLDOWN_APPEND_METADATA']=($I('map_viz_drilldown_append_metadata').checked?1:0);
  run_table_visualization(null, fallback_md);
  return;
 }
	  
 var hidden_columns=[];
 var geom_array=[];
 var coincident_points=false;
 var point_index={};

 var GEOM_COLUMN=$I('map_viz_geometry_columns').value;
 hidden_columns.push(GEOM_COLUMN);

 // Map Title
 var title_type=$I('map_viz_title_type').value;
 var title_value=$I('map_viz_title_value').value;
 $I('map_title').innerHTML='';
 if (title_type!='Column Value')
   $I('map_title').innerHTML=escHTML(title_value);
 else
  try {
   $I('map_title').innerHTML=escHTML(dataset.rows.item(0)[title_value]);
   hidden_columns.push(title_value);
      } catch(e) {};

 //Map Tooltip
 var tooltip_type=$I('map_viz_tooltip_type').value;
 var tooltip_value=$I('map_viz_tooltip_value').value;

 var link_target=$I('map_viz_links_target').value;

 var drilldown=$I('map_viz_drilldown_column').value;
 var anchor=$I('map_viz_drilldown_label').value;
 var append_metadata=(($I('map_viz_drilldown_append_metadata').checked)?true:false);
 if (!anchor) anchor='Drilldown';

 var all_points=true;
 var geom_idx=0;
 for (var i=0; i<dataset.rows.length; i++) {
  var geom;
   try {
    geom=wkt2geojson(dataset.rows.item(i)[GEOM_COLUMN]); 
    if (geom) {
     geom_array[geom_idx]={geometry:geom,data_idx:i};
     var gtype=turf.getType(geom);
     if (gtype.toLowerCase()=='point') {
      if (point_index[dataset.rows.item(i)[GEOM_COLUMN]])
       coincident_points=true
      else
       point_index[dataset.rows.item(i)[GEOM_COLUMN]]=true;
      } else
      all_points=false;
     } 
     geom_idx++;
   } catch(e) {};
  }

 var use_clusters=((all_points)&&((dataset.rows.length>=gMAX_UNCLUSTERED_POINTS)||(coincident_points)));

 gTHE_MAP=L.map('map').setView([0,0],2);
 L.easyButton('fa-bars easy', function() {set_visible_pane('home'); destroy_map(); },'Menu',gTHE_MAP).addTo(gTHE_MAP);
 L.easyButton('fa-th-large easy', function() { save_offline_tiles();},'Save Offline Map Tiles',gTHE_MAP).addTo(gTHE_MAP);

 var tile_url=get_simple_value('CONFIG_MAP_BASE_URL');
 var tile_url_is_safe=safeURL(tile_url.replace(/\{/g,'').replace(/\}/g,''));
 if (tile_url_is_safe) {
  var tile_attrib=escATTR(get_simple_value('CONFIG_MAP_ATTRIBUTION'));
  //L.tileLayer(tile_url,{attribution:tile_attrib,maxZoom:24}).addTo(gTHE_MAP);
  gMAP_TILE_LAYER=cachingTileLayer(tile_url,{attribution:tile_attrib,maxZoom:24}).addTo(gTHE_MAP);
 }

 gTHE_MAP_FEATURES=[];
 var feat_idx=0;
 for (var i=0; i<geom_array.length; i++) {
  var feat=null;
  try { feat=toFeature(geom_array[i].geometry); } catch(e) { /* Ingore empty geoms */};
  if (!feat) { continue };
  if (!feat.properties) feat.properties={};

  var regular_style={};
  var hover_style={};
  for (var j=1; j<=6; j++) {
   var style_option=$I('map_viz_style'+j.toString()+'_option').value;
   var style_mode=$I('map_viz_style'+j.toString()+'_mode').value;
   var style_type=$I('map_viz_style'+j.toString()+'_type').value;
   var style_value=$I('map_viz_style'+j.toString()+'_value').value;
   var the_value=null;
   if (style_value) {
    if (style_type == 'Column Value')
     try {the_value= escHTML(dataset.rows.item(geom_array[i].data_idx)[style_value]) 
          if (hidden_columns.indexOf(style_value) <0) hidden_columns.push(style_value); 
         } catch(e) {}

    else
     the_value=escHTML(style_value);
   }; 
   if ((the_value)&&(style_option)) {
    if (['stroke'].indexOf(style_option) >= 0)  //Special case for boolean style options
     the_value=(the_value.toLowerCase()=='true');
    if (style_mode == 'regular')
     regular_style[style_option]=the_value;
    else
     hover_style[style_option]=the_value;
					 }
  }
  feat.properties.hover=hover_style;
  feat.properties.index=feat_idx;

  var tooltip;
  if (tooltip_type=='Column Value')
   try {
     tooltip=escHTML(dataset.rows.item(i)[tooltip_value]);
     if (hidden_columns.indexOf(tooltip_value) <0) hidden_columns.push(tooltip_value); 
        } catch(e) {}
  else
   tooltip=tooltip_value;

  var popup=map_feature_popup(dataset.rows.item(i),hidden_columns,link_target,drilldown,append_metadata,anchor);

  var opts = {
   onEachFeature: function(feature, layer) {
        if (tooltip)
         layer.bindTooltip(tooltip);
	if (popup)
	 layer.bindPopup(popup,{maxHeight:240});
	layer.on("mouseover", function (e) {
               if (feature.properties.hover)
                this.setStyle(feature.properties.hover);
               });
        layer.on("mouseout", function (e) {
		gTHE_MAP_FEATURES[feature.properties.index].resetStyle(this);
            })
          },
       pointToLayer: function (feature, latlng) {
	return L.circleMarker(latlng);
				 },
       style: regular_style
       };
  gTHE_MAP_FEATURES[feat_idx]=L.geoJSON(feat,opts);
  feat_idx++; 
 }

 if (use_clusters) {
   gTHE_MAP_CLUSTER_LAYER = L.markerClusterGroup();
   for (var i=0; i<gTHE_MAP_FEATURES.length; i++) 
    gTHE_MAP_CLUSTER_LAYER.addLayer(gTHE_MAP_FEATURES[i]);
   gTHE_MAP_CLUSTER_LAYER.addTo(gTHE_MAP);
   gTHE_MAP.fitBounds(gTHE_MAP_CLUSTER_LAYER.getBounds(),{padding:[50,50],maxZoom:18}); 
  } else {
   gTHE_MAP_FEATURE_LAYER = L.featureGroup(gTHE_MAP_FEATURES);
   gTHE_MAP_FEATURE_LAYER.addTo(gTHE_MAP);
   gTHE_MAP.fitBounds(gTHE_MAP_FEATURE_LAYER.getBounds(),{padding:[50,50],maxZoom:18}); 
  }

 $I('map_render_progress').innerHTML='';

}


function map_feature_popup(row, hidden_columns, link_target, drilldown, append_metadata, anchor) {
  if (!hidden_columns)
   hidden_columns = [];
  var have_data=false;
  var popup='<dl>';
  for (col in row) 
   if (hidden_columns.indexOf(col)<0) {
    have_data=true;
    popup+= '<dt class="hdrg">'+escHTML(col,link_target)+'</dt>';
    if (col==drilldown)
     popup+= '<dd>'+drilldownURL(row[col],append_metadata,link_target,anchor)+'</dd>';
    else
     popup+= '<dd>'+escHTML(row[col],link_target)+'</dd>';
   }
 popup+='</dl>';
 return ((have_data)?popup:null); 
}


function destroy_map() {
 try { gTHE_MAP.remove(); } catch(e) {}
 gTHE_MAP=null;
 gTHE_MAP_OBJECT_NAME=null;
 gTHE_MAP_FEATURES=[];
 gTHE_MAP_FEATURE_LAYER=null;
 gTHE_MAP_CLUSTER_LAYER=null;
 gMAP_TILE_LAYER=null;
}

function map_fallback_fade() {
 $I('map_fallback_dialog_info').innerHTML=gMAX_MAP_ROWS;
 $I('map_fallback_dialog').show();
 window.setTimeout(function() { $I('map_fallback_dialog').close(); }, 4000);
};	  

/* ----- End Map Visualization ----- */

/* ----- Begin Caching Tile Store (offline Map Tiles ----- */
// (some parts of this code was inspired from both the leaflet.offline)

var gSAVE_TILE_COUNTER=0;
var gTILE_REQUEST_COUNTER=0;
var gOT_THROBBER_TIMEOUT;

function countOfflineTilesStore(theMode) {
 var totalRows='?';
 gDB.transaction(function(t) {
  t.executeSql("select count(*) as TOTAL_TILES from VF_TILE_STORE", [],
   function(tx, r) {
    if (parseInt(r.rows.length)>0)  {
     totalRows= r.rows.item(0)["TOTAL_TILES"];
     }
    else 
     totalRows= '?';
                   });
                              }, 
                          function() { 
                            if (theMode == 'delete') 
                             prepareDelete(totalRows);
                            else
                             prepareToLoad(totalRows);
                                      },
                          function() { 
                            if (theMode == 'delete') 
                             prepareDelete(totalRows);
                            else
                             prepareToLoad(totalRows);
                                      });
  
};
 

function prepareDelete(totalRows) {
 deleteMapTileStore();
}

function deleteMapTileStore() {
 map_dialog_close();
 gDB.transaction(function(t) {
  t.executeSql("delete from VF_TILE_STORE", []);}, null, null);
}

function prepareToLoad(totalRows) {

 $I('map_render_progress').innerHTML=gSPIN_2X;

 var minZoom=4;
 var maxZoom=22;
 var theMap=gTHE_MAP;
 var theLayer=gMAP_TILE_LAYER;

 var zoomCumTileCount={};
 var softTileLimit=5000;

 var bounds=null;
 var zoomLevels=[];
 var tileUrls=[];
 var currentZoom=gTHE_MAP.getZoom();
 var latlngBounds=gTHE_MAP.getBounds();
 
 if (currentZoom < minZoom) {
   notify("Current Zoom level ("+currentZoom.toString()+
          ") is below minimum Zoom level ("+minZoom.toString()+"). "+
          "Zoom in further before downloading Offline Tiles.");
   return;
  }

 if (currentZoom >= maxZoom) {
   notify("Current Zoom level ("+currentZoom.toString()+
          ") is above maximum Zoom level ("+maxZoom.toString()+"). "+
          "Zoom out further before downloading Offline Tiles.");
   return;
  }
 
 for (var zoom = currentZoom; zoom <= maxZoom; zoom++) {
   zoomLevels.push(zoom);
  }
  
 for (var i = 0; i < zoomLevels.length; i++) {
   if (tileUrls.length < softTileLimit) {
    bounds = L.bounds(theLayer._map.project(latlngBounds.getNorthWest(), zoomLevels[i]),
                      theLayer._map.project(latlngBounds.getSouthEast(), zoomLevels[i]));
    tileUrls = tileUrls.concat(theLayer.getTileUrls(bounds, zoomLevels[i]));
    //zoomCumTileCount.push(i);
    zoomCumTileCount[zoomLevels[i]]= tileUrls.length;
   }
  }

 // Setup dialog
 $I('ot_current_zoom').innerHTML=escHTML(currentZoom);
 $I('ot_current_tiles').innerHTML=escHTML(totalRows);

 $I('ot_max_container').innerHTML='';
 var vHTML='<select id="ot_max_zoom">'; 
 vHTML+= '<option value="-1" selected="selected">Select Zoom Level to Fetch</option>';
 for (i in zoomCumTileCount) {
  if (i > currentZoom)
   vHTML+= '<option value="'+parseInt(i)+'">To level '+
              escHTML(parseInt(i).toString())+' ('+escHTML(parseInt(zoomCumTileCount[i]).toString())+' tiles)</option>';
  }
 vHTML+= '</select>';
 $I('ot_max_container').innerHTML=vHTML;
 $I('ot_max_zoom').onchange= function() { prepareToFetchTiles(); };
 $I('map_tile_dialog').show();
 $I('map_render_progress').innerHTML=null;
}

function map_dialog_close() {
 $I('map_tile_dialog').close();
}

// Invoked from dialog - starts actual download
function prepareToFetchTiles() {

 map_dialog_close();

 var minZoom=4;
 var maxZoom=$I('ot_max_zoom').value;
 var theMap=gTHE_MAP;
 var theLayer=gMAP_TILE_LAYER;

 var bounds=null;
 var zoomLevels=[];
 var tileUrls=[];
 var currentZoom;
 try { currentZoom = parseInt($("#ot_current_zoom").html());
       if (!currentZoom)
        currentZoom = theMap.getZoom();
     } catch(e) { currentZoom = theMap.getZoom(); };
  
 var latlngBounds = theMap.getBounds();

 // Values have been previously validated (check for non selected value)
 if (maxZoom < 0)
  return; 

 for (var zoom = currentZoom; zoom <= maxZoom; zoom++) 
  { zoomLevels.push(zoom); }
 
 for (var i = 0; i < zoomLevels.length; i++) {
   bounds = L.bounds(theLayer._map.project(latlngBounds.getNorthWest(), zoomLevels[i]),
                     theLayer._map.project(latlngBounds.getSouthEast(), zoomLevels[i]));
   tileUrls = tileUrls.concat(theLayer.getTileUrls(bounds, zoomLevels[i]));
  }

 fetchOfflineTiles(tileUrls);
}

function save_offline_tiles() {
 countOfflineTilesStore('prepare');
}

function setTileSrc(theLayer, coords, theTile) {
 var url = L.TileLayer.prototype.getTileUrl.call(theLayer, coords);
 var dbStorageKey = theLayer._getStorageKey(url);

 gDB.transaction(function(t) {
  t.executeSql("select CONTENT, CONTENT_TYPE from VF_TILE_STORE where KEY=?", [dbStorageKey],
   function(tx, r) {
    if (parseInt(r.rows.length)>0)  {
      // Got cache hit
      let content=r.rows.item(0)["CONTENT"];
      let content_type=r.rows.item(0)["CONTENT_TYPE"];
      let byte_array=JSON.parse(content);
      let Ui=new Uint8Array(byte_array);
      let theBlob=new Blob([Ui], {type: content_type});
      theTile.src=URL.createObjectURL(theBlob);
       }
     else 
      theTile.src = url;
                   });
                            }, function() { theTile.src=url; }, null);
 };
 

function saveOfflineTile(theKey, theUrl, encoded_content, content_type) {
 var now=new Date();
 var date_saved=JSON.stringify(now);
 gDB.transaction(function(t) {
  t.executeSql("delete from VF_TILE_STORE where KEY = ?", [theKey]);
  t.executeSql("insert into VF_TILE_STORE(KEY, URL, CONTENT, CONTENT_TYPE, ENCODING_ALGORITHM, DATE_SAVED) values (?,?,?,?,?,?)", 
	       [theKey, theUrl, encoded_content, content_type, '1', date_saved]);
                              },  $L, function(a,b) { saveOfflineTileIncrement(); });
};
 
   
function saveOfflineTileIncrement() {
 gSAVE_TILE_COUNTER= parseInt(gSAVE_TILE_COUNTER+1);
 ot_throbber_update(gSAVE_TILE_COUNTER);
};
  
function fetchOfflineTiles(tileUrls) {
 for (var i=0; i < tileUrls.length; i++) {
  retrieveOfflineTile(tileUrls[i].url, tileUrls[i].key);
 };
};
 
async function retrieveOfflineTile(theUrl, theKey) {
 var the_headers={};
 var response;
 response=await fetch(theUrl);

 const reader = response.body.getReader();
 var content_type="";
 for(let entry of response.headers.entries()) {
  if (entry[0].toLowerCase() == 'content-type')
   content_type=entry[1];
 }

 let receivedLength=0; 
 let chunks=[];
 while(true) {
  const {done, value} = await reader.read();
  if (done) break;
  chunks.push(value);
  receivedLength+=value.length;
 }
 // concatenate chunks into single Uint8Array
 let chunksAll=new Uint8Array(receivedLength);
 let position=0;
 for(let chunk of chunks) {
  chunksAll.set(chunk,position); 
  position+=chunk.length;
 }

 var u=chunksAll.entries();
 go=true;
 var saved=[];
 while (go) {
  var a=u.next().value;
  if (!a) { go=false; continue;}
  saved.push(a[1]);
 }

 var encoded_content=JSON.stringify(saved);

 saveOfflineTile(theKey, theUrl, encoded_content, content_type);
}

function ot_throbber_update(c) {
 var txt='<span style="color:blue;font-size:32px;margin:6px;background:rgba(255,255,255,0.8);pointer-events:none">'+
	  escHTML(c.toString())+'</span>';
 $I('map_render_progress').innerHTML=txt;
 try { clearTimeout(gOT_THROBBER_TIMEOUT); } catch(e) {};
 gOT_THROBBER_TIMEOUT = setTimeout(ot_throbber_quiese, 10000);
}

// Quiese and reset count if no offline tiles loaded in 10 seconds
function ot_throbber_quiese() {
 $I('map_render_progress').innerHTML='';
 gTILE_REQUEST_COUNTER=0;
 gSAVE_TILE_COUNTER=0;
}

/* Some inspiration comes from Leaflet-Offline */
var CachingTileLayer = L.TileLayer.extend({

	initialize: function (url, options) {

		this._url = url;

		options = L.Util.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
	}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},


	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	// If the URL does not change, the layer will not be redrawn unless
	// the noRedraw parameter is set to false.
	setUrl: function (url, noRedraw) {
		if (this._url === url && noRedraw === undefined) {
			noRedraw = true;
		}

		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.Util.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.Util.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		//tile.src = this.getTileUrl(coords);

		setTileSrc(this, coords, tile);

		return tile;
	},

        /**
         * Gets the URLs for all the tiles that are inside the given bounds.
         * Every element of the result array is in this format:
         * {key: <String>, url: <String>}. The key is the key used on the
         * database layer to find the tile image offline. The URL is the
         * location from where the tile image will be downloaded.
         * 
         * @param {Object} bounds The bounding box of the tiles.
         * @param {Number} zoom The zoom level of the bounding box.
         * @returns {Array} An array containing all the URLs inside the given
         * bounds.
         */
        getTileUrls: function (bounds, zoom) {
            var tiles = [];
            var originalurl = this._url;

            this.setUrl(this._url.replace('{z}', zoom), true);

            var tileBounds = L.bounds(
                bounds.min.divideBy(this.getTileSize().x).floor(),
                bounds.max.divideBy(this.getTileSize().x).floor()
            );
  
            for (var i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
                for (var j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
                    var tilePoint = new L.Point(i, j);
                    var url = L.TileLayer.prototype.getTileUrl.call(this, tilePoint);

                    tiles.push({
                        'key': this._getStorageKey(url),
                        'url': url,
                    });
                }
            }

          this.setUrl(originalurl, true);

          return tiles;

        },

        /**
         * Determines the key that will be used on the database layer given
         * a URL.
         * 
         * @param {String} url The URL of a tile image.
         * @returns {String} The key that will be used on the database layer
          * to find a tile image.
         */
        _getStorageKey: function (url) {
            var key = null;

            if (url.indexOf('{s}')) {
                var regexstring = new RegExp('[' + this.options.subdomains.join('|') + ']\.');
                key = url.replace(regexstring, this.options.subdomains['0'] + '.');
            }

            return key || url;
        }
 
      });

var cachingTileLayer= function (url, options) {
    return new CachingTileLayer(url, options);
      };
  

/* ----- End Caching Tile Store (offline Map Tiles ----- */


/* ----- Begin Metadata support functions ----- */

function cr_metadata(encode) {
 var encode=($I('export_encode_uri').checked);
 var reset=($I('export_reset_db').checked);
 cr_metadata_increment('', 0, encode, reset);
}

function cr_metadata_increment(table_meta, offset, encode, reset) {
 if (offset >= gVF_DEFINITION.TABLES.length) {
  cr_metadata_config(table_meta, encode, reset);
  return;
 }
 if (table_meta) table_meta+=',';
 var the_table=gVF_DEFINITION.TABLES[offset].TABLE;
 var the_columns='';
 for (var c=0; c<gVF_DEFINITION.TABLES[offset].COLUMNS.length; c++) {
  if (the_columns) the_columns+=',';
  the_columns+= sanitise(gVF_DEFINITION.TABLES[offset].COLUMNS[c].column);
 }
 var the_sql='select '+the_columns+' from '+sanitise(the_table);

 var next_offset=offset+1;
 table_meta+='\n  '+JSON.stringify(the_table)+': [';   
 var col_array=[];
 gDB.transaction(function(t) {
  t.executeSql(the_sql,[],
   function(tx, r) {
    for (var i=0; i<r.rows.length; i++) {
     if (i!=0) table_meta+=',';
     var col_array='\n   [';
     var first_col=true;
     for (var col in r.rows.item(i)) {
      if (first_col) 
       first_col=false; 
      else 
       col_array+=','; 
      var val=JSON.stringify(r.rows.item(i)[col]);
      col_array+= val;
      }
     col_array+= ']';
    table_meta+= col_array;
    }
   table_meta+= '\n  ]';
                   });
		     }, $L, function() { cr_metadata_increment(table_meta, next_offset, encode, reset); });
}


// Add config params and finalize metadata download												      
function get_config_params() {
 var config=gVF_DEFINITION.CONFIG;
 var config_json_string='';
 for (var i=0; i<config.length; i++) {
  if (config_json_string)
   config_json_string+=',';
  config_json_string+= JSON.stringify(localStorage[config[i].param]);
 }
 return config_json_string;
}

function cr_metadata_config(table_meta, encode, reset) {
 var config='\n "CONFIG": ['+ get_config_params()+']';
 var full_table_meta='\n "TABLES": {'+table_meta+'\n }';
 var reset_db='';
 if (reset)
  reset_db=',\n "RESET_DB": true';
 var META='{"VERSION": "1",'+config+reset_db+','+full_table_meta+'\n}';
 if (encode) {
  var encodedMETADATA=encodeURIComponent(META);
  download_file(encodedMETADATA,'METADATA.txt','text/plain');
 } else
 download_file(META,'METADATA.json','text/json');
}

// Metadata element File Drag and Drop functions

function setup_metadata_file_dd() {
 var fileInput=$I('metadatafile');
 var dropzone = document.querySelector('.metadatafilediv');
 fileInput.addEventListener('change', function(evt) {
  dropzone.classList.remove('dragover');
  var f = evt.target.files[0];
  var reader = new FileReader();
  reader.onload = (function(e) {file_metadata_drop(e,f); });
  reader.readAsText(f);
 });
 fileInput.addEventListener('dragenter', function() {
  dropzone.classList.add('dragover');
 });
 fileInput.addEventListener('dragleave', function() {
  dropzone.classList.remove('dragover');
 });
}

function file_metadata_drop(e,f) {
 var data=e.target.result;
 var parsed=null;
 try { parsed=JSON.parse(data); }
  catch(e) {
   try { parsed=JSON.parse(decodeURIComponent(data)); }
   catch(e) { parsed=null; }
  }
 if (parsed) {
  gMETADATA=data;
  gMETADATA_PARSED=parsed;
  if (gMETADATA_PARSED.VERSION) {
   tick_fade('metadata_import_progress');
   load_config(3);  // flow 3 - Metadata Import
  }
 }
}

function metadata_reset() {
 $I('metadata_reset_progress').innerHTML=gSPIN;
 reset_config(true);
 dropTables(4);  // flow 4 - Metadata Resest
}

/* ----- End Metadata support functions ----- */


/* ----- Begin Sequence Execution rutime functions (core engine) ----- */

// var state={task_list: null, offset: null, db_task_list: null, db_offset: null}

function run_task_sequence(state) {
 if (!state) return;
 if (!state.offset) state.offset=0;
 if ((!state.task_list)||(state.offset+1 > state.task_list.length)) {
  update_favicon(0);
  $I('status_tasks_remaining').innerHTML='';
  gSHOW_STATUS=false;
  return;
 }
 let remaining=state.task_list.length-state.offset;
 update_favicon(remaining);
 $I('status_tasks_remaining').innerHTML=escHTML(remaining.toString());
 select_db_tasks(state);
}

function select_db_tasks(state) {
 var the_task_id= state.task_list[state.offset];
 state.db_task_list=[];
 state.db_offset=0;

 // Device Attributes
 var dev_task=get_simple_value('CONFIG_DEVICE_ATTRIBUTES_TASK_ID');
 if ((dev_task)&&(dev_task==the_task_id))
  state.db_task_list.push({object_type: 'DEVICE ATTRIBUTES', label: 'Device Attributes', rowid: dev_task}); 

 gDB.transaction(
  function(t) {
   t.executeSql("select 'TABLE IMPORT' as object_type, TABLE_NAME as label, rowid from VF_TABLES where uri_task_id = ? "+
                "union all " +
                "select 'SQL' as object_type, label, rowid from VF_SQL where task_id = ? "+ 
                "union all "+
                "select 'PROMPT' as object_type, label, rowid from VF_PROMPT_INPUT where task_id = ? "+
                "union all "+
                "select 'FUNCTION' as object_type, label, rowid from VF_CUSTOM_FUNCTION where task_id = ? "+ 
                'union all '+
                "select 'TABLE VISUALIZATION' as object_type, label, rowid from VF_TABLE_VISUALIZATION where task_id = ?"+
                'union all '+
                "select 'CHART VISUALIZATION' as object_type, label, rowid from VF_CHART_VISUALIZATION where task_id = ?"+
                'union all '+
                "select 'MAP VISUALIZATION' as object_type, label, rowid from VF_MAP_VISUALIZATION where task_id = ?", 
                [the_task_id, the_task_id, the_task_id, the_task_id, the_task_id, the_task_id, the_task_id],

    function (tx, r) {
      for (let i=0; i<r.rows.length; i++) { 
       state.db_task_list.push(r.rows.item(i));
            }
         });

                 }, null, function() { run_db_task(state); });
}
        
function run_db_task(state) {
 if (!state.db_offset) state.db_offset=0;
 if (((!state.db_task_list)||
     (state.db_task_list.length==0))||
     (state.db_offset+1 > state.db_task_list.length)) {
  $I('status_current_task_id').innerHTML='';
  $I('status_current_task_type').innerHTML='';
  $I('status_current_task_description').innerHTML='';
  state.offset++;
  run_task_sequence(state);
  return;
 } 
 run_task(state);
}

function run_task(state) {
 try {
  gSHOW_STATUS=(parseInt(get_simple_value('CONFIG_SHOW_STATUS'))>=1);
 } catch(e) { gSHOW_STATUS=false; }

 var obj_type = state.db_task_list[state.db_offset].object_type;
 var rowid = state.db_task_list[state.db_offset].rowid;
 var label=state.db_task_list[state.db_offset].label;
 if (label.length>150) label=label.substr(0,150)+'... ';

 //Update status'
 $I('status_current_task_id').innerHTML=escHTML(state.task_list[state.offset]);
 $I('status_current_task_type').innerHTML=escHTML(obj_type);
 $I('status_current_task_description').innerHTML=escHTML(label);

 if (obj_type == 'TABLE IMPORT') {
  execute_saved_table(rowid, state, false);
  return;
 }

 if (obj_type == 'SQL') {
  handle_saved_sql('execute',rowid, state);
  return;
 }

 if (obj_type == 'PROMPT') {
  handle_prompt('execute', rowid, state);
  return;
 }

 if (obj_type == 'FUNCTION') {
  handle_cf('execute', rowid, state);
  return;
 }

 if (obj_type == 'TABLE VISUALIZATION') {
  handle_table_viz('execute', rowid);
  sequence_termination();
  return;
  }

 if (obj_type == 'CHART VISUALIZATION') {
  handle_chart_viz('execute', rowid);
  sequence_termination();
  return;
 }

 if (obj_type == 'MAP VISUALIZATION') {
  handle_map_viz('execute', rowid);
  sequence_termination();
  return;
 }

 if (obj_type == 'DEVICE ATTRIBUTES') {
  handle_device_attributes('execute', state); 
  //Actually rowid is the task id in this case.
  return;
 }

 // Otherwise skip
 state.db_offset++;
 run_db_task(state);
}

function sequence_termination() {
 // Used for visualization tasks that will terminate a sequence
 update_favicon(0);
 gSHOW_STATUS=false;
 $I('status_tasks_remaining').innerHTML='0';
 $I('status_current_task_id').innerHTML='';
 $I('status_current_task_type').innerHTML='';
 $I('status_current_task_description').innerHTML='';
}

function execute_saved_table(rowid, state, browse) {
 var use_cache=false;
 set_visible_pane('urlimport');
 gDB.transaction(function (t) {
   t.executeSql("select TABLE_NAME as table_name, "+
                       "URI uri, "+
                       "CHARSET charset, "+
                       "SEPARATOR separator, "+
                       "CUSTOM_SEPARATOR custom_separator, "+
                       "DELIMITER delimiter, "+
                       "CUSTOM_DELIMITER custom_delimiter, "+
                       "SKIP_FIRST_LINES skip_first_lines, "+
                       "HEADER_ROW header_row,"+
                       "EMPTY_AS_NULL empty_as_null, "+
                       "IS_TEMP is_temp, "+
                       "URI_TASK_ID uri_task_id, " +
                       "LAST_TABLE_REFRESH last_table_refresh, "+
                       "URI_CACHE_MAX_AGE uri_cache_max_age, "+
                       "URI_HEADER_NAME1 uri_header_name1, "+
                       "URI_HEADER_VALUE1 uri_header_value1, "+
                       "URI_HEADER_NAME2 uri_header_name2, "+
                       "URI_HEADER_VALUE2 uri_header_value2 "+
                       " from VF_TABLES where rowid = ? ", [rowid],
     function (tx, r) {
      var tup = r.rows.item(0);
      $I("urlurl").value=tup.uri;
      //$I("urldelim").options[0].selected=true;
      $I("urldelim").value=tup.delimiter;
      $I("urlcustomdelim").value=tup.custom_delimiter;
      if (tup.delimiter == 'Custom')
       $I("urlcustomdelim").disabled=false;
      else
       $I("urlcustomdelim").disabled=true;
      //$I("urlsep").options[0].selected=true;
      $I('urlsep').value= tup.separator;
      $I("urlcustomsep").value=tup.custom_separator;
      if (tup.separator == 'Custom')
       $I("urlcustomsep").disabled=false;
      else
       $I('urlcustomsep').disabled=true;
      $I("urlskiplines").value=(tup.skip_first_lines||0);
      $I("urlheader").checked=(tup.header_row) ? true : false;
      $I("urlasnull").checked=(tup.empty_as_null) ? true : false;
      $I("urltablename").value=tup.table_name;
      $I("urltabletemp").checked=(tup.is_temp) ? true : false;
      $I("urltaskid").value=tup.uri_task_id;
      $I("urlmaxage").value=tup.uri_cache_max_age;  
      $I("urlheadername1").value=tup.uri_header_name1;
      $I("urlheadervalue1").value=tup.uri_header_value1;
      $I("urlheadername2").value=tup.uri_header_name2;
      $I("urlheadervalue2").value=tup.uri_header_value2;
      $I("urlextract").innerHTML="";
      url_progress('');

      try {
       var last = new Date(JSON.parse(tup.last_table_refresh));
       var max_age = parseInt(tup.uri_cache_max_age);
       if (!max_age)
        max_age=0;
       var now= new Date();
       var diff= parseInt((now-last)/1000);
       if (diff <= max_age)
         use_cache=true;
       } catch(e) { use_cache=false; };

                  })
                              }, null, function() { 
			                 if (use_cache)
					  next_task(state);
					 else
					  url_fetch(null,state,browse); } );
}

/* ----- End Sequence Execution rutime functions (core engine) ----- */

/* ===== End Core functions (heavy lifters)  ===== */


/* ----- Begin API page helpers -----*/

function build_api_page_helpers() {
  var defn=gVF_DEFINITION;
  var conf='<dl>';
  for (var i=0; i<defn.CONFIG.length; i++) {
	   let indx=(i+1).toString();
           conf+='<dt>Index Element: '+escHTML(indx)+'</dt>'+
	   '<dd>Internal Name: '+escHTML(defn.CONFIG[i].param)+'</dd>'+
	   '<dd>Meaning: '+escHTML(defn.CONFIG[i].help)+'</dd>';
	   }
  conf+='</dl>';
  $I('api_config').innerHTML=conf;

  var table_options='<option value="0">Select</option>';
  for (var i=0; i<defn.TABLES.length; i++) {
   table_options+='<option value="'+escATTR(i.toString())+'">'+
		  defn.TABLES[i].TABLE+'</option>';
  }
  $I('api_tables').innerHTML=table_options;
}

function show_api_table_helper(i) {
 if (i<0) {
  $I('api_table_detail')='';
  return;
 }
 var defn=gVF_DEFINITION.TABLES[i];
 var blurb='<dl>'+
           '<dt>Table:<dt><dd>'+escHTML(defn.TABLE)+'</dd></dt>'+
	   '<dt>Help (purpose)</dt><dd>'+escHTML(defn.help)+'</dd></dt>'+
	   '<dt>Applicable Screens</dt><dd>'+escHTML(defn.applicable_screens)+'</dd></dt>'+
	   '<dt>Number of Columns</dt><dd>'+escHTML(defn.COLUMNS.length)+'</dd></dt>'+
	   '<dt>Column Array</dt><dd><dl>';
 for (var c=0; c<defn.COLUMNS.length; c++) {
  let indx=(c+1).toString();
  blurb+= '<dt>Column Index: '+escHTML(indx)+'</dt>'+
          '<dd>Column: '+escHTML(defn.COLUMNS[c].column)+'</dd>'+
          '<dd>Help: '+escHTML(defn.COLUMNS[c].help)+'</dd>';
 }
 blurb+='</dl></dl>'; 
 $I('api_table_detail').innerHTML=blurb;
}

function build_cf_api_select() {
 var cf_function_opts='<option value="-1">Select</option>';
 for (var i=0; i<VF_CUSTOM_FUNCTIONS.length; i++)
  cf_function_opts+= '<option value="'+escATTR(VF_CUSTOM_FUNCTIONS[i].id.toString())+'">'+
                      escHTML(VF_CUSTOM_FUNCTIONS[i].library+':'+VF_CUSTOM_FUNCTIONS[i].name)+
		      ' ('+escHTML(VF_CUSTOM_FUNCTIONS[i].id.toString())+') </option>';
 $I('api_functions').innerHTML=cf_function_opts;
}

function show_api_function_helper(idx) {
 if (idx < 0) return;
 var the_function_offset=gCF_IDX[idx];
 var fn=VF_CUSTOM_FUNCTIONS[the_function_offset];
 var blurb='<dl>'+
           '<dt>ID:<dt><dd>'+escHTML(fn.id)+'</dd></dt>'+
	   '<dt>Library</dt><dd>'+escHTML(fn.library)+'</dd></dt>'+
	   '<dt>Name</dt><dd>'+escHTML(fn.name)+'</dd></dt>'+
	   '<dt>Type</dt><dd>'+escHTML(fn.type)+'</dd></dt>'+
	   '<dt>Parameters</dt><dd><dl>';
 for (var p=0; p<fn.parameters.length; p++) {
  blurb+= '<dt>Name: '+escHTML(fn.parameters[p].name)+'</dt>'+
          '<dd>Help: '+escHTML(fn.parameters[p].help)+'</dd>'+
          '<dd>Optional: '+escHTML(fn.parameters[p].optional.toString())+'</dd>'+
          '<dd>Default Value: '+escHTML(fn.parameters[p].default)+'</dd>';
 }
 blurb+='</dl>'; 
 blurb+='<dt>Function:</dt><dd>'+escHTML(fn.func.toString())+'</dd>';
 blurb+='</dl>';

 $I('api_function_detail').innerHTML=blurb;
}

/* ----- End API page helpers -----*/

</script>

<script>
// Example of adding your own Custom Function definition.
// Just place a reference, or link to an external script, here
// And push your Custom Function definitions onto the VF_CUSTOM_FUNCTIONS array
// You will need to specify;
// 1) A Uniquie Id (do not used existing allocated Id's)
// 2) An arbitrary library name - this is just a free text label used for grouping
// 3) A name for your function
// 4) A function type - leave this as "immutable" for deterministic functions
// 5) A help line.
// 6) A parameters array, which consists of;
//    a) The "name" of the parameter
//    b) A "help" line of text
//    c) An "optional" true/false setting indicating whether a value is required
//    d) An optional "default" value for this parameter
// 7) A "func" javascript function that will accept an array of parameters and return 
//	a scalar value or throw an exception with an error message.
// Eg;
/*
VF_CUSTOM_FUNCTIONS.push(
{ id: 9999,
library: "MyFunctions",
name: "Add_X_Y",
type: "immutable",
help: "This is an example of an extra added Custom Function.  Returns X plus Y.",
parameters: [{name: "X", help: "X", optional: false, default: null},
	{name: "Y", help: "Y", optional: false, default: null}],
func: function(params) { return parseFloat(params[0])+parseFloat(params[1]) }
});
*/
</script>                       

</head>
<body>
<!-- Begin Page Support elements -->
<datalist id="query_string_list"></datalist>

<dialog id="map_fallback_dialog" style="z-index:5000;position:absolute;top:100px;background:#FFF9F9;">
<div>
<h4>Falling back to Table Visualization ...</h4>
<p>This results set has<br/>
more than <b><span id="map_fallback_dialog_info"></span></b> features.<br/>
Which is too large to render<br/>
as a Map Visualization.
</p>
</div>
</dialog>

<dialog id="chart_fallback_dialog" style="z-index:5000;position:absolute;top:100px;background:#FFF9F9;">
<div>
<h4>Falling back to Table Visualization ...</h4>
<p>This results set has<br/>
more than <b><span id="chart_fallback_dialog_info"></span></b> rows.<br/>
Which is too large to render<br/>
as a Chart Visualization.
</p>
</div>
</dialog>
<!-- End Page Support elements -->

<!-- Begin Main Content -->
<!-- - - - - - - - - -  -->
<div style="height: 100vh; display: block; overflow-x: auto;">

<!-- Begin Nav Bar -->
<div class="topnav" id="navdiv">
<div class="dropdown">
<button class="dropbtn"><i class="fa fa-play" style="color:cyan;"></i></button>
<div class="dropdown-content" id="menu_dropdown"><a><em>No Menu Items Defined</em></a></div>
</div>
<div class="dropdown">
<button class="dropbtn">Create <i class="fa fa-caret-down"></i> </button>
<div class="dropdown-content">
<a href="javascript:go_import_file();">Table (Import File)</a>
<a href="javascript:go_url_import();">Table (Import URL)</a>
<a href="javascript:go_sql();">SQL statement</a>
<a href="javascript:go_custom_function();">Custom Function</a>
<a href="javascript:go_table_viz_setup();">Table Visualization</a>
<a href="javascript:go_chart_viz_setup();">Chart Visualization</a>
<a href="javascript:go_map_viz_setup();">Map Visualization</a>
<a href="javascript:go_prompt();">Prompt Input</a>
<a href="javascript:go_sequence();">Sequence</a>
<a href="javascript:go_run_menu()">Define <i class="fa fa-play" ></i> Menu</a>
<a href="javascript:go_device_attributes();">Device Attributes</a>
<a href="javascript:go_pageload();">On Page Load</a>
</div>
</div> 
<div class="dropdown">
<button class="dropbtn">Dictionary <i class="fa fa-caret-down"></i> </button>
<div class="dropdown-content">
<a href="javascript:go_browse();">Browse</a>
<a href="javascript:go_browse('VF_TABLES');">Browse VF Tables</a>
<a href="javascript:go_browse('VF_DB_OBJECTS');">Browse All DB Objects</a>
<a href="javascript:go_browse('VF_QUERY_STRING');">Show Query String</a>
<a href="javascript:go_browse('VF_DEVICE_ATTRIBUTES');">Show Device Attributes</a>
<a href="javascript:go_metadata_export();">Export Metadata</a>
<a href="javascript:go_metadata_import();">Import Metadata</a>
<a href="javascript:go_metadata_reset();">Reset Metadata</a>
</div>
</div>
<div class="dropdown">
<button class="dropbtn">Help <i class="fa fa-caret-down"></i> </button>
<div class="dropdown-content">
<a href="javascript:go_config();">Config</a>
<a href="javascript:go_reference_guide();">Reference</a>
<a href="javascript:go_api_guide();">API Guide</a>
<a href="javascript:go_tips();">General Help</a>
<a href="javascript:go_status();">Status</a>
<a href="javascript:set_visible_pane('home');">Home</a>
<a href="javascript:go_about();">About</a>
</div>
</div>
<a href="javascript:void(0);" style="font-size:15px;" class="icon" onclick="NavRender()">&#9776;</a>
</div>
<!-- End Nav Bar -->


<!-- Begin Device Attributes Pane -->
<div id="device_attributes" style="padding-left: 10px">
<h3>Collect Device Attributes</h3>
<dl>
<dt><span class="required">Task Id</span></dt>
<dd><input type="number" value="" id="device_attributes_task_id" style="width:60px"/></dd>
</dl>
<p>
<button title="Save" onclick="set_device_attributes()"><i class="fa fa-save"></i> Save</button><span id="device_attributes_status"></span>
<button title="Run" onclick="run_device_attributes();"><i class="fa fa-arrow-circle-right"></i> Run</button>
<button title="Reset" onclick="reset_device_attributes();">Reset</button>
</div>
<!-- End Device Attributes Pane -->


<!-- Begin Pageload Pane -->
<div id="pageload" style="padding-left: 10px">
<h3>On Page Load</h3>
<dl>
<dt><span class="required">Run Task Id</span></dt>
<dd><select oninput="pageload_task_type_change();" onchange="pageload_task_type_change();" id="pageload_task_type">
  <option value="Literal Constant">Literal Constant</option>
  <option value="Query String">Query String Param</option>
</select>
<input type="text" value="" id="pageload_task_value" style="width:120px"/></dd>
</dl>
<p>
<button title="Save" onclick="set_pageload()"><i class="fa fa-save"></i> Save</button><span id="pageload_status"></span>
<button title="Run" onclick="run_pageload(true);"><i class="fa fa-arrow-circle-right"></i> Run</button>
<button title="Reset" onclick="reset_pageload();">Reset</button>
</div>
<!-- End Pageload Pane -->


<!-- Begin Home Pane -->
<div id="home" style="padding-left: 10px;">
<h3>Visual Field</h3>
<label class="filelabel">
<div class="quickfilediv">Drop your CSV file here to Import and Browse</div>
<input type="file" id="quickfile">
</label> <span id="quickreadstatus" style="margin: 20px;"></span>
<p style="font-size: smaller;">
<span style="color:blue;"><em>Explore, Process and Visualize your data right in your browser.</em></span>
<br/>
<span class="application"></span>
<a href="http://visualfield.org">visualfield.org</a>
</p>
</div>
<!-- Begin Home Pane -->

<!-- Begin File Import Pane -->
<div id="fileimport" style="padding-left: 10px">
<h3>Import File</h3>
<label class="filelabel">
<div class="filediv">Click or drop delimited file here</div>
<input type="file" id="thefile">
</label> <span id="filereadstatus" style="margin: 20px;"></span>
<p>Preview</p>
<p><pre id="fileextract" class="preview"></pre>
<p><span style="color: blue; font-size: smaller;" id="filedescription"></span></p>
<p>Charset: <input style="width: 50px" placeholder="UTF-8" disabled="disabled" />
<p><label>Separator <select id="filesep" oninput="filesepchange();">
		     <option value=",">Comma ,</option>
		     <option value=";">Semicolon ;</option>
		     <option value="|">Pipe |</option>
		     <option value=" ">Space </option>
		     <option value="\t">Tab \t</option>
		     <option value="Custom">Custom</option>
	      </select></label>
&nbsp; &nbsp; <label>Custom <input type="text" style="width: 18px" maxlength="1" disabled="disabled" id="filecustomsep"/></label>
<p><label>Delimiter <select id="filedelim" oninput="filedelimchange();">
		     <option value='"'>Double Quote "</option>
		     <option value="'">Single Quote '</option>
		     <option value="Custom">Custom</option>
	     </select></label>
&nbsp; &nbsp; <label>Custom <input type="text" style="width: 18px" maxlength="1" disabled="disabled" id="filecustomdelim"/></label>
<p><label>Skip first <input type="number" style="width: 50px" id="fileskiplines" value="0"> lines.</label>&nbsp; &nbsp;
<label>Header row <input type="checkbox" checked="checked" id="fileheader"></label> &nbsp; &nbsp; 
<label>Empty Fields as Null <input type="checkbox" checked="checked" id="fileasnull"></label>
<p><label><span class="required">Destination Table</span> <input type="search" id="filetablename" onkeyup="file_table_enter(event);" style="width: 240px; max-width: 40%;"/></label> 
<label>Temp <input type="checkbox" id="filetabletemp"></label></p>
<p><label>After Import, start Task Id <input type="number" style="width: 50px" id="filetaskid"/></label>&nbsp;
<label>Automate Import next time <input type="checkbox" id="fileauto"/></label></p>
<p><button title="Import" id="filebutton" onclick="create_file_table_metadata(false,false,null);"><i class="fa fa-arrow-circle-right"></i> Import</button>
<button title="Import and Browse" onclick="create_file_table_metadata(false,true,null);">
<i class="fa fa-arrow-circle-right"></i> <i class="fa fa-table"></i> Import + Browse</button>
<button title="Save without Importing" onclick="filelist_save();"><i class="fa fa-save"></i> Save (No Import)</button> 
<span id="filelist_save_progress"></span>
<button title="List Defined File Imports" onclick="list_fileimports();"><i class="fa fa-list"></i> List</button>
<button title="Reset" onclick="filelist_reset();">Reset</button>
</p>
<p><span class="importstatus"></span></p>
<div>
<p><span id="filelist_progress"></span><span id="filelist_summary"></span></p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px);"><tbody id="filelist_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only">
<table class="rs"><tbody id="filelist_results" class="rs"></tbody></table>
</div>
<span id="filelist_navigation"> </span> <!-- Not Implemented -->
</div>
</p>
</div>
</div>
<!-- End File Import Pane -->

<!-- Begin URL Import Pane -->
<div id="urlimport" style="padding-left: 10px">
<h3>Import URL</h3>
<p><label><span class="required">URL</span>
<input type="search" id="urlurl" style="width: 360px; max-width: 70%"/></label>  <span class="urlprogress" style="color: blue;"></span></p>
<p>Preview <button title="Fetch URL but do not Import" onclick="url_fetch(true,null,false);"><i class="fa fa-cloud-download"></i> Fetch (preview only)</button></p>
<p><pre id="urlextract" class="preview"></pre></p>
<p><span style="color: blue; font-size: smaller;" id="urldescription"></span></p>
<p>Charset: <input style="width: 50px" placeholder="UTF-8" disabled="disabled" /></p>
<div style="display: inline-block">
<label>Separator <select id="urlsep" oninput="urlsepchange();">
		     <option value=",">Comma ,</option>
		     <option value=";">Semicolon ;</option>
		     <option value="|">Pipe |</option>
		     <option value=" ">Space </option>
		     <option value="\t">Tab \t</option>
		     <option value="Custom">Custom</option>
	      </select></label>
&nbsp; &nbsp; <label>Custom <input type="text" style="width: 18px" maxlength="1" disabled="disabled" id="urlcustomsep"/></label>
<p>
<label>Delimiter <select id="urldelim" oninput="urldelimchange();">
		     <option value='"'>Double Quote "</option>
		     <option value="'">Single Quote '</option>
		     <option value="Custom">Custom</option>
	     </select></label>
&nbsp; &nbsp; <label>Custom <input type="text" style="width: 18px" maxlength="1" disabled="disabled" id="urlcustomdelim"/></label>
</p>
<p>
<label>Skip first <input type="number" style="width: 50px" id="urlskiplines" value="0"> lines.</label>&nbsp; &nbsp;
<label>Header row <input type="checkbox" checked="checked" id="urlheader"></label> &nbsp; &nbsp; 
<label>Empty Fields as Null <input type="checkbox" checked="checked" id="urlasnull"></label>
</p>
<p>
<label><span class="required">Destination Table</span> 
<input type="search" id="urltablename" onkeyup="url_table_enter(event);" style="width: 240px; max-width: 40%;"/></label> 
<label>Temp <input type="checkbox" id="urltabletemp"></label>
</p>
<p>
<label>Save as Task Id <input type="number" style="width: 50px" id="urltaskid"/></label>&nbsp; &nbsp;
<label>Cache Max-Age <input type="number" placeholder="0" style="width:60px" id="urlmaxage" value="0"/> seconds</label>
</p>
</div>
<div style="display: inline-block;">
  <p><label>URL Header 1 <input type="text" placeholder="name" id="urlheadername1"/> 
	  <input type="text" placeholder="value" id="urlheadervalue1"/></label></p>
  <p><label>URL Header 2 <input type="text" placeholder="name" id="urlheadername2"/> 
	     <input type="text" placeholder="value" id="urlheadervalue2"/></label></p>
</div>
<p>
<button title="Import" id="urlbutton" onclick="url_fetch(false,null,false);"><i class="fa fa-arrow-circle-right"></i> Import</button>
<button title="Import then Browse" onclick="url_fetch(false,null,true);">
<i class="fa fa-arrow-circle-right"></i> <i class="fa fa-table"></i> Import + Browse</button>
<button title="Save definition without Importing" onclick="urllist_save();">
<i class="fa fa-save"></i> Save (No Import)</button> <span id="urllist_save_progress"></span> 
<button title="List Defined URL import definitions" onclick="list_urlimports();"><i class="fa fa-list"></i> List</button>
<button title="Reset" id="urlreset" onclick="new_url();">Reset</button></p>
</p>
<p><span class="importstatus"></span></p>
<div>
<p><span id="urllist_progress"> </span><span id="urllist_summary"> </span></p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px);"><tbody id="urllist_results_smallscreen" class="rs"></tbody></table>

</div>
<div class="largescreen_only"> 
<table class="rs"><tbody id="urllist_results" class="rs"></tbody></table>
</div>
<span id="urllist_navigation"> </span> <!-- Not Implemented -->
</div>
</p>
</div>
</div>
<!-- End URL Import Pane -->

<!-- Begin Config Pane -->
<div id="config" style="padding-left: 10px">
<div style="display:inline-block">
<h3>General Config</h3>
<dl>
<dt>Database Name</dt>
<dd><input id="db_name" type="text" style="width: 50px;" disabled="disabled" value="vf"/></dd>
<dt>Database Size</dt>
<dd><input type="number" style="width:50px;" id="db_size"/> Mb</dd>
<dt>Maximum sequence task expansion</dt>
<dd><select id="sequence_limit">
<option>20</option>
<option>50</option>
<option>75</option>
<option>100</option>
<option>150</option>
<option>200</option>
<option>500</option>
</select> tasks</dd>
<dt>Show Status Pane during Sequence Execution</dt> 
<dd><input type="checkbox" id="show_status_page"/></dd>
<dt>Truncate display of displayed fields after</dt>
<dd><select id="field_size">
 <option>1000</option>
 <option>2000</option>
 <option>5000</option>
 <option>10000</option>
 <option>50000</option>
</select> characters</dd>
</dl>
</div>
<div style="display:inline-block">
<h3>Table Config</h3>
<dl>
<dt>Table Page Size</dt>
<dd><select id="page_size">
<option>10</option>
<option>20</option>
<option>50</option>
<option>100</option>
</select> rows</dd>
</dl>
</div>
<div style="display:inline-block">
<h3>Map Config</h3>
<dl>
<dt>Map Base Layer Tile URL <span style="font-size:x-small;">(EPSG: 3857,900913)</span></dt>
<dd><input id="map_base_tile_url" type="search" style="width:200px" placeholder="URL"/>
<span id="map_base_tile_url_status"></span>
</dd>
<dt>Map Base Layer Attribution</dt>
<dd><input id="map_base_tile_attribution" type="search" style="width:200px" placeholder="Attribution"/>
<span id="map_base_tile_attribution_status"></span>
</dd>
<dt><em>Sample Base Layers</em></dt>
<dd><select onchange="set_sample_base_layer(this);" id="map_base_sample_layers"></select></dd>
</dl>
</div>
<p><em><b>Device Attributes</b> and <b>On Page Load</b> are included in Config settings</em></p>
<p>
<button title="Save Config" onclick="set_config()"><i class="fa fa-save"></i> Save</button><span id="config_status"></span>
<button title="Reset Config to Default settings" onclick="reset_config(true);">Reset</button>
</p>
</div>
<!-- End Config Pane -->

<!-- Begin SQL Pane -->
<div id="sql" style="padding-left:10px;">
<h3>Enter SQL Statement</h3>
<div>
<div>
<textarea id="sql_input" rows="10" style="width:75%;"></textarea> 
</div>
<div>
<button title="Execute SQL statement" onclick="sql_run_execute();"><i class="fa fa-arrow-circle-right"></i> Execute</button>
</div>
<div> 
<h3>Save Statement</h3> 
<label><span class="required">Statement Description</span> 
    <input type="search" id="sql_label" style="width: 20%"></label> &nbsp; 
<label>Task Id <input type="number" id="sql_task_id" style="width:50px;"/></label>
<button title="Save" onclick="save_sql();"><i class="fa fa-save"></i> Save</button> 
<span id="sql_save_progress"></span>
<button title="List Saved SQL Statements" onclick="list_saved_sql();"><i class="fa fa-list"></i> List</button>
<button title="Reset" onclick="reset_sql();">Reset</button>
</div>
<div>
<p>
<span class="sql_progress"></span>
<span class="sql_summary"></span>
<span id="sql_csv_download_progress"></span>
<button id="sql_csv_button" onclick="sql_execute(null,null,'csv');" style="display: none;" title="Open Results as CSV">
<i class="fa fa-download"></i>
</button>
</p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px);"><tbody id="sql_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only">
<table class="rs"><tbody id="sql_results" class="rs"></tbody></table>
</div>
<span id="sql_navigation"></span>
</div>
</p>
</div>
</div>
</div>
<!-- End SQL Pane -->


<!-- Begin Sequence Pane -->
<div id="sequence" style="padding-left: 10px">
<h3>Define Run Sequence</h3>
<div>
<dl>
<dt><span class="required">Sequence Task Id</span></dt>
<dd><input id="sequence_input" type="number" style="width:60px"></dd>
<dt><span class="required">Component Task Id's (comma separated)</span></dt>
<dd><input id="sequence_task_list" type="search" style="width:280px; max-width:80%"></dd>
<dt><span class="required">Description</span></dt>
<dd><input id="sequence_description" type="search" style="width:280px; max-width:80%"></dd>
</dl>
<p>
<button title="Save Sequence Definition" onclick="save_sequence();"><i class="fa fa-save"></i> Save</button> 
<span id="sequence_save_progress"></span>
<button title="List saved Sequence Definitions" onclick="list_saved_sequences();"><i class="fa fa-list"></i> List</button>
<button title="Reset" onclick="clear_sequence_form();">Reset</button>
</p>
<div>
<p><span id="sequence_progress"></span><span id="sequence_summary"></span></p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px)"><tbody id="sequence_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px)">
<table class="rs"><tbody id="sequence_results" class="rs"></tbody></table>
</div>
<span id="sequence_navigation"> </span> <!-- Sequence Listing pagination currently not yet implemented -->
</div>
</p>
</div>
</div>
</div>
<!-- End Sequence Pane -->

<!-- Begin Custom Function Pane -->
<div id="custom_function" style="padding-left: 10px">
<h3>Define Custom Function</h3>
<div id="cf_part1">
<dl>
<dt><span class="required">Input Table</span></dt>
<dd><input id="cf_table" type="search" style="width:200px" list="cf_table_list" 
oninput="cf_reset(0);" onchange="cf_reset(0);"><datalist id="cf_table_list"></datalist></dd>
<dt><span class="required">Function</span></dt>
<dd><select id="cf_function" oninput="cf_reset(0);" onchange="cf_reset(0);"></select></dd>
</dl>
<button title="Proceed to next step" id="cf_next" onclick="custom_function_next();"><i class="fa fa-arrow-circle-right"></i> Next</button>
</div>
<datalist id="cf_table_column_list"></datalist>
<div id="cf_part2" style="display: none;">
<p>
<div id="cf_part2_help" style="color: green;"></div>
<div id="cf_part2_inputs"></div>
</p>
<p>
<dl>
<dt><span class="required">Result Table</span></dt>
<dd><input id="cf_result_table"></dd>
<dt>Temp</dt>
<dd><input type="checkbox" id="cf_is_temp"/></dd>
<dt><span class="required">Description</span></dt>
<dd><input type="search" id="cf_description" style="width:200px"/></dd>
<dt>Task Id</dt>
<dd><input id="cf_task_id" type="number" style="width:60px"/></dd>
</dl>
<p>
<p>
<button title="Run this Custom Function" id="cf_execute" onclick="cf_execute();"><i class="fa fa-arrow-circle-right"></i> Run</button>
<button title="Save this Custom Function definition" id="cf_save" onclick="save_cf();">
<i class="fa fa-save"></i> Save</button> <span id="cf_save_progress"></span>
</p>
</div>
<div id="cf_part3">
<p>
<button title="List Defined Custom Function Definitons" id="cf_list" onclick="list_cf_functions(1);"><i class="fa fa-list"></i> List</button>
<button title="Reset" id="cf_reset" onclick="cf_reset(1);">Reset</button>
</p>
<p><span class="cf_status"></span></p>
<div>
<p>
<span id="cf_summary"></span>
</p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px)"><tbody id="cf_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px)">
<table class="rs"><tbody id="cf_results" class="rs"></tbody></table>
</div>
<span id="cf_navigation"> </span> <!-- Not Implemented -->
</div>
</p>
</div>
</div>
</div>
<!-- End Custom Function Pane -->

<!-- Begin Prompt Pane -->
<div id="prompt" style="padding-left: 10px">
<h3>Define Prompt Input</h3>
<div>
<dl>
<dt><span class="required">Prompt Text</span></dt>
<dd><input id="prompt_text" type="search" style="width:280px; max-width:80%"></dd>
<dt><span class="required">Query String Parameter Name</span></dt>
<dd><input id="prompt_parameter_name" type="search" style="width:280px; max-width:80%"></dd>
<dt><span class="required">Description</span></dt>
<dd><input id="prompt_description" type="search" style="width:280px; max-width:80%"></dd>
<dt>Task Id</dt>
<dd><input type="number" style="width:60px;" id="prompt_task_id"></dd>
</dl>
<p>
<button title="Save Prompt Definition" onclick="save_prompt();"><i class="fa fa-save"></i> Save</button> 
<span id="prompt_save_progress"></span>
<button title="List Saved Prompt Definitions" onclick="list_saved_prompts();"><i class="fa fa-list"></i> List</button>
<button title="Reset" onclick="clear_prompt_form();">Reset</button>
</p>
<div>
<p>
<span id="prompt_progress"> </span><span id="prompt_summary"> </span>&nbsp;
</p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px)"><tbody id="prompt_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px)">
<table class="rs"><tbody id="prompt_results" class="rs"></tbody></table>
</div>
<span id="prompt_navigation"> </span> <!-- Prompt Listing pagination currently not yet implemented -->
</div>
</p>
</div>
</div>
</div>
<!-- End Prompt Pane -->

<!-- Begin Run Menu Pane -->
<div id="run_menu" style="padding-left: 10px">
<h3>Define Run Menu</h3>
<div>
<dl>
<dt><span class="required">Menu Item Label</span></dt>
<dd><input id="menu_label" type="search" style="width:280px; max-width:80%"></dd>
<dt>Menu Item Title</dt>
<dd><input id="menu_title" type="search" style="width:280px; max-width:80%"></dd>
<dt><span class="required">Task Id</span></dt>
<dd><input type="number" style="width:60px;" id="menu_task_id"></dd>
<dt>Relative Order</dt>
<dd><input id="menu_relative_order" type="number" style="width:60px; max-width:80%"></dd>
</dl>
<p>
<button title="Save This Run Menu Definition" onclick="save_menu();"><i class="fa fa-save"></i> Save</button> 
<span id="menu_save_progress"></span>
<button title="List Saved Menu Definitions" onclick="list_saved_menu_items();"><i class="fa fa-list"></i> List</button>
<button title="Reset" onclick="clear_menu_form();">Reset</button>
</p>
<div>
<p><span id="menu_progress"></span><span id="menu_summary"></span></p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px)"><tbody id="menu_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px)">
<table class="rs"><tbody id="menu_results" class="rs"></tbody></table>
</div>
<span id="menu_navigation"> </span> <!-- Menu Listing pagination currently not yet implemented -->
</div>
</p>
</div>
</div>
</div>
<!-- End Run Menu Pane -->

<!-- Begin Browse Pane -->
<div id="browse" style="padding-left: 10px">
<h3>Browse</h3>
<div id="browse_part1">
<dl>
<dt>Table/View</dt>
<dd><input id="browse_table" type="search" style="width:200px" 
list="browse_table_list" onkeyup="browse_run(event);" placeholder="Table or View"> 
<datalist id="browse_table_list"></datalist></dd>
<dt>Search</dt>
<dd><input id="browse_search_input" type="search" style="width:200px" onkeyup="browse_run(event);" placeholder="Filter"></dd>
</dl>
<div>
<button onclick="browse_execute();" title="Execute"><i class="fa fa-arrow-circle-right"></i></button>
<button title="Reset" onclick="browse_reset();">Reset</button>
</div>
<div> 
<div>
<p><span id="browse_progress"></span><span id="browse_summary"></span>
<button id="browse_csv_button" title="Open Results as CSV" onclick="" style="display:none;">
 <i class="fa fa-download"></i>
</button>
<span id="browse_csv_download_progress"></span>
</p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px);"><tbody id="browse_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px)">
<table class="rs"><tbody id="browse_results" class="rs"></tbody></table>
</div>
<span id="browse_navigation"> </span>
</div>
</p>
</div>
</div>
</div>
</div>
<!-- End Browse Pane -->

<!-- Begin Table Visualization Setup Pane -->
<div id="table_viz_setup" style="padding-left: 10px">
<h3>Table Visualization</h3>
<div style="display:inline-block">
<dl>
<dt><span class="required">Table/View</span></dt>
<dd><input id="table_viz_object_name" type="search" style="width:200px;" list="table_viz_object_name_list"
oninput="table_viz_populate_column_list();" onchange="table_viz_populate_column_list();"/>
<datalist id="table_viz_object_name_list"></datalist>
<datalist id="table_viz_column_list"></datalist>
</dd>
<dt><span class="required">Description</span></dt>
<dd><input id="table_viz_description" type="text" style="width:200px;"/></dd>
<!-- Future use
<dt>Display Theme</dt>
<dd><input id="table_viz_display_theme" type="text" style="width:200px;" disabled="disabled"/></dd>
-->
<dt>Title</dt>
<dd><select id="table_viz_title_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="table_viz_title_value" type="search" style="width:200px;" list="table_viz_column_list"/>
</dd>
<dt>Task Id</dt>
<dd><input id="table_viz_task_id" type="number" style="width:60px;"/></dd>
<dt>Link Target</dt>
<dd><input id="table_viz_links_target" type="search" style="width:120px;"/></dd>
</dl>
</div>
<div style="display:inline-block;">
<h4>Self Drilldown</h4>
<dl>
<dt>Drilldown Column (Query String)</dt>
<dd><input id="table_viz_drilldown_column" type="search" style="width:200px;" list="table_viz_column_list"/></dd>
<dt>Drilldown Column Replacement Label</dt>
<dd><input id="table_viz_drilldown_label" type="text" style="width:120px;" value="Drilldown"/></dd>
<dt>Append Original Metadata</dt>
<dd><input id="table_viz_drilldown_metadata" type="checkbox"/></dd>
</dl>
</div>
<p>
<button title="Save This Table Visualization Definition" onclick="save_table_viz();"><i class="fa fa-save"></i> Save</button> 
<span id="table_viz_save_progress"></span>
<button title="List Saved Table Visualization Definitions" onclick="list_table_viz();"><i class="fa fa-list"></i> List</button>
<button title="Reset" onclick="clear_table_viz_form();">Reset</button>
</p>
<p>
<div>
<p>
<span id="table_viz_progress"> </span><span id="table_viz_summary"></span>
</p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px)"><tbody id="table_viz_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px)">
<table class="rs"><tbody id="table_viz_results" class="rs"></tbody></table>
</div>
<span id="table_viz_navigation"> </span> 
</div>
</p>
</div>
</p>
</div>
<!-- End Table Visualization Setup Pane -->

<!-- Begin Chart Visualization Setup Pane -->
<div id="chart_viz_setup" style="padding-left: 10px">
<h3>Chart Visualization</h3>
<div style="display: inline-block;">
<dl>
<dt><span class="required">Table/View</span></dt>
<dd><input id="chart_viz_object_name" type="search" style="width:200px;" list="chart_viz_object_name_list"
oninput="chart_viz_populate_column_list();" onchange="chart_viz_populate_column_list();"/>
<datalist id="chart_viz_object_name_list"></datalist>
<datalist id="chart_viz_column_list"></datalist>
<datalist id="chart_viz_numeric_column_list"></datalist>
</dd>
<dt><span class="required">Description</span></dt>
<dd><input id="chart_viz_description" type="search" style="width:200px;"/></dd>
<dt>Chart Background Color</dt>
<dd><input id="chart_viz_background_color" type="color" value="#FFFFFF"/></dd>
<dt>Title</dt>
<dd><select id="chart_viz_title_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="chart_viz_title_value" type="search" style="width:180px;" list="chart_viz_column_list"/>
</dd>
<dt>Task Id</dt>
<dd><input id="chart_viz_task_id" type="number" style="width:60px;"/></dd>
<dt>Link Target</dt>
<dd><input id="chart_viz_links_target" type="search" style="width:120px;"/></dd>
<dt>Drilldown Append Original Metadata</dt>
<dd><input id="chart_viz_drilldown_metadata" type="checkbox"/></dd>
<dt>Pie Chart Display Theme</dt>
<dd><input id="chart_viz_display_theme" type="search" style="width:200px;" 
placeholder="#FF8080,#FFFF80,#80FF80,#00FF80,#80FFFF,#0080FF,#FF80C0,#FF80FF"/></dd>
</dl>
</div>
<div style="display: inline-block">
<h4>X-Axis</h4>
<dl>
<dt><span class="required">X-Axis Column</span></dt>
<dd><input id="chart_viz_x_axis_column" type="search" style="width:120px;" list="chart_viz_column_list"/></dd>
<dt>X-Axis Order By Column</dt>
<dd><input id="chart_viz_x_axis_order_by_column" type="search" style="width:120px;" list="chart_viz_column_list"/></dd>
<dt>X-Axis Order By Direction</dt>
<dd><select id="chart_viz_x_axis_order_by_direction">
<option>asc</option>
<option>desc</option>
</select>
</dd>
<dt>Stacked</dt>
<dd><input id="chart_viz_stacked" type="checkbox"/></dd>
</dl>
</div>
<div style="display: inline-block">
<h4>Series 1</h4>
<dl>
<dt>Type</dt>
<dd><select id="chart_viz_series1_type">
 <option>Line</option>
 <option>Bar</option>
 <option>Pie</option>
</select>
</dd>
<dt>Y-Axis Orient</dt>
<dd><select id="chart_viz_series1_axis_orient">
 <option>Left</option>
 <option>Right</option>
</select>
</dd>
<dt><span class="required">Y-Axis Value Column</span></dt>
<dd><input id="chart_viz_series1_y_axis_column" type="search" style="width:120px;" list="chart_viz_numeric_column_list"/></dd>
<dt>Drilldown Column (Query String)</dt>
  <dd><input id="chart_viz_series1_drilldown_column" type="search" style="width:120px;" list="chart_viz_column_list"/></dd>
<dt>Series Color</dt>
<dd><input id="chart_viz_series1_color" type="color" value="#FF0000"/></dd>
</dl>
</div>
<div style="display: inline-block">
<h4>Series 2</h4>
<dl>
<dt>Type</dt>
<dd><select id="chart_viz_series2_type">
  <option>Line</option>
  <option>Bar</option>
 </select>
</dd>
<dt>Y-Axis Orient</dt>
<dd><select id="chart_viz_series2_axis_orient">
  <option>Left</option>
  <option>Right</option>
 </select>
</dd>
<dt>Y-Axis Value Column</dt>
<dd><input id="chart_viz_series2_y_axis_column" type="search" style="width:120px;" list="chart_viz_numeric_column_list"/></dd>
<dt>Drilldown Column (Query String)</dt>
<dd><input id="chart_viz_series2_drilldown_column" type="search" style="width:120px;" list="chart_viz_column_list"/></dd>
<dt>Series Color</dt>
<dd><input id="chart_viz_series2_color" type="color" value="#00FF00"/></dd>
</dl>
</div>
<div style="display: inline-block">
<h4>Series 3</h4>
<dl>
<dt>Type</dt>
<dd><select id="chart_viz_series3_type">
  <option>Line</option>
  <option>Bar</option>
 </select>
</dd>
<dt>Y-Axis Orient</dt>
<dd><select id="chart_viz_series3_axis_orient">
  <option>Left</option>
  <option>Right</option>
 </select>
</dd>
<dt>Y-Axis Value Column</dt>
<dd><input id="chart_viz_series3_y_axis_column" type="search" style="width:120px;" list="chart_viz_numeric_column_list"/></dd>
<dt>Drilldown Column (Query String)</dt>
<dd><input id="chart_viz_series3_drilldown_column" type="search" style="width:120px;" list="chart_viz_column_list"/></dd>
<dt>Series Color</dt>
<dd><input id="chart_viz_series3_color" type="color" value="#0000FF"/></dd>
</dl>
</div>
<div style="display: inline-block">
<h4>Series 4</h4>
<dl>
<dt>Type</dt>
<dd><select id="chart_viz_series4_type">
 <option>Line</option>
 <option>Bar</option>
</select>
</dd>
<dt>Y-Axis Orient</dt>
<dd><select id="chart_viz_series4_axis_orient">
 <option>Left</option>
 <option>Right</option>
</select>
</dd>
<dt>Y-Axis Value Column</dt>
<dd><input id="chart_viz_series4_y_axis_column" type="search" style="width:120px;" list="chart_viz_numeric_column_list"/></dd>
<dt>Drilldown Column (Query String)</dt>
<dd><input id="chart_viz_series4_drilldown_column" type="search" style="width:120px;" list="chart_viz_column_list"/></dd>
<dt>Series Color</dt>
<dd><input id="chart_viz_series4_color" type="color" value="#000000"/></dd>
</dl>
</div>
</p>
<p>
<button title="Save this Chart Visualization Definition" onclick="save_chart_viz();">
<i class="fa fa-save"></i> Save</button> 
<span id="chart_viz_save_progress"></span>
<button title="List Saved Chart Visualization Definitions" onclick="list_chart_viz();">
<i class="fa fa-list"></i> List</button>
<button onclick="clear_chart_viz_form();" title="Clear Form">Reset</button>
</p>
<p>
<div>
<p>
<span id="chart_viz_progress"> </span><span id="chart_viz_summary"></span>
</p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px)"><tbody id="chart_viz_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only">
<table class="rs"><tbody id="chart_viz_results" class="rs"></tbody></table>
</div>
<span id="chart_viz_navigation"> </span> <!-- Not Implemented -->
</div>
</p>
</div>
</p>
</div>
<!-- End Chart Visualization Setup Pane -->


<!-- Begin Map Visualization Setup Pane -->
<div id="map_viz_setup" style="padding-left: 10px">
<h3>Map Visualization</h3>
<div style="display: inline-block;">
<dl>
<dt><span class="required">Table/View</span></dt>
<dd><input id="map_viz_object_name" type="search" style="width:200px;" list="map_viz_object_name_list"
 oninput="map_viz_populate_column_list();" onchange="map_viz_populate_column_list();"/>
<datalist id="map_viz_object_name_list"></datalist>
<datalist id="map_viz_column_list"></datalist>
<datalist id="map_viz_geom_column_list"></datalist>
</dd>
<dt><span class="required">Description</span></dt>
<dd><input id="map_viz_description" type="search" style="width:120px;"/></dd>
<dt>Title</dt>
<dd><select id="map_viz_title_type">
 <option value="Literal Constant">Literal Constant</option>
 <option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_title_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
<dt>Task Id</dt>
<dd><input id="map_viz_task_id" type="number" style="width:60px;"/></dd>
<dt>Link Target</dt>
<dd><input id="map_viz_links_target" type="search" style="width:120px;"/></dd>
</dl>
</div>
<div style="display: inline-block;">
<h4>Geometry</h4>
<dl>
<dt><span class="required">Geometry Column(s)</span></dt>
<dd><input id="map_viz_geometry_columns" type="search" list="map_viz_geom_column_list"/></dd>
<dt>Tooltip</dt>
<dd><select id="map_viz_tooltip_type">
 <option value="Literal Constant">Literal Constant</option>
 <option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_tooltip_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
</dl>
</div>
<div style="display: inline-block;">
<h4>Custom Style</h4>
<dl>
<dt>Custom Style 1</dt>
<dd>
<select id="map_viz_style1_option">
   <option>radius</option>
   <option>stroke</option>
   <option>color</option>
   <option>weight</option>
   <option>opacity</option>
   <option>lineCap</option>
   <option>lineJoin</option>
   <option>dashArray</option>
   <option>dashOffset</option>
   <option>fill</option>
   <option>fillColor</option>
   <option>fillOpacity</option>
   <option>fillRule</option>
</select>
<select id="map_viz_style1_mode">
   <option>regular</option>
   <option>hover</option>
</select>
<select id="map_viz_style1_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_style1_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
<dt>Custom Style 2</dt>
<dd>
<select id="map_viz_style2_option">
   <option>radius</option>
   <option>stroke</option>
   <option>color</option>
   <option>weight</option>
   <option>opacity</option>
   <option>lineCap</option>
   <option>lineJoin</option>
   <option>dashArray</option>
   <option>dashOffset</option>
   <option>fill</option>
   <option>fillColor</option>
   <option>fillOpacity</option>
   <option>fillRule</option>
</select>
<select id="map_viz_style2_mode">
   <option>regular</option>
   <option>hover</option>
</select>
<select id="map_viz_style2_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_style2_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
<dt>Custom Style 3</dt>
<dd>
<select id="map_viz_style3_option">
   <option>radius</option>
   <option>stroke</option>
   <option>color</option>
   <option>weight</option>
   <option>opacity</option>
   <option>lineCap</option>
   <option>lineJoin</option>
   <option>dashArray</option>
   <option>dashOffset</option>
   <option>fill</option>
   <option>fillColor</option>
   <option>fillOpacity</option>
   <option>fillRule</option>
</select>
<select id="map_viz_style3_mode">
   <option>regular</option>
   <option>hover</option>
</select>

<select id="map_viz_style3_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_style3_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
<dt>Custom Style 4</dt>
<dd>
<select id="map_viz_style4_option">
   <option>radius</option>
   <option>stroke</option>
   <option>color</option>
   <option>weight</option>
   <option>opacity</option>
   <option>lineCap</option>
   <option>lineJoin</option>
   <option>dashArray</option>
   <option>dashOffset</option>
   <option>fill</option>
   <option>fillColor</option>
   <option>fillOpacity</option>
   <option>fillRule</option>
</select>
<select id="map_viz_style4_mode">
   <option>regular</option>
   <option>hover</option>
</select>
<select id="map_viz_style4_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_style4_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
<dt>Custom Style 5</dt>
<dd>
<select id="map_viz_style5_option">
   <option>radius</option>
   <option>stroke</option>
   <option>color</option>
   <option>weight</option>
   <option>opacity</option>
   <option>lineCap</option>
   <option>lineJoin</option>
   <option>dashArray</option>
   <option>dashOffset</option>
   <option>fill</option>
   <option>fillColor</option>
   <option>fillOpacity</option>
   <option>fillRule</option>
</select>
<select id="map_viz_style5_mode">
   <option>regular</option>
   <option>hover</option>
</select>
<select id="map_viz_style5_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_style5_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
<dt>Custom Style 6</dt>
<dd>
<select id="map_viz_style6_option">
   <option>radius</option>
   <option>stroke</option>
   <option>color</option>
   <option>weight</option>
   <option>opacity</option>
   <option>lineCap</option>
   <option>lineJoin</option>
   <option>dashArray</option>
   <option>dashOffset</option>
   <option>fill</option>
   <option>fillColor</option>
   <option>fillOpacity</option>
   <option>fillRule</option>
</select>
<select id="map_viz_style6_mode">
   <option>regular</option>
   <option>hover</option>
</select>
<select id="map_viz_style6_type">
<option value="Literal Constant">Literal Constant</option>
<option value="Column Value">Column Value</option>
</select> 
<input id="map_viz_style6_value" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
</dl>
</div>
<div style="display: inline-block;">
<h4>Self Drilldown</h4>
<dl>
<dt>Drilldown Column (Query String)</dt>
<dd><input id="map_viz_drilldown_column" type="search" style="width:200px;" list="map_viz_column_list"/>
</dd>
<dt>Drilldown Column Replacement Label</dt>
<dd><input id="map_viz_drilldown_label" type="search" style="width:120px;" value="Drilldown"/></dd>
<dt>Append Original Metadata</dt>
<dd><input id="map_viz_drilldown_append_metadata" type="checkbox"/></dd>
</div>
</p>
<p>
<button title="Save this Map Visualization Definition" onclick="save_map_viz();"><i class="fa fa-save"></i> Save</button> 
<span id="map_viz_save_progress"></span>
<button title="List Saved Map Visualization Definitions" onclick="list_map_viz();"><i class="fa fa-list"></i> List</button>
<button title="Reset" onclick="clear_map_viz_form();">Reset</button>
</p>
<p>
<div>
<p>
<span id="map_viz_progress"> </span><span id="map_viz_summary"> </span>
</p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px);"><tbody id="map_viz_results_smallscreen" class="rs"></tbody></table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px);">
<table class="rs"><tbody id="map_viz_results" class="rs"></tbody></table>
</div>
<span id="map_viz_navigation"> </span>  <!-- Pagination not implemented -->
</div>
</p>
</div>
</p>
</div>
<!-- End Map Visualization Setup Pane -->


<!-- Begin Table Visualization Pane -->
<div id="table_viz_render" style="padding-left:10px">
<h3><button onclick="set_visible_pane('home');" title="Menu"><i class="fa fa-bars"></i></button>
<span id="table_viz_render_title"></span></h3>
<div>
<input id="table_viz_render_search_input" type="search" style="width:200px" 
    onkeyup="table_viz_render_run(event);" placeholder="Search">
<button title="Go" onclick="table_viz_render_execute();"><i class="fa fa-arrow-circle-right"></i></button>
<button title="Reset Form" onclick="table_viz_render_reset();">Reset</button>
<div> 
<div>
<p><span id="table_viz_render_progress"></span><span id="table_viz_render_summary"></span>
<button id="table_viz_render_csv_button" title="Open Results as CSV" onclick="" style="display:none;">
 <i class="fa fa-download"></i>
</button>
<span id="table_viz_render_csv_download_progress"></span>
</p>
<p>
<div>
<div class="smallscreen_only">
<table class="rs" style="width:calc(100vw-40px);">
<tbody id="table_viz_render_results_smallscreen" class="rs"></tbody>
</table>
</div>
<div class="largescreen_only" style="width:calc(100vw-40px)">
<table class="rs"><tbody id="table_viz_render_results" class="rs"></tbody></table>
</div>
<span id="table_viz_render_navigation"> </span>
</div>
</p>
</div>
</div>
</div>
</div>
<!-- End Table Visualization Pane -->


<!-- Begin Chart Visualization Pane -->
<div id="chart_viz_render" style="width:100vw;height:100vh;">
<canvas id="chart_viz_the_canvas"></canvas>
<div style="position: absolute; top: 12px; left: 12px;">
<button onclick="set_visible_pane('home');" title="Menu"><i class="fa fa-bars"></i></button><br/>
<button onclick="toggle_points();" title="Toggle Line Chart Point Radius"><i class="fa fa-bullseye"></i></button><br/>
<button onclick="download_chart();" title="Download Chart"><i class="fa fa-download"></i></button><br/>
</div>
<span id="chart_viz_render_progress" class="throbber"></span> 
</div>
<!-- End Chart Visualization Pane -->


<!-- Begin Map Visualization Pane -->
<div id="map_container" style="width:100vw;height:100vh">
<dialog id="map_tile_dialog" style="z-index:5000;position:absolute;top:100px;">
<div>
<h4>Offline Map Tile Store</h4>
<p>Current Map Zoom Level: <span id="ot_current_zoom" style="font-weight:bolder;color:green;"></span></p>
<p>Current Tiles in Offline Store: <span id="ot_current_tiles" style="font-weight:bolder;color:green;"></span></p>
<p id="ot_max_container"></p>
<p>
<button title="Delete Map Tile Store" onclick="deleteMapTileStore();"><i class="fa fa-trash-o"></i> Delete Tile Store</button>
<button title="Close this Dialog" onclick="map_dialog_close();">Close</button>
</p>
</div>
</dialog>
<div id="map" style="width:100vw;height:100vh">
<div id="map_title" class="map_title"></div>
<span id="map_render_progress" class="throbber"></span>
</div>
</div>
<!-- End Map Visualization Pane -->


<!-- Begin Metadata Export Pane -->
<div id="metadata_export" style="padding-left: 10px">
<h3>Export Metadata</h3>
<div>
<dl>
<dt>Encode as URI</dt>
<dd><input id="export_encode_uri" type="checkbox"></dd>
<dt>Reset DB <em>(applies only for Query String invocations)</em></dt>
<dd><input id="export_reset_db" type="checkbox"></dd>
</dl>
<p>
<button title="Export Metadata" onclick="cr_metadata();"><i class="fa fa-download"></i> Export</button> 
<span id="metadata_export_progress"></span>
</p>
</div>
</div>
<!-- End Metadata Export Pane -->


<!-- Begin Metadata Import Pane -->
<div id="metadata_import" style="padding-left: 10px">
<h3>Import Metadata</h3>
<div>
<label class="filelabel">
<div class="metadatafilediv">Drop your Visual Field Metadata file here to Import</div>
<input type="file" id="metadatafile">
</label>
<p><span id="metadata_import_progress"></span></p>
</div>
</div>
<!-- End Metadata Import Pane -->


<!-- Begin Metadata Reset Pane -->
<div id="metadata_reset" style="padding-left: 10px">
<h3>Reset Metadata</h3>
<p>
<button title="Warning: This will clear all defined Metadata" onclick="metadata_reset();"><i class="fa fa-trash-o"></i> Reset</button> 
<span id="metadata_reset_progress"></span>
</p>
</div>
<!-- End Metadata Reset Pane -->


<!-- Begin Reference Guide Pane -->
<div id="reference_guide" style="padding-left:10px;max-width:1000px;">
<h3>Reference Guide</h3>
<p>
<h4>Home</h4>
If you have an RFC 4180 standards based CSV file with a single header row, just drag and drop it
on to the file input area on this pane.  Your CSV will be parsed, loaded into a table having
the same name as the filename, and then switched to the Browse pane so you can readily view
the contents.
</p>
<hr/>
<p>
<h4>Table (Import File)</h4>
This pane enables you to import a delimited file into the Visual Field WebSQL database. To start,
just drag and drop your file onto the file input area and a preview will be displayed. A destination
table will need to be nominated (which will default to the deduplicated filename).  If your delimited
file is in RFC 4180 CSV standards format and contains a single header row then you 
should not need to change any of the other setting and can proceed to import your file by using
the Import buttons at the bottom of the pane.  In the case you need to change settings for a 
different formatted file, these are described as follows;
<h5>Charset</h5>
Unused in this version - will always be UTF-8
<h5>Separator</h5>
Specify the file field separator from the select list.  If the separator used in your file is
not shown in the select list, then choose "Custom" and enter the separator character in the
Custom input field.
<h5>Delimiter</h5>
Specify the file field escape delimiter from the Select list.  If the delimiter used in your file is
not shown in the select list, then choose "Custom" and enter the delimiter character in the
Custom input field.
<h5>Skip first lines</h5>
If the delimited content in your file does not begin on the first line, then enter the number
of lines to skip before parsing your data.  Please note that leading empty lines will automatically
be omitted during file read.
<h5>Header Row</h5>
Indicates that the file contains a header row that lists the column names.  If this is unchecked,
column names will be assigned as; F1, F2, F3, etc.
<h5>Empty Fields as Null</h5>
With this checked, empty fields encountered in the file will be assigned null when inserted into
the database table.  If this is unchecked an empty string will be inserted.
<h5>Destination Table</h5>
Enter the table name to be created in the Visual Field database for this import.  Will default
to the deduplicated filename.
<h5>Temp</h5>
If this is selected, the table will be created as "TEMP" - meaning that it wont persist after
a subsequent page reload (opening of the database).
<h5>After Import Start Task Id</h5>
Various actions within Visual Field can have an associated Task Id.  Enter the Task Id, that
you wish to start automatically after you file loads here.  Eg, you could put an SQL, Custom
Function or Visualization task immediately after your file is loaded.
<h5>Automate Import Next Time</h5>
With this checked, the next time, you drop a file with the same filename, the import will
run automatically without further action required.
</p>
<p>
<dl>
<dt><button><i class="fa fa-arrow-circle-right"></i> Import</button></dt>
<dd>Press this to commence the parse and import of your file.  A database table will be (re)created by this import.</dd>
<dt><button><i class="fa fa-arrow-circle-right"></i> <i class="fa fa-table"></i> Import + Browse</button></dt>
<dd>Press this to commence the parse and import of your file. Once your file is loaded, the Browse
pane for the corresponding table will be activated so you can immediately see the contents</dd>
<dt><button><i class="fa fa-save"></i> Save (No Import)</button></dt>
<dd>Use this to save the configuration specified above but do not actually run an import.  Useful
if you need to change something about the import.</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list with actions in this pane.  Limited to 100 rows maximum - if you have more than this
number of tables, use the Browse functions.  In the mini list, the actions that can be undertaken are;
<dl>
       <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
       <dd>Edit the import configuration of the particular table/filename</dd>
       <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
       <dd>Drop the import configuration of this particular table/filename. 
       However, the actual database table, if it exists, will not be dropped.</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
</dl>
</p>
<hr/>
<h4>Table (Import URL)</h4>
This pane enables you to import a web service that is serving delimited content into a Visual Field WebSQL database
table.  If you are using the file:// protocol to use Visual Field, or if the web service is being served
from a different domain, the web service may need to include CORS headers or the import fetch
request may fail.  A destination table will need to be nominated.  If the web resource is delimited in
RFC 4180 CSV standards format and contains a single header row then you should not need to change 
any of the other setting and can proceed to import once a destination table is specified.
In the case you need to change settings for a different formatted resource, these are described as follows;
<h5>Charset</h5>
Unused in this version - will always be UTF-8
<h5>Separator</h5>
Specify the file field separator from the select list.  If the separator used in your file is
not shown in the select list, then choose "Custom" and enter the separator character in the
Custom input field.
<h5>Delimiter</h5>
Specify the file field escape delimiter from the Select list.  If the delimiter used in your file is
not shown in the select list, then choose "Custom" and enter the delimiter character in the
Custom input field.
<h5>Skip first lines</h5>
If the delimited content in your file does not begin on the first line, then enter the number
of lines to skip before parsing your data.  Please note that leading empty lines will automatically
be omitted during file read.
<h5>Header Row</h5>
Indicates that the file contains a header row that lists the column names.  If this is unchecked,
column names will be assigned as; F1, F2, F3, etc.
<h5>Empty Fields as Null</h5>
With this checked, empty fields encountered in the file will be assigned null when inserted into
the database table.  If this is unchecked an empty string will be inserted.
<h5>Destination Table</h5>
Enter the table name to be created in the Visual Field database for this import.  Will default
to the deduplicated filename.
<h5>Temp</h5>
If this is selected, the table will be created as "TEMP" - meaning that it wont persist after
a subsequent page reload (opening of the database).
<h5>Save as Task Id</h5>
This will associate a Task Id with this particular import action.  The task can then be invoked
at a later point to automate the ingestion of the web service.
<h5>Cache Max-Age</h5>
If this import has a Task Id and that if the import is being invoked as part of that task, then
if this number of seconds has not yet elapsed since the previous import of this service, then
this task will be skipped.  That is, you can specify the number of seconds to elapse before this
resource should be re-imported when invoking this action as a task.  Will default to zero meaning
always import.  If this import is being run manually by one of the buttons below, then this
setting is ignored.
<h5>URL Header Name &amp; Value</h5>
You can optionally specify upto 2 http headers to attach as part of the URL request.
</p>
<p>
<dl>
<dt><button><i class="fa fa-cloud-download"></i> Fetch (preview only)</button></dt>
<dd>This will attempt to retrieve the webservice URL nominated but not import it.</dd>
<dt><button><i class="fa fa-arrow-circle-right"></i> Import</button></dt>
<dd>Press this to commence the fetch, parse and import of your web resource.  A database table will be 
(re)created by this import.</dd>
<dt><button><i class="fa fa-arrow-circle-right"></i> <i class="fa fa-table"></i> Import + Browse</button></dt>
<dd>Press this to commence the fetch, parse and import of your web resource. Once your file is loaded, the Browse
pane for the corresponding table will be activated so you can immediately see the contents</dd>
<dt><button><i class="fa fa-save"></i> Save (No Import)</button></dt>
<dd>Use this to save the configuration specified above but do not actually run an import.  Useful
if you need to change something about the import.</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list with actions in this pane.  Limited to 100 rows maximum - if you have more than this
number of tables, use the Browse functions.  In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the import configuration of the particular table/filename</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will perform a fetch, parse, Import and switch to the Browse Pane once loaded</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Drop the import configuration of this particular resource. 
       However, the actual database table, if it exists, will not be dropped.</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
</dl>
</p>

<hr/>
<h4>SQL Statement</h4>
Use this pane to execute an arbitrary SQL statement in the Visual Field WebSQL database.  This could be either 
a select statement or a DML statement against your own created objects.  Some care should be taken in that your 
database will also house the Visual Field dictionary which consists of a series of tables that begin with 
<b>VF_</b> - and you should generally not apply DML against these dictionary tables (although there are some 
specific exceptions to this guideline - see General Help).  
<h5>Enter SQL Statement</h5>
Enter your SQL statement in the textarea.
<h5>Statement Description</h5>
If you choose to save your statement, you will need to specify an arbitrary description.
<h5>Task Id</h5>
A Task id can be associated with your saved SQL Statement so that it can be invoked as
part of a Task.
<p>
<dl>
<dt><button><i class="fa fa-arrow-circle-right"></i> Execute</button></dt>
<dd>Press this button to execute your SQL Statement, results will appear below.</dd>
<dt><button><i class="fa fa-save"></i> Save (No Import)</button></dt>
<dd>Will save your SQL Statement</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved SQL Statements.  Limited to 100 rows maximum - if you have more than this
number of saved SQL statements, use the Browse functions.  In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved SQL statement</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved statement</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved statement.</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
<dt><button><i class="fa fa-download"></i></button></dt>
<dd>Will allow you to download the SQL statement result set as CSV.</dd>
</dl>
</p>

<hr/>
<h4>Custom Function</h4>
Use this pane to specify Custom Function definitions. Custom Functions are a series of some predefined javascript
functions that extend what is available within native WebSQL.  Custom Functions operate against a WebSQL
table and apply the javascript function specified using parameter characteristics (mappings).  A Custom Function
will drop and recreate a result table of the function results.  For all Custom Functions, the structure of the
result table is the same - which means that Custom Function outputs can be automated (as part of a task) 
and can either be linked (joined) back to the source table or used for further processing (as a task).
This is because the structure of the output table is predictable.  Custom Functions have a function Id that 
is associated with them and an arbitrary "library" that is a general grouping (described below).  If you are a 
web developer, the Custom Function metadata is extensible - <em>please search the source of this page for
"// Example of adding your own Custom Function definition" </em> approximately line 11,300 for
instructions.
<h5>Input Table</h5>
Specify the input table the Custom Function will be run against.
<h5>Function</h5>
Select the function that you wish to apply.  Functions are broken down by a "library" which is
just an arbitrary grouping.  Please refer to the API section for further details of each specific 
Custom Functions.
<h5>Library</h5>
<dl>
<dt>Math</dt>
<dd>A collection of javascript Math functions</dd>
<dt>Stats</dt>
<dd>A small collection of mathematical statistical functions</dd>
<dt>Misc<dt>
<dd>A collection of functions written by the author that do not largely fall
within another library.  This may contain large parts of functions from
other libraries (such as Turf and Metaphone) but have been substantially
reworked to function within Visual Field.</dd>
<dt>Turf</dt>
<dd>A collection of spatial analytical functions from the Turf.js library</dd>
</dl>

<p>As mentioned, when a custom function runs it will drop and recreate the result table which is
of a predefined structure.  This structure is;

<dl>
<dt>SRC_TABLE</dt>
<dd>This will be populated with the source input table used for the function.</dd>
<dt>SRC_ROWID</dt>
<dd>If there is a direct mapping of the custom function row back to a corresponding
row in the SRC_TABLE, then this field will be populated with the ROWID of the
SRC_TABLE.  This gives a definitive way to link the output of Custom Function
results back to the source input table.  Not all functions produce a result
set that is directly mappable.  And some functions produce grouping results
where these rowid's may be repeated.</dd>
<dt>GROUPING_RESULT</dt>
<dd>This value is a secondary result value.  It is either populated when the
Custom Function is some sort of aggregation function or the Custom Function
produces a secondary result.  In the case of an aggregation value, this can
typically be used with repeating ROWID's to aggregate the results back to
the original table.  In the case it is used for secondary results, this will
be specific to the particular Custom Function.</dd>
<dt>RESULT_STATUS</dt>
<dd>Either 'true' or 'false'.  For each row, this is the result status of the
execution of the javascript Custom Function.  If the function completes 
successfully (normally) then this will be set to 'true'.  If the function
threw an exception, then this will be set to 'false'</dd>
<dt>RESULT</dt>
<dd>This is the actual output of the invoked Custom Function.  This is a normally
a scalar result and may or may not map back to the source input table by way
of SRC_ROWID.</dd>
<dt>ERR_MESSAGE</dt>
<dd>If the Custom Function threw an exception, this is populated with any associated
error message</dd>
</dl>

</p>
<p>
Custom Functions operate against a single input table (and not joined tables).  If you
need to apply a custom function using input data from 2 or more tables, the source tables
will need to be joined prior to passing to the joined table to the Custom Function.  Please 
refer to an example in General Help guide.  When joining input tables, typically a 
cross join or Cartesian Product is to be generated to be passed to the Custom Function.  
In order to minimise the number of input rows in the join table, it is suggested to 
apply any additional relational filtering predicates as possible prior to joining tables.  
Relating the results of Custom Function output back to the source input tables can then 
still be achieved via the SRC_ROWID values from the Result table - but in the case of 
joined table input may involve a select statement of multiple tables to achieve this.  
Initially, using the ROWID's in this way may seem awkward until you get understand how 
to easily apply this.  Because ROWID's are used in this way, the inputs to Custom Functions
must be a table and not a database view.
</p>
<p>
Some Custom Functions require an array of input values.  For such functions, arrays
can be passed as a delimited list of values.  Such functions will typically accept a
list parameter and a list separator and delimiter parameter.  This is how arrays can
be passed to Custom Functions.  Generating delimited lists from SQL, for input to 
Custom Functions, might seem difficult at first but thankfully WebSQL (sqlite) provides
the fantastic group_concat function that can make the generation of such lists
very simple.  Please refer to the General Help section for some examples of using
group_concat.
</p>

The fields on the Define Custom Function pane are;

<h5>Input Table</h5>
Nominate the source input table here.
<h5>Function</h5>
Select the Custom Function to be applied.
<br/>
<button><i class="fa fa-arrow-circle-right"></i> Next</button>
<br/>
Press this to retrieve the Custom Function Parameters and nominate the Parameter mapping values.
For the parameter type -  "Literal Constant" will pass a constant value, "Column Value" will 
pass the table column and "Query String Param" will pass the nominated Query String Parameter.
Note in the case of "Query String Param" only 1 query string value for a given parameter name
will be passed (ie, if your query string parameter is an array (eg; ?A=1&amp;A=2) then only
1 single value (the first) will be passed to the function.

<h5>Result Table</h5>
Specify the Result table to be created when this Custom Function runs.
<h5>Temp</h5>
Select if the result table should be created as a TEMP table.
<h5>Description</h5>
Enter a description for this Custom Function.
<h5>Task Id</h5>
Enter an optional Task Id that will be associated with this Custom Function so it can
be run as part of a task.
</p>

<p>
<dl>
<dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
<dd>This will execute your Custom Function</dd>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will save your Custom Function Definition</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved Custom Functions.  Limited to 100 rows maximum - if you have more than this
number of functions, use the Browse functions.  In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved Custom Function</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved Custom Function</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved Custom Function</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
</dl>
</p>

</p>
<hr/>


<h4>Table Visualization</h4>
A table visualization is a tabular presentation of a nominated table or view.  The actual visualization produced
will be based on the table/view, have a filter input, and paginated tabular output.  The fields in this pane
are used to define a Table Visualization.
<p>
<dl>
<dt>Table/View</dt>
<dd>Specify the Table or View for the visualization.</dd>
<dt>Description</dt>
<dd>Specify a description to be associated with this visualization.</dd>
<dt>Title<dt>
<dd>This is the title heading that will be displayed at the top of the page when this
table visualization runs.  Titles can either be a constant ("Literal Constant") or
come from a table column ("Column Value") itself.  For the case of "Column Value", the 
value of the first row of the table column will be used.</dd>
<dt>Task Id</dt>
<dd>A Task Id to be associated with this table visualization</dd>
<dt>Link Target</dt>
<dd>If any presented data in the table/view contains valid hyperlinks, then this value will
be passed to the "target" attribute of the generated hyperlink.  For example, this
may be useful if you are invoking Visual Field from within an iframe and require
linking to a parent page.</dd>
</dl>
</p>

<p><b>Self Drilldown</b></p>
<p>
Self Drilldown is a mechanism that will enable you to create a hyperlink from your presented
data that will link back to the Visual Field page (ie, vf.html).  This is provided
to enable the creation of mini data driven applications.</p>
<p>
<dl>
<dt>Drilldown Column (Query String)</dt>
<dd>Nominate a column in the Table/View that has a Query String value that can be used for
the self drilldown.  The Drilldown Column will be passed as a Query String to the vf.html
invocation.  Note that this needs to be in the form of a valid web GET Query String name
value pairs.  Eg; param1=value1&amp;param2=value2.  Query Strings may also need to be 
encoded if the parameter name or value contains spaces for example.  Please refer to the 
Misc:encodeURIComponent Custom Function as a possible mechanism that can be used to assist 
the encoding of such Query Strings (that could be called as a prior task to creating these
links).  The Query String value should NOT include a leading Question Mark.</dd>
<dt>Drilldown Column Replacement Label</dt>
<dd>This is just a constant string value that will be used in replacement of the Drilldown
Column itself (name/value pair) and used as the hyperlink anchor text.</dd>
<dt>Append Original Metadata</dt>
<dd>If this page was invoked with a passed METADATA parameter then by selecting this
checkbox, that original METADATA parameter will be attached to the URL string in the
Drilldown Column.  Eg; name1=value1&amp;name2=value2&amp;METADATA=...  Note that it
may not be essential to reattach the METADATA - as you application could potentially
rely on existing saved offline state data.  However, if you intend to provide hyperlinks
that do not rely on any saved offline state, then as a general guideline, the METADATA
(which defines your mini-app) parameter should be appended to your hyperlink.
</dd>
</dl>
</p>
<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will save your Table Visualization Definition</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved Table Visualizations.  Limited to 100 rows maximum - 
if you have more than this number of Table Visualizations, use the Browse functions.  
In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved Table Visualization</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved Table Visualization</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved Table Visualization</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
<dt><button><i class="fa fa-bars"></i></button></dt>
<dd>Will exit from a Table Visualization and return to the Visual Field Home pane</dd>
<dt><button><i class="fa fa-download"></i></button></dt>
<dd>Will allow you to download the Table Visualization data.</dd>
</dl>
</p>

<p><b>Usage Notes</b></p>
<ol>
<li>If a Table Visualization is used as a Task in a Sequence, the sequence will be terminated
as part of this Task (even if there are other tasks defined after this task in the Sequence).</li>
<li>Columns used in the definition of the Table Visualization - eg, Title or Drilldown Column will
be omitted from the Table Visualization when it runs.</li>
</ol>

<hr/>



<h4>Chart Visualization</h4>
A Chart Visualization is a Pie, Bar or Line chart presentation of a nominated table or view. 
The fields in this pane are used to define a Chart Visualization.  A chart of upto 4 data
series can be generated.
<p>
<dl>
<dt>Table/View</dt>
<dd>Specify the Table or View as the input source for the visualization.</dd>
<dt>Description</dt>
<dd>Specify a description to be associated with this visualization.</dd>
<dt>Chart Background Color</dt>
<dd>Specify a background color for the chart.</dd>
<dt>Title<dt>
<dd>This is the title heading that will be displayed at the top of the page when this
chart visualization runs.  Titles can either be a constant ("Literal Constant") or
come from a table column ("Column Value") itself.  For the case of "Column Value", the 
value of the first row of the table column will be used.</dd>
<dt>Task Id</dt>
<dd>A Task Id to be associated with this Chart Visualization</dd>
<dt>Link Target</dt>
<dd>If Drilldown Columns are specified in the chart definition, then upon invocation
of such links, the "target" attribute of the generated hyperlink will be set to
this value.  For example, this may be useful if you are invoking Visual Field 
from within an iframe and require linking to a parent page.</dd>
<dt>Drilldown Append Original Metadata</dt>
<dd>If this page was invoked with a passed METADATA parameter then by selecting this
checkbox, that original METADATA parameter will be attached to any chart drilldown
links.  Note that it may not be essential to reattach the METADATA - as you application 
could potentially rely on existing saved offline state data.  However, if you intend to 
provide hyperlinks that do not rely on any saved offline state, then as a general 
guideline, the METADATA (which defines your mini-app) parameter should be appended.
</dd>
<dt>Pie Chart Display Theme</dt>
<dd>Pie Charts use this input field as a list of hex triplet color codes to be
used in the generation of the pie chart.  This value does not apply to 
Bar or Line charts.  As the colors are internally converted to RGBA values,
please only specify hex triplet color codes and not HTML named colors and 
ensure they are separated by commas.</dd>
<dt>X-Axis Column</dt>
<dd>Specify the X-Axis or, in the case of a Pie chart, the reference column.</dd>
<dt>X-Axis Order By Column</dt>
<dd>Optionally specify the column to order the result set by within the chart.</dd>
<dt>X-Axis Order by Direction</dt>
<dd>Select either 'asc' or 'desc' for the order by direction.</dd>
<dt>Stacked</dt>
<dd>Applies only to Bar and Line charts and specifies whether the series are to 
be stacked in the chart.  Note that Bars and Lines are stacked as groupings
of Bars and Lines (and not combined).</dd>
<dt>Series - Type</dt>
<dd>Select Line, Bar or Pie for the type of chart to be displayed.  Note that if 
this is set to Pie, then only Series 1 is used and Series 2-4 are ignored.</dd>
<dt>Series - Y-Axis Orient</dt>
<dd>Select "Left" or "Right" for the Y axis that will be associated with this
series.  Allows charts to be generated with up to 2 independent Y axis.</dd>
<dt>Series - Drilldown Column (Query String)</dt>
<dd>Nominate a column in the Table/View that has a Query String value that can be used for
the self drilldown.  The Drilldown Column will be passed as a Query String to the vf.html
invocation.  Note that this needs to be in the form of a valid web GET Query String name
value pairs.  Eg; param1=value1&amp;param2=value2.  Query Strings may also need to be 
encoded if the parameter name or value contains spaces for example.  Please refer to the 
Misc:encodeURIComponent Custom Function as a possible mechanism that can be used to assist 
the encoding of such Query Strings (that could be called as a prior task to creating these
links).  The Query String value should NOT include a leading Question Mark.
In relation to the hyperlink itself - a click event upon the associated chart element
itself will invoke the hyperlink.</dd>
<dt>Series - Series Color</dt>
<dd>Select the color to be used for this series</dd>
</dl>
</p>

<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will save your Chart Visualization Definition</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved Chart Visualizations.  Limited to 100 rows maximum - 
if you have more than this number of Chart Visualizations, use the Browse functions.  
In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved Chart Visualization</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved Chart Visualization</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved Chart Visualization</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
<dt><button><i class="fa fa-bars"></i></button></dt>
<dd>Will exit from a Chart Visualization and return to the Visual Field Home pane</dd>
<dt><button><i class="fa fa-bullseye"></i></button></dt>
<dd>Will toggle Line Chart point markers between 3 set radii size values.  Possibly useful 
for; 1) when viewing on a touch device that requires larger points to interact with, and 2) when
downloading a Chart as an image it may be desirable to remove all point markers from the chart.</dd>
<dt><button><i class="fa fa-download"></i></button></dt>
<dd>Will download a chart in an image format.</dd>
</dl>
</p>

<p><b>Usage Notes</b></p>
<ol>
<li>If a Chart Visualization is used as a Task in a Sequence, the sequence will be terminated
as part of this visualization task (even if there are other tasks defined after this task in the sequence).</li>
<li>Chart Visualizations have an internal limit of the maximum number of table/view rows 
that can be displayed.  Charts with a greater number of rows will automatically fallback to a Table
Visualization.  Please refer to the General Help for details of this.</li>
<li>Pie Chart Visualizations have an internal limit of the maximum number rows that will include
a chart header legend.  In charts with a greater number of rows the header legend will automatically 
be omitted.  Please refer to the General Help for details of this.</li>
</ol>

<hr/>

<h4>Map Visualization</h4>
A Map Visualization is a Leaflet Map presentation of a nominated table or view. 
The fields in this pane are used to define a Map Visualization.  
<p>
<dl>
<dt>Table/View</dt>
<dd>Specify the Table or View as the input source for the visualization.</dd>
<dt>Description</dt>
<dd>Specify a description to be associated with this visualization.</dd>
<dt>Title<dt>
<dd>This is the title heading that will be displayed at the top of the page when this
map visualization runs.  Titles can either be a constant ("Literal Constant") or
come from a table column ("Column Value") itself.  For the case of "Column Value", the 
value of the first row of the table column will be used.</dd>
<dt>Task Id</dt>
<dd>A Task Id to be associated with this Map Visualization</dd>
<dt>Link Target</dt>
<dd>If a Drilldown Column is specified in the map definition, then upon invocation
of such links, the "target" attribute of the generated hyperlink will be set to
this value.  For example, this may be useful if you are invoking Visual Field 
from within an iframe and require linking to a parent page.</dd>
<dt>Drilldown Column (Query String)</dt>
<dd>Nominate a column in the Table/View that has a Query String value that can be used for
the self drilldown.  The Drilldown Column will be passed as a Query String to the vf.html
invocation.  Note that this needs to be in the form of a valid web GET Query String name
value pairs.  Eg; param1=value1&amp;param2=value2.  Query Strings may also need to be 
encoded if the parameter name or value contains spaces for example.  Please refer to the 
Misc:encodeURIComponent Custom Function as a possible mechanism that can be used to assist 
the encoding of such Query Strings (that could be called as a prior task to creating these
links).  The Query String value should NOT include a leading Question Mark.</dd>
<dt>Drilldown Column Replacement Label</dt>
<dd>This is just a constant string value that will be used in replacement of the Drilldown
Column itself (name/value pair) and used as the hyperlink anchor text. The hyperlink
itself will be displayed within the map geometry element onclick popup.</dd>
<dt>Append Original Metadata</dt>
<dd>If this page was invoked with a passed METADATA parameter then by selecting this
checkbox, that original METADATA parameter will be attached to the URL string in the
Drilldown Column.  Eg; name1=value1&amp;name2=value2&amp;METADATA=...  Note that it
may not be essential to reattach the METADATA - as you application could potentially
rely on existing saved offline state data.  However, if you intend to provide hyperlinks
that do not rely on any saved offline state, then as a general guideline, the METADATA
(which defines your mini-app) parameter should be appended to your hyperlink.
</dd>
<dt>Geometry Column(s)</dt>
<dd>Enter the table/view geometry (WKT) column that the Map Visualization will be based upon.
In the current version of Visual Field, only a single geometry column can be entered.</dd>
<dt>Tooltip</dt>
<dd>This is the mouseover tooltip that will be displayed upon hover of map geometries.
Tooltips can either be a constant ("Literal Constant") or come from a table column 
("Column Value") itself. </dd>
<dt>Custom Style</dt>
<dd>Maps with no Custom Style defined will use the Leaflet Mapping Library default path
styling options.  Please refer to the Leaflet Mapping Library Path options reference.
Maps can have up to 6 custom styles defined that override the default Leaflet styling.</dd>
<dt>Custom Style - Option</dt>
<dd>Enter the Leaflet Mapping Library Path Option value.  That is, the Path option
relating to the map geometry.</dd>
<dt>Custom Style - regular/hover</dt>
<dd>Select either "regular" or "hover".  "regular" means the styling will be used in place
of the Leaflet default styling.  "hover" means the styling will be applied upon mouseover
hover of the map geometry.</dd>
<dt>Custom Style - Value</dt>
<dd>This is the value that for the styling that will be applied.
Style values can either be a constant ("Literal Constant") or come from a table column 
("Column Value") itself.  Applying styles from a "Column Value" will enable you to
create data context driven map styling.</dd>
</dl>

<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will save your Map Visualization Definition</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved Map Visualizations.  Limited to 100 rows maximum - 
if you have more than this number of Map Visualizations, use the Browse functions.  
In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved Map Visualization</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved Map Visualization</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved Map Visualization</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
<dt><button><i class="fa fa-bars"></i></button></dt>
<dd>Will exit from a Map Visualization and return to the Visual Field Home pane</dd>
<dt><button class="fa fa-th-large"></button></dt>
<dd>Will enable the fetch and store of Map Tiles that can be used later if the map is viewed offline (without an
internet connection).  Requires Map Tile feeds to be CORS enabled.  <span class="alert">Please note
  that your Tile provider may have usage policies relating to the fetching of Map Tiles for
  offline use.</span></dd>
</dl>
</p>

<p><b>Usage Notes</b></p>
<ol>
<li>If a Map Visualization is used as a Task in a Sequence, the sequence will be terminated
as part of this visualization task (even if there are other tasks defined after this task in the sequence).</li>
<li>Map Visualizations have an internal limit of the maximum number of table/view rows (features)
that can be displayed.  Maps with a greater number of rows will automatically fallback to a Table
Visualization.  Please refer to the General Help for details of this.</li>
<li>Table columns that are used to generate the map - eg; Map Title, Geometry or Custom Styling fields 
will be omitted from the Map Visualization geometry onclick popup attribute listing.</li>
<li>As mentioned above - the fetching of Map Tiles for later offline use may be subject to usage 
policies of your tile provider.</li>
</ol>
<hr/>

<h4>Define Prompt Input</h4>
A prompt input allows for the creation of a simple javascript prompt to retrieve a single line
of input text from the user.  This text will then be saved to the VF_QUERY_STRING table as
a simple name/value parameter.  It may overwrite any existing Query String Parameters.
More detailed mechanisms for retrieving input fields from users are not currently provided.
<p>
<dl>
<dt>Prompt Text</dt>
<dd>Specify the Prompt Greeting text that is to be displayed when the Prompt runs.</dd>
<dt>Query String Parameter Name</dt>
<dd>Specify the Query String Parameter Name for the value that will be saved to the VF_QUERY_STRING table.</dd>
<dt>Description</dt>
<dd>Specify a description for this Prompt.</dd>
<dt>Task Id</dt>
<dd>Specify a Task Id that will be associated with this Prompt.</dd>
</dl>
<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will save your Prompt Input Definition</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved Prompt Definitions.  Limited to 100 rows maximum - 
if you have more than this number of Prompt Definitions, use the Browse functions.  
In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved Prompt Definition</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved Prompt Definition</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved Prompt Definition</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
</dl>
<hr/>

<h4>Define Run Sequence</h4>
A Sequence is simply a Task that is made up of other tasks.  When the sequence is run,
the component task list is expanded to all leaf tasks and then they are run in order.
<p>
<dl>
<dt>Sequence Task Id</dt>
<dd>Specify the Task Id for this Sequence.</dd>
<dt>Component Task Id's (comma separated)</dt>
<dd>This is a list of Task Id's that make up this sequence.  The list should consist of comma separated numeric values.</dd>
<dt>Description</dt>
<dd>Specify a description for this Sequence.</dd>
</dl>
<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will save your Sequence Definition</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved Sequence Definitions.  Limited to 100 rows maximum - 
if you have more than this number of Sequence Definitions, use the Browse functions.  
In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved Sequence Definition</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved Sequence Definition</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved Sequence Definition</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
</dl>
<p><b>Usage Notes</b></p>
<ol>
<li>When executed, a Sequence is first expanded into a list of leaf Task Id's.  In order 
to prevent possible infinite loops, a maximum sequence predefined limit is used.
This limit can be adjusted somewhat under the Config settings; <em>Maximum sequence task expansion</em>
setting.
<li>In the current version of Visual Field, a sequence will terminate upon the rendering of any Visualization
  task even if there are other subsequent tasks defined as part of the Sequence.  Such as a 
  Table Visualization, Chart Visualization or a Map Visualization.  This may be changed in
  subsequent versions of Visual Field.
</ol>
<hr/>

<h4>Define Run Menu</h4>
The run menu is found in the upper left part of the Home pane and can be identified by the cyan
<i class="fa fa-play"></i> icon.  Run menu entries are simple label entries that have a Task Id
associated with them.  The run menu gives a very simple way (shortcut) to run a task from the 
Home pane of Visual Field.  This may be useful for presentations and quick summaries where a 
menu entry will be far easier to navigate to than locating the particular Task under under 
the general dropdown menus.
<p>
<dl>
<dt>Menu Item Label</dt>
<dd>Specify the textual label that will make up the run menu entry.</dd>
<dt>Menu Item Title</dt>
<dd>This will be populated in the HTML title attribute of the Run Menu entry and may be useful
for a simple tooltip.  Optional.</dd>
<dt>Task Id</dt>
<dd>Specify the Task Id that should be run upon selection of this menu entry.</dd>
<dt>Relative Order</dt>
<dd>A numeric value that depicts the relative order (from lowest to highest) that this menu item
should appear down in the menu list.</dd>
</dl>
<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will save your Run Menu Item Definition</dd>
<dt><button><i class="fa fa-list"></i> List</button></dt>
<dd>Will give a mini list of your saved Run Menu Definitions.  Limited to 100 rows maximum - 
if you have more than this number of Sequence Definitions, use the Browse functions.  
In the mini list, the actions that can be undertaken are;
<dl>
 <dt><button><i class="fa fa-file-o"></i> Edit</button></dt>
 <dd>Edit the saved Run Menu Item Definition</dd>
 <dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
 <dd>Will run the saved Run Menu Item Definition</dd>
 <dt><button><i class="fa fa-trash-o"></i> Drop</button></dt>
 <dd>Will drop the saved Run Menu Item Definition</dd>
</dl>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
</dl>
<hr/>

<h4>Collect Device Attributes</h4>
Here you can specify a Task Id that will be associated with the collection of device attributes.
Device attributes are a set of attributes that are specific to the client device.  Instantaneous
collected device attributes are saved in the VF_DEVICE_ATTRIBUTES table.  No historical values
are saved - only instantaneous values.  Currently, only GeoLocation Device Attributes are 
collected and, with current browsers, typically will only work on file:// protocol or https://
protocol contexts.  GeoLocation also typically requires an input action from the user.
<p>
<dl>
<dt>Task Id</dt>
<dd>This is a Task Id that will be associated with the Collection of Device Attributes.  The
task will need to be run to collect the device attributes.
</dl>
<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will assign the specified Task Id to the Collection of Device Attributes</dd>
<dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
<dd>Will Run the Collection of Device Attributes.</dd>
<dt><button>Reset</button></dt>
<dd>Will clear this form and reset the Task Id.</dd>
</dl>
<hr/>

<h4>On Page Load</h4>
Here you can specify a Task Id that will be run after the Visual Field page loads in
the browser.  This can either be a constant value or a value passed in as a Query
String parameter.
<p>
<dl>
<dt>Run Task Id</dt>
<dd>This is a Task Id that will be run upon when the Visual Field page loads in the browser.
"Literal Constant" will run the specified Task Id, whereas "Query String Param" will 
run the value of the named Query String parameter passed in as a GET parameter as
part of the URL to this page.
</dl>
<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Will assign the specified Task Id to the On Page Load</dd>
<dt><button><i class="fa fa-arrow-circle-right"></i> Run</button></dt>
<dd>Will Run the On Page Load Task Id.</dd>
<dt><button>Reset</button></dt>
<dd>Will clear this form and Reset the Task Id.</dd>
</dl>
<hr/>

<h4>Browse</h4>
This pane enables you to readily browse objects (tables and views) in your Visual Field WebSQL database.
In addition to your own created table, there are a set of Visual Field tables and views - which can be
identified by the "VF_" prefix.  Ordinarily, you should not need to browse or modify the "VF_" tables
but there are some specific exceptions to this guideline - refer to the General Help section.  Some
"VF_" tables have table specific markup associated with them and will render with a certain set of
functionality to allow further operations from the browse pane.  For your own loaded tables, there will
be no markup associated with the display of the table data.  The Browse pane generates a paginated and
sortable table listing.  It can be used for listing of all tables, whereas the mini-lists within
Visual Field are unsortable and are limited to 100 rows.
<p>
<dl>
<dt>Table/View</dt>
<dd>Enter the Table or View you wish to browse.  A datalist of values should be suggested to make easy
identification of your loaded tables.
<dt>Search</dt>
<dd>You can filter your table result listing by search filter criteria.  All tokens in the Search input
must be present in any of the fields in your table.
</dl>
<p>
<dl>
<dt><button><i class="fa fa-arrow-circle-right"></i></button></dt>
<dd>Will Run your Search.</dd>
<dt><button>Reset</button></dt>
<dd>Will clear this form.</dd>
<dt><button><i class="fa fa-download"></i></button></dt>
<dd>Will download the displayed table, with any filtering applied, as CSV format.</dd>
</dl>
</dl>
<hr/>

<h4>Browse VF Tables</h4>
A shortcut to Browse the Visual Field internal table VF_TABLES - which houses the metadata for
any table you have created as part of a "Table import (File)" or "Table Import (URL)".  Refer
to the Browse section above for more detail.
<hr/>

<h4>Browse All DB Objects</h4>
A shortcut to Browse all Visual Field WebSQL database objects (tables, views and temp tables).
Refer to the Browse section above for more detail.
<hr/>

<h4>Show Query String</h4>
A shortcut to Browse Visual Field WebSQL database VF_QUERY_STRING table.  This table is
populated upon page load and prompt actions.  Refer to the Browse section above.
<hr/>

<h4>Show Device Attributes</h4>
A shortcut to Browse Visual Field WebSQL database VF_DEVICE_ATTRIBUTES table.  This table is
populated upon the running of "Collect Device Attributes" Task Id.  Refer to the Browse section above.
<hr/>

<h4>Export Metadata</h4>
This pane enables you to export the metadata of the essential Visual Field configuration that
you may have defined.  Exported metadata can then be re-imported either manually or automated
by passing in on the Query String.  So you can share your metadata with your colleagues or 
generate reports using your metadata.  Metadata is made up of a simple JSON structure consisting
of a core subset of the Visual Field configuration.  So the metadata is human readable.
<p>
<dl>
<dt>Encode as URI</dt>
<dd>If you intend to re-import your metadata in a file:// context as part of the
Query String, then check this checkbox so that your JSON metadata is generated and then URI encoded.  
You can then make a reference to this metadata in the Query String that will be valid in a 
file:// context.  Ie, if you want to make Visual Field reports without needing the use of a web server.  
The way you would reference this is to re-import the whole encoded metadata in a Query String URL
upon page load as the METADATA parameter.  Eg; file://vf.html?METADATA=&lt;encodedURI&gt;.
This may be necessary because of browser security restrictions that prevent loading of
file URL's over Ajax in a file:// context.  Encoding of the Metadata as a URI is provided if
you are not using a web server but wish to load in METADATA on the Query String.  If you simply 
wish to generate a JSON representation of your Metadata, do not check this checkbox.</dd>
<dt>Reset DB</dt>
<dd>When Metadata is (re)imported it will be applied in a "merge" sense.  In that existing
Metadata will not be affected unless it is referencing by the same Id values.  Metadata can
be reset by the user - see Reset Metadata.  But in a web context, whilst possibly unusual, this
option can allow the reset of Visual Field Metadata objects upon pageload.  Checking this
option will simply include a tag; "RESET_DB:true" within the Metadata.  When such metadata
is loaded in a URL context on the Query String, then all Visual Field related WebSQL Objects
will be dropped and recreated (as empty) upon initial page load.  Normally, you should not need
to check this checkbox (and for some actions where offline state is required to be maintained
between web invocations this option should NOT be selected).</dd>
</dl>
</p>
<p>
<dl>
<dt><button><i class="fa fa-download"></i> Export</button></dt>
<dd>Will export your Visual Field Metadata as either an Encoded URI text file or a JSON file.</dd>
</dl>
</p>
<hr/>

<h4>Import Metadata</h4>
This pane enables you to import previously saved Visual Field Metadata.  Simply drop your metadata
file on this input field.  Files can be JSON, or URI encoded JSON.  Import of Metadata in this
way by the user will apply it in a "merge" sense in that it will only overwrite objects with the
same Id's.  In this way you can share Metadata amongst your colleagues - and can do that
non-destructively by using non-overlapping sets of Id's.  Metadata imported in this way
ignores any "RESET_DB" setting within the Metadata.
<p>
<p><b>Usage Notes</b></p>
<ol>
 <li>To re-import Metadata by using the Query String, specify the parameter METADATA.
  When passed on the URL as a Query String parameter, the METADATA parameter will be evaluated as;
  <ol>
	  <li>If the METADATA parameter is an URI encoded string of JSON, it will be parsed and imported.</li>
	  <li>If the METADATA parameter is a string (that fails to parse as JSON), it will be 
		  assumed to be a URL reference and fetched as a URL (remote web request) to 
		  retrieve the Metadata as JSON.</li>
  </ol>
</ol>
<hr/>

<h4>Reset Metadata</h4>
This pane enables you to reset Visual Field Metadata.  Reseting Metadata means that
all Visual Field WebSQL objects will be dropped and recreated as empty.  If you have
existing objects within the database, these should not be affected (however, any metadata
references to them will be lost).
<p>
<dl>
<dt><button>Reset</button></dt>
<dd>Will drop and recreate (empty) Visual Field Metadata WebSQL objects.</dd>
</dl>
</p>
<hr/>

<h4>Config</h4>
This pane enables the setting of various application wide values.
<p>
<dl>
<dt>Database Name</dt>
<dd>This will specify the WebSQL database name.  Currently disabled and fixed as "vf"</dd>
<dt>Database Size</dt>
<dd>Specify the size of the WebSQL database in Mb.</dd>
<dt>Show Status Pane during Sequence Execution</dt>
<dd>The Status Pane shows a broad summary during Sequence Execution.  It is set to be shown
by default (with this setting) and it is generally useful once your report/workflow is deployed 
in a production sense so that some general feedback is given to the user.  Unchecking this and 
running a sequence will switch between pertinent panes during sequence execution.  This might be 
more useful during development so you can monitor the details of the sequence execution but could 
be distracting once a report is finalised. Once you finalise and debug your sequence, you should
re-check this checkbox.</dd>
<dt>Truncate display of displayed fields after</dt>
<dd>This sets a limit on the maximum number of characters that will be displayed in Visual Field for
any given result set. Eg, Browse, SQL output and Table, Chart and Map Visualizations.  This helps
mitigate against potential browser issues (memory crash) due to extremely large table fields as
the display will be truncated after this length.  Truncation is not applied to CSV downloads.
<dt>Table Page Size</dt>
<dd>This sets a limit to the pagination for SQL output, Table Browse and Table Visualizations.  Setting
a page size and pagination of output helps mitigate against potential browser issues (memory crash).
<dt>Map Base Layer Tile URL</dt>
<dd>Enter the Tile URL for use in any Map Visualization.  Map Tile URL's should be in EPSG 3857 datum.
To enable Offline Map Tile store, Tile URL's will need to be CORS enabled.  A sample of Tile URL's
is available by selecting a <em>Sample Base Layers</em>.</dd>
<dt>Map Base Layer Attribution</dt>
<dd>Enter the Map Base Layer Attribution that for the Map Base Layer Tile URL.  This will be displayed
on Map Visualizations.</dd>
</dl>
<p>
<dl>
<dt><button><i class="fa fa-save"></i> Save</button></dt>
<dd>Save the specified Configuration.</dd>
<dt><button>Reset</button></dt>
<dd>Reset the Configuration to default Settings.</dd>
</dl>
</p>
<hr/>

</p>
</div>
<!-- End Reference Guide Pane -->


<!-- Begin API Guide Pane -->
<div id="api_guide" style="padding-left: 10px; max-width: 1000px;">
<h3>API Guide</h3>
<p>
The METADATA that can be generated and imported back into Visual Field is essentially
a simplistic JSON object with 4 key elements.  This may be optionally URI encoded but
underlying it is still a simple JSON object.  This API page is included for those
who may wish to automatically generate Visual Field metadata such as an automated
report for example.  The 4 elements in the metadata are;
<dl>
  <dt>VERSION</dt>
  <dd>This is the Visual Field metadata version number.  It is not the same
      as the Visual Field Release number but the Version number represents the
      structure of the metadata.  The following describes the metadata structure
      for Version 1.  This is currently the only version supported for import.
      This should be set to 1 for any generated metadata.</dd>
  <dt>RESET_DB</dt>
  <dd>Either "true" or "false".  Indicates whether the WebSQL database Visual
      Field dictionary objects should be dropped and recreated upon page load.
      Applicable only when passed in using the METADATA parameter in the Query
      String and is ignored for manually imported metadata. This should normally
      be set to "false" or omitted.  Should you need to reset the WebSQL database,
      then set this to "true".</dd>
  <dt>CONFIG</dt>
  <dd>An array of Config Item values for Visual Field.  Config Values typically
      broadly affect the behaviour of Visual Field.  Please refer to the config
      section displayed below for the specifics of what needs to be included in
      the CONFIG array. The CONFIG array needs to be included with the correct
      number of elements.</dd>
  <dt>TABLES</dt>
  <dd>The TABLES element is an object of a subset of Visual Field tables that
  are used to represent the core Metadata structured elements.  This is a subset
  of all of the Visual Field tables and views.  Please see the Tables section
  displayed below for a listing of these tables. TABLE elements are simply
  an array of table rows (another array).  TABLES need to be included
  with the correct table elements and the correct number of elements for each
  table row to be imported successfully.</dd>
</dl>

<p><h4>CONFIG</h4></p>
The CONFIG element is made up of an array with the following entries;
<p><span id="api_config"></span></p>

<p><h4>TABLES</h4><p>
<p>
The TABLES element is made up of an array of elements that are the Visual Field
internal tables that are represented in the metadata.  TABLE element themselves
are then made up of an array of rows.  The list of TABLES that can be included
in metadata definitions is a subset of all of the Visual Field internal tables.
Select a TABLE below to detail the row components to be included in a TABLES
definition entry;
<p>
<p><select id="api_tables" onchange="show_api_table_helper(this.value);"></select></p>
<p><span id="api_table_detail"></span></p>

<p><h4>CUSTOM FUNCTION (ID)</h4></p>
<p>
Custom Functions are identified by a numeric ID within Visual Field.  This is
an extensible array should you wish to add your own function definitions
(refer to the General Help section).  To assist in identifying a Custom Function 
definition and its ID details, please choose from the following selection.  Custom 
functions that are deterministic in that their output is solely dependent upon their
input parameters, should be defined as "type=immutable".

<p><select id="api_functions" onchange="show_api_function_helper(this.value);"></select></p>
<p><span id="api_function_detail"></span></p>

</p>
</div>
<!-- End API Guide Pane -->


<!-- Begin General Help - Tips and Troubleshooting Pane -->
<div id="tips" style="padding-left:10px;max-width:1000px;">
<h3>General Help</h3>

<p>
<h4>Mandatory and Optional input fields within Visual Field</h4>
<p>
<ul>
<li><span class="required">This Styling Indicates a Mandatory Input Field</span></li>
<li>This Styling indicates an Optional Input Field</li>
</ul>
</p>

<p>
<h4>File Import</h4>
If your Import File is in CSV standards format (RFC 4180) with a 1 row header containing field names, then
you can generally accept the default settings and import your data without needing to change
any settings. Many open data CSV datasets are in this format.
</p>
<p>
<h4>CSV parsing of multi line fields</h4>
The internal algorithm in which Visual Field parses import delimited files (eg, CSV) varies
dependent upon the size of the input file.  For files less than 20Mb, the parser will perform 
a full standards parse (RFC 4180) on the input file as a whole (internally done by the fantastic
jQuery-csv parser).  So any multi-line input fields (fields containing carriage returns or line feeds) 
should be parsed correctly.  However, full file parsing of the input files in this way is not 
scalable for extremely large input data files.  And this can cause memory utilisation issues within the 
browser (ie, crash) if this approach were to be adopted for all file sizes.  To mitigate against this, 
there is an internal threshold set in Visual Field of 20Mb.  For files larger than this 20Mb threshold, 
the input file will be split line-by-line and processed incrementally (ie, CSV parsed line-by-line).  
This enables Visual Field to ingest extremely large CSV, or other delimited, files (without having to parse 
the file as a whole).  However for such large files (larger than this 20Mb threshold), multi-line 
input fields will typically cause a parse failure of those particular lines.  In actuality, most of 
the very large delimited files, there are typically no multi-line fields.  So in general, this 20Mb 
threshold for parsing approach - should go unnoticed and should not cause any issues - 
it also means that the Visual Field input file ingestion is very scalable for extremely large files
with little to no inconvenience.  Please refer to the Internal Limits section below.
</p>
<p>
<h4>Querying Columns containing spaces</h4>
If you are not accustomed to referencing database columns containing spaces when using SQL or
similar, you may need to enclose those fields in double quotes.  For example, suppose you
have a table called SCHOOLS and one of its fields is "Upper Grade", then you could query this
by something like;
<pre class="info">

select "Upper Grade" from SCHOOLS;

</pre>
</p>

<p>
<h4>Casting to correct datatypes</h4>
When importing delimited data (from the File Import or URL Import), for the created database table 
all of the field datatypes will be TEXT.  No heuristics are applied to attempt to ascertain import 
field datatypes.  Columns are simply all created as TEXT datatype and you may wish to CAST 
these to other datatypes.  Casting can easily be done by various ways.  You can cast in subsequent
SQL queries.  You may also wish to consider creating a task that runs after your 
table import and drops/(re)creates a database view that does the appropriate datatype casting.  
That is, the fields in the view could be cast to the appropriate datatypes.  Casting is not 
strictly important in general - you can typically query numeric and string values in a similar way.  
However casting to the correct datatypes may become important when you start to relationally join 
tables together by SQL joins.  Also, imported Query String Parameters placed in the 
VF_QUERY_STRING table are created as "TEXT" - and again they may need casting to
appropriate datatypes if you relationally join these to other tables via SQL queries
or views.
</p>
<pre class="info">

create view if not exists SCHOOLS_GRADE
as 
select cast("Upper Grade" as INT) "Upper Grade",
"Campus Name"
from SCHOOLS;

</pre>
</p>

<p>
<h4>group_concat</h4>
There are several Custom Functions in Visual Field that require an array input by way of a delimited list.  
That is typically a list of values separated by a comma to form an input array of values.  This may initially
seem difficult to produce from SQL but thankfully, within WebSQL (sqllite), there is the excellent
group_concat function.  This is a string aggregation function with an optional delimiter.
For example, if you wish to apply a statistical Custom Function against all lower grade values
from the SCHOOLS table, you could prepare input to the Custom Function by a statement similar
to the following;
</p>
<pre class="info">

create table if not exists SCHOOLS_LOWER_GRADES
as 
select group_concat("Lower Grade",',') as lower_grade_list
from SCHOOLS;

</pre>
<p>There are also several Spatial Custom Functions in Visual Field (courtesy of the fantastic Turf js library) 
that accept an array of geometries as input.  Again, the group_concat function may be useful in producing a list
(array) of WKT geometries for input.  In this case however, WKT geometries may contain commas, so
it is safer to enclose the grouped geometries in double quotes (delimiter).  Eg, suppose our SCHOOLS table
has a WKT geometry field called "Location 1", then to get a list (array) of geometries, you
could use the following;
<pre class="info">

create table if not exists SCHOOLS_GEOMS_LIST
as 
select group_concat('"'||"Location 1"||'"',',') as geom_list
from SCHOOLS;

</pre>
</p>

<p> But what about the case where your input may contain double quotes or commas?  The approach
here is to take group_concat further with the replace function and replace any occurrence of
a double quote with a double double quote.  In this case you will essentially be producing a 
standards based CSV input list (array) from SQL!  Eg, suppose we wish to make a listing of the
"Campus Name" field in the SCHOOLS table and that field may contain either commas or double quotes,
then the following approach is suggested;
<pre class="info">

create table if not exists SCHOOLS_NAME_LIST
as 
select 
group_concat('"'||replace("Campus Name",'"','""')||'"',',') 
as name_list
from SCHOOLS;

</pre>
</p>
<p>
If for some reason you need the inverse function to group_concat, please see the Custom
Function Misc:ListSplit - which takes a list (delimited array) and splits the results
out to individual rows in the result table.
</p>

<p><h4>Exceptions to Guidelines relating to VF_ dictionary objects</h4></p>
As mentioned in the Reference Guide section, the Visual Field data dictionary is
also maintained in the same WebSQL database that your tables will reside.  The Visual Field
dictionary tables and views are generally prefixed with "VF_" and there should generally
be no need to query or run DML directly against these dictionary objects.  There
are a few specific exceptions to this guideline however, namely; VF_QUERY_STRING,
VF_DEVICE_ATTRIBUTRES and VF_TILE_STORE.
</p>

<p><h5>VF_QUERY_STRING</h5></p>
This table contains the name value pairs of any Query String parameters passed to Visual
Field in a GET context.
<p>
To obtain Query String expressions within SQL, it may be necessary to query the VF_QUERY_STRING
table directly.  No shortcut technique is provided - it is up to you to manually query this table.  
Some points worth noting also are;
<ol>
<li>The passed Query String values are of type TEXT.  As per mentioned above, if you
	are joining such values to other tables, you may need to explicitly CAST such
	values correctly either as part of the join or otherwise.</li>
<li>Multi value parameters are acceptable and can be passed in so you may need to account 
	for that also in any SQL referencing the VF_QUERY_STRING table.
</ol>
Here are some SQL examples of querying VF_QUERY_STRING;
Suppose our URL is; <span style="color:blue;">vf.html?A=-2&amp;B=0&amp;B=1</span>
<pre class="info">

select "Campus Name"
from SCHOOLS
where "Lower Grade" =
(select cast(value as INT)
from VF_QUERY_STRING
where name = 'A');

</pre>

And for a multi valued parameter;

<pre class="info">

select "Campus Name"
from SCHOOLS
where "Lower Grade" in 
(select cast(value as INT) 
 as "Value"
from VF_QUERY_STRING
where name = 'B');

</pre>

<p><h5>VF_DEVICE_ATTRIBURES</h5></p>
<p>
Similar to VF_QUERY_STRING the VF_DEVICE_ATTRIBUTES will be populated with a Collect Device Attributes
task invoked and acceptance by the user.  Device Attributes are similar to VF_QUERY_STRING in that
they may need to be explicitly queried and CAST to appropriate datatypes.

<p><h5>VF_TILE_STORE</h5></p>
<p>
The VF_TILE_STORE houses stored offline Map Tiles.  This table is initially empty and gets populated
if a user clicks the <button><i class="fa fa-th-large"></i></button> button in a Map Visualization and
downloads Map Tiles for possible Offline use.  Map Tile images must be CORS enabled and are simply
stored in the VF_TILE_STORE table as an encoded array of Uint8 values.  This is referred internally
as ENCODING_ALGORITHM 1.  However, more advanced users should recognise that the VF_TILE_STORE
can be Browsed in Visual Field just like any other table and extracted as a CSV download.  So,
if you are technically impelled, you could create a tile store, extract it, and make the CSV
available as a web service.  You could then define a Table (Import URL) as part of a Page load,
Run Menu, or Sequence that will fetch the web accessible CSV Tile Store and reload it into the
VF_TILE_STORE table.  You will then be able to create a mini application complete with an
Offline Map Tile store.  Please Note, as mentioned in the Reference Guide, downloading Map
tiles for Offline use may be subject to your Tile providers usage policies.
</p>

<p><h4>Preparing multi table input for Custom Function invocation - an example</h4></p>
Suppose we have 2 tables; SCHOOLS and HAZARDS.  The SCHOOLS table contains a point WKT
geometry ("Location 1") and the HAZARDS contains a polygon WKT geometry ("the_geom").
Suppose we want to run the Turf:booleanPointInPolygon test against these 2 tables.  To
do this, it will be necessary to combine these prior for input to the 
Custom Function into a single table.  The following SQL extract demonstrates how to 
possibly do this by way of a preparing a Cartesian Product.  You could then use this joined
table as input to the Custom Function and link the output of the Custom Function by way of 
referencing the appropriate ROWID's back to the source tables;

<pre class="info">

create table if not exists SCHOOLS_HAZARD
as select s.rowid as SCHOOLS_ROWID,
  s."Location 1" as the_point,
  h.rowid as HAZARDS_ROWID,
  h."the_geom" as the_polygon
from SCHOOLS s, HAZARDS h;

</pre>

<p><h4>Chart and Map - Table Visualization Fallback</h4>
Table Visualizations in Visual Field are paginated in the number of rows displayed on a page and a limit 
also set for the maximum field display length.  As such, Table Visualizations and SQL Statement (output) 
is intended to be much more scalable and allow far greater result sets.  Browse and Table Visualizations
are written in a way that should enable indefinite scalability where SQL Statement (output) is scalable to
about 512Mb result set size.  However, this is far greater than what is practical as a Chart or Map
Visualization.  And a Table Visualization should be fully scalable (and render without crashing the browser) 
even for extremely large tables.  This is currently not the case for Chart and Map Visualizations.  
Currently, Chart (using the Chartjs library internally) and Map (using the Leaflet library internally) Visualizations 
typically attempt to render (or process) the entire result set.  This tends to mean that, currently, such 
visualizations may not scalable for extremely large datasets and may cause memory issues in the browser 
(ie, may crash the browser) if left unbounded.  To mitigate this, there are some fixed internal fallback 
thresholds in Visual Field that will render a Table Visualization instead of a Chart or Map after a certain 
number of rows.  Please refer to the Internal Limits section below for more detail.  Once a Chart or a 
Map result set result set exceeds a certain number of rows - a Table Visualization will be shown 
instead.  To avoid such fallbacks, you may need to either reduce or somehow aggregate your data to produce a
smaller result set before showing as a Chart or Map Visualization.
</p>

<p><h4>Visual Field - Internal Limits</h4><p>
The following are some fixed internal limits within Visual Field;
<ul>
<li><b>20Mb</b> - Maximum full standards parse (RFC 4180) CSV file size.  Larger CSV files
	will be parsed line-by-line.</li>
<li><b>10,000</b> - Maximum number of rows in Chart Visualization result set before falling back to Table Visualization.</li>
<li><b>30</b> - Maximum number of rows in Pie Chart Visualization result set before Pie Chart header legend will be omitted.</li>
<li><b>120,000</b> - Maximum number of rows in Map Visualization result set before falling back to Table Visualization.</li>
<li><b>3,000</b> or <b>any coincident</b> Points - Maximum number of rows in Map Visualization Point only result set before Points will clustered.</li>
<li><b>100 unsorted rows</b> - Maximum number of rows displayed in Visual Field mini-lists.</li>
</ul>

<p><h4>Visual Field - Soft Limits</h4><p>
The following are some observed limits;
<ul>
<li><b>512Mb</b> - Maximum SQL Statement result set limit.  If you generate a result set greater than this size
	you may encounter browser memory issues (browser crash).  For "select" statements, consider using
	the OFFSET and LIMIT directives to reduce the total result set.
<li><b>512Mb</b> - Maximum CSV Download size.  If you generate CSV greater than this size you
	may encounter browser memory issues (browser crash).  You may need to break up your
	CSV downloads into chunks by using the SQL Statement pane and specifying appropriate
	OFFSET and LIMIT directives in order to reduce the total result set.
</ul>

<p><h4>Storage Allocation Error</h4></p>
<p>
If you experience this error during the Import phase (<span 
class="error">there was not enough remaining storage space, or the storage quota was reached
and the user declined to allow more space</span>), it may indicate that a request for 
the initial WebSQL database storage was initially successful however during
actual allocation, your browser is enforcing quota restrictions on the amount of usable storage/disk space on 
your device for TEMPORARY objects.  Common quota restrictions for Chrome and Opera on Windows and Android 
platforms for TEMPORARY objects (ie, WebSQL database) may mean that it is necessary to have up to 10 times
the required database storage space available.  Such quota restrictions commonly apply the following rules; 
1) only 50% of remaining storage/disk space on your device will be considered in the usable "pool", 2) of the usable 
"pool" a single web page may only be permitted to use a maximum of 20% of the pool.  In other words, you may need 
up to 10 times free space on your device that what your Offline Visual Field WebSQL database will occupy.
</p>


<p><h4>Offline Web Application</h4><p>
Whilst Visual Field is intended to be able to function as a stand alone file (via the file:// protocol
context), it is also capable of operating as a true offline web application.  To do this, it will
be necessary to place the optional vf_service_workers.js file into the same directory that you have placed vf.html
on your web server.  Please see instructions at <a href="//visualfield.org">visualfield.org</a> on 
how to download and use the vf_service_workers.js file.  The optional vf_service_workers.js file needs to reside in same 
directory that you are hosting vf.html to make it into an offline accessible web application.

</div>
<!-- End General Help - Tips and Troubleshooting Pane -->


<!-- Begin Status Pane -->
<div id="status" style="padding-left: 10px">
<p>
<div style="position: absolute; top: 12px; left: 12px;">
<button onclick="gSTATUS=false; set_visible_pane('home');" title="Menu"><i class="fa fa-bars"></i></button>
<h3 style="display: inline-block;">Status</h3>
<p>
<dl>
    <dt class="hdrb">Tasks Remaining</dt>
    <dd><span id="status_tasks_remaining"></span></dd>
    <dt class="hdrb">Current Task Id</dt>
    <dd><span id="status_current_task_id"></span></dd>
    <dt class="hdrb">Current Task Type</dt>
    <dd><span id="status_current_task_type"></span></dd>
    <dt class="hdrb">Current Task Description</dt>
    <dd><span id="status_current_task_description"></span></dd>
    <dt class="hdrb">URL Fetch Status</dt>
    <dd><span class="urlprogress" style="color:blue;"></span></dd>
    <dt class="hdrb">Table Import Status</dt>
    <dd><span class="importstatus"></span></dd>
    <dt class="hdrb">Custom Function Status</dt>
    <dd><span class="cf_status"></span></dd>
    <dt class="hdrb">SQL Statement Status</dt>
    <dd><span class="sql_progress"></span><span class="sql_summary"></span></dd>
</dl>
</p>
</div>
</p>
</div>
<!-- End Status Pane -->


<!-- Begin About Pane -->
<div id="about" style="padding-left: 10px">
<h3>About</h3>
<p>
<span class="application"></span>

<pre>
Copyright (c) 2019 Harris Hudson
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of
conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list
of conditions and the following disclaimer in the documentation and/or other materials
provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>
</p>
</div>
<!-- End About Pane -->


</div>
<!-- End Main Content -->
<!-- - - - - - - - -  -->

</body>
</html>
